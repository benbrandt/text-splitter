---
source: tests/snapshots.rs
expression: chunks
---
- "// https://github.com/rust-lang/hashbrown/blob/1167d19935f79320d666bf8549f053229567d778/src/rustc_entry.rs\n#[cfg(feature = \"raw\")]"
- "\nuse crate::raw::RawTable;\nuse crate::{Equivalent, TryReserveError};\nuse alloc::borrow::ToOwned;\nuse core::fmt;\nuse core::hash::{BuildHasher, Hash};\nuse core::iter::{Chain, FusedIterator};\nuse core::ops::{BitAnd, BitOr, BitXor, Sub};\n\nuse super::map::{self, DefaultHashBuilder, HashMap, Keys};\nuse crate::raw::{Allocator, Global, RawExtractIf};\n\n// Future Optimization (FIXME!)\n// =============================\n//\n// Iteration over zero sized values is a noop. There is no need\n"
- "// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n// to get rid of it properly.\n\n/// A hash set implemented as a `HashMap` where the value is `()`.\n///\n/// As with the [`HashMap`] type, a `HashSet` requires that the elements\n/// implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by\n/// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n/// it is important that the following property holds:\n///\n/// ```text\n"
- "/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n///\n/// It is a logic error for an item to be modified in such a way that the\n/// item's hash, as determined by the [`Hash`] trait, or its equality, as\n/// determined by the [`Eq`] trait, changes while it is in the set. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n/// unsafe code.\n///\n"
- "/// It is also a logic error for the [`Hash`] implementation of a key to panic.\n/// This is generally only possible if the trait is implemented manually. If a\n/// panic does occur then the contents of the `HashSet` may become corrupted and\n/// some items may be dropped from the table.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashSet<String>` in this example).\n/// let mut books = HashSet::new();\n///\n"
- "/// // Add some books.\n/// books.insert(\"A Dance With Dragons\".to_string());\n/// books.insert(\"To Kill a Mockingbird\".to_string());\n/// books.insert(\"The Odyssey\".to_string());\n/// books.insert(\"The Great Gatsby\".to_string());\n///\n/// // Check for a specific one.\n/// if !books.contains(\"The Winds of Winter\") {\n///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n///              books.len());\n/// }\n///\n/// // Remove a book.\n/// books.remove(\"The Odyssey\");\n///\n"
- "/// // Iterate over everything.\n/// for book in &books {\n///     println!(\"{}\", book);\n/// }\n/// ```\n///\n/// The easiest way to use `HashSet` with a custom type is to derive\n/// [`Eq`] and [`Hash`]. We must also derive [`PartialEq`]. This will in the\n/// future be implied by [`Eq`].\n///\n/// ```\n/// use hashbrown::HashSet;\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     power: usize,\n/// }\n///\n/// let mut vikings = HashSet::new();\n///\n"
- "/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Olaf\".to_string(), power: 4 });\n/// vikings.insert(Viking { name: \"Harald\".to_string(), power: 8 });\n///\n/// // Use derived implementation to print the vikings.\n/// for x in &vikings {\n///     println!(\"{:?}\", x);\n/// }\n/// ```\n///\n/// A `HashSet` with fixed list of elements can be initialized from an array:\n///\n/// ```\n"
- "/// use hashbrown::HashSet;\n///\n/// let viking_names: HashSet<&'static str> =\n///     [ \"Einar\", \"Olaf\", \"Harald\" ].into_iter().collect();\n/// // use the values stored in the set\n/// ```\n///\n/// [`Cell`]: https://doc.rust-lang.org/std/cell/struct.Cell.html\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n/// [`HashMap`]: struct.HashMap.html\n/// [`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n"
- "/// [`RefCell`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html\npub struct HashSet<T, S = DefaultHashBuilder, A: Allocator = Global> {\n    pub(crate) map: HashMap<T, (), S, A>,\n}\n\nimpl<T: Clone, S: Clone, A: Allocator + Clone> Clone for HashSet<T, S, A> {\n    fn clone(&self) -> Self {\n        HashSet {\n            map: self.map.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.map.clone_from(&source.map);\n    }\n}\n\n#[cfg(feature = \"ahash\")]\n"
- "impl<T> HashSet<T, DefaultHashBuilder> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n"
- "    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_hasher`](HashSet::with_hasher) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn new() -> Self {\n        Self {\n            map: HashMap::new(),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n"
- "    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_capacity_and_hasher`](HashSet::with_capacity_and_hasher) method.\n    ///\n"
- "    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self {\n"
- "            map: HashMap::with_capacity(capacity),\n        }\n    }\n}\n\n#[cfg(feature = \"ahash\")]\nimpl<T: Hash + Eq, A: Allocator> HashSet<T, DefaultHashBuilder, A> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n"
- "    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_hasher_in`](HashSet::with_hasher_in) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n"
- "    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn new_in(alloc: A) -> Self {\n        Self {\n            map: HashMap::new_in(alloc),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n"
- "    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n"
- "    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_capacity_and_hasher_in`](HashSet::with_capacity_and_hasher_in) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n"
- "    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Self {\n            map: HashMap::with_capacity_in(capacity, alloc),\n        }\n    }\n}\n\nimpl<T, S, A: Allocator> HashSet<T, S, A> {\n    /// Returns the number of elements the set can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n    /// assert!(set.capacity() >= 100);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn capacity(&self) -> usize {\n        self.map.capacity()\n    }\n\n    /// An iterator visiting all elements in arbitrary order.\n    /// The iterator element type is `&'a T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\");\n    /// set.insert(\"b\");\n"
- "    ///\n    /// // Will print in an arbitrary order.\n    /// for x in set.iter() {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter {\n            iter: self.map.keys(),\n        }\n    }\n\n    /// Returns the number of elements in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert_eq!(v.len(), 0);\n"
- "    /// v.insert(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert!(v.is_empty());\n    /// v.insert(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n"
- "    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Clears the set, returning all elements in an iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert!(!set.is_empty());\n    ///\n    /// // print 1, 2, 3 in an arbitrary order\n    /// for i in set.drain() {\n    ///     println!(\"{}\", i);\n    /// }\n    ///\n    /// assert!(set.is_empty());\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn drain(&mut self) -> Drain<'_, T, A> {\n        Drain {\n            iter: self.map.drain(),\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let xs = [1,2,3,4,5,6];\n    /// let mut set: HashSet<i32> = xs.into_iter().collect();\n"
- "    /// set.retain(|&k| k % 2 == 0);\n    /// assert_eq!(set.len(), 3);\n    /// ```\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.map.retain(|k, _| f(k));\n    }\n\n    /// Drains elements which are true under the given predicate,\n    /// and returns an iterator over the removed items.\n    ///\n    /// In other words, move all elements `e` such that `f(&e)` returns `true` out\n    /// into another iterator.\n    ///\n"
- "    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n    /// or the iteration short-circuits, then the remaining elements will be retained.\n    /// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n    ///\n    /// [`retain()`]: HashSet::retain\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<i32> = (0..8).collect();\n"
- "    /// let drained: HashSet<i32> = set.extract_if(|v| v % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn extract_if<F>(&mut self, f: F) -> ExtractIf<'_, T, F, A>\n    where\n"
- "        F: FnMut(&T) -> bool,\n    {\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.map.table.iter() },\n                table: &mut self.map.table,\n            },\n        }\n    }\n\n    /// Clears the set, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// v.insert(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn clear(&mut self) {\n        self.map.clear();\n    }\n}\n\nimpl<T, S> HashSet<T, S, Global> {\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not\n    /// allocate until it is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n"
- "    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashSet to be useful, see its documentation for details.\n    ///\n"
- "    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_map::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n"
- "    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub const fn with_hasher(hasher: S) -> Self {\n        Self {\n            map: HashMap::with_hasher(hasher),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. "
- "If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n"
- "    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashSet to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_map::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> Self {\n        Self {\n            map: HashMap::with_capacity_and_hasher(capacity, hasher),\n        }\n    }\n}\n\nimpl<T, S, A> HashSet<T, S, A>\nwhere\n"
- "    A: Allocator,\n{\n    /// Returns a reference to the underlying allocator.\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        self.map.allocator()\n    }\n\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not\n    /// allocate until it is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n"
- "    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n"
- "    /// the HashSet to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_map::DefaultHashBuilder;\n    ///\n"
- "    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub const fn with_hasher_in(hasher: S, alloc: A) -> Self {\n        Self {\n            map: HashMap::with_hasher_in(hasher, alloc),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n"
- "    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`ahash::RandomState`] or [`std::collections::hash_map::RandomState`]\n"
- "    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashSet to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n"
- "    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_map::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn with_capacity_and_hasher_in(capacity: usize, hasher: S, alloc: A) -> Self {\n        Self {\n            map: HashMap::with_capacity_and_hasher_in(capacity, hasher, alloc),\n"
- "        }\n    }\n\n    /// Returns a reference to the set's [`BuildHasher`].\n    ///\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_map::DefaultHashBuilder;\n    ///\n    /// let hasher = DefaultHashBuilder::default();\n    /// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n    /// let hasher: &DefaultHashBuilder = set.hasher();\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn hasher(&self) -> &S {\n        self.map.hasher()\n    }\n}\n\nimpl<T, S, A> HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashSet`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n"
- "    /// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n    /// in case of allocation error. Use [`try_reserve`](HashSet::try_reserve) instead\n    /// if you want to handle memory allocation failure.\n    ///\n    /// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n    /// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n"
- "    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.reserve(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn reserve(&mut self, additional: usize) {\n        self.map.reserve(additional);\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashSet<K,V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n"
- "    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.map.try_reserve(additional)\n"
- "    }\n\n    /// Shrinks the capacity of the set as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to_fit();\n    /// assert!("
- "set.capacity() >= 2);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn shrink_to_fit(&mut self) {\n        self.map.shrink_to_fit();\n    }\n\n    /// Shrinks the capacity of the set with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n"
- "    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to(10);\n    /// assert!(set.capacity() >= 10);\n    /// set.shrink_to(0);\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.map.shrink_to(min_capacity);\n    }\n\n"
- "    /// Visits the values representing the difference,\n    /// i.e., the values that are in `self` but not in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Can be seen as `a - b`.\n    /// for x in a.difference(&b) {\n    ///     println!(\"{}\", x); // Print 1\n    /// }\n    ///\n"
- "    /// let diff: HashSet<_> = a.difference(&b).collect();\n    /// assert_eq!(diff, [1].iter().collect());\n    ///\n    /// // Note that difference is not symmetric,\n    /// // and `b - a` means something else:\n    /// let diff: HashSet<_> = b.difference(&a).collect();\n    /// assert_eq!(diff, [4].iter().collect());\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn difference<'a>(&'a self, other: &'a Self) -> Difference<'a, T, S, A> {\n        Difference {\n            iter: self.iter(),\n"
- "            other,\n        }\n    }\n\n    /// Visits the values representing the symmetric difference,\n    /// i.e., the values that are in `self` or in `other` but not in both.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Print 1, 4 in arbitrary order.\n    /// for x in a.symmetric_difference(&b) {\n    ///     println!(\"{}\", x);\n"
- "    /// }\n    ///\n    /// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n    /// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n    ///\n    /// assert_eq!(diff1, diff2);\n    /// assert_eq!(diff1, [1, 4].iter().collect());\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn symmetric_difference<'a>(&'a self, other: &'a Self) -> SymmetricDifference<'a, T, S, A> {\n        SymmetricDifference {\n"
- "            iter: self.difference(other).chain(other.difference(self)),\n        }\n    }\n\n    /// Visits the values representing the intersection,\n    /// i.e., the values that are both in `self` and `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Print 2, 3 in arbitrary order.\n    /// for x in a.intersection(&b) {\n"
- "    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let intersection: HashSet<_> = a.intersection(&b).collect();\n    /// assert_eq!(intersection, [2, 3].iter().collect());\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn intersection<'a>(&'a self, other: &'a Self) -> Intersection<'a, T, S, A> {\n        let (smaller, larger) = if self.len() <= other.len() {\n            (self, other)\n        } else {\n            (other, self)\n        };\n        Intersection {\n"
- "            iter: smaller.iter(),\n            other: larger,\n        }\n    }\n\n    /// Visits the values representing the union,\n    /// i.e., all the values in `self` or `other`, without duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order.\n    /// for x in a.union(&b) {\n"
- "    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let union: HashSet<_> = a.union(&b).collect();\n    /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn union<'a>(&'a self, other: &'a Self) -> Union<'a, T, S, A> {\n        // We'll iterate one set in full, and only the remaining difference from the other.\n        // Use the smaller set for the difference in order to reduce hash lookups.\n"
- "        let (smaller, larger) = if self.len() <= other.len() {\n            (self, other)\n        } else {\n            (other, self)\n        };\n        Union {\n            iter: larger.iter().chain(smaller.difference(larger)),\n        }\n    }\n\n    /// Returns `true` if the set contains a value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n"
- "    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.contains(&1), true);\n    /// assert_eq!(set.contains(&4), false);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n    where\n        Q: Hash + Equivalent<T>,\n    {\n"
- "        self.map.contains_key(value)\n    }\n\n    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.get(&2), Some(&2));\n"
- "    /// assert_eq!(set.get(&4), None);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        Q: Hash + Equivalent<T>,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.map.get_key_value(value) {\n            Some((k, _)) => Some(k),\n"
- "            None => None,\n        }\n    }\n\n    /// Inserts the given `value` into the set if it is not present, then\n    /// returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.len(), 3);\n    /// assert_eq!(set.get_or_insert(2), &2);\n    /// assert_eq!(set.get_or_insert(100), &100);\n    /// assert_eq!(set.len(), 4); // 100 was inserted\n"
- "    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get_or_insert(&mut self, value: T) -> &T {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.map\n            .raw_entry_mut()\n            .from_key(&value)\n            .or_insert(value, ())\n            .0\n    }\n\n"
- "    /// Inserts an owned copy of the given `value` into the set if it is not\n    /// present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_owned(pet);\n"
- "    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    pub fn get_or_insert_owned<Q: ?Sized>(&mut self, value: &Q) -> &T\n    where\n        Q: Hash + Equivalent<T> + ToOwned<Owned = T>,\n    {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.map\n            .raw_entry_mut()\n"
- "            .from_key(value)\n            .or_insert_with(|| (value.to_owned(), ()))\n            .0\n    }\n\n    /// Inserts a value computed from `f` into the set if the given `value` is\n    /// not present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n"
- "    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T\n    where\n        Q: Hash + Equivalent<T>,\n        F: FnOnce(&Q) -> T,\n    {\n"
- "        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.map\n            .raw_entry_mut()\n            .from_key(value)\n            .or_insert_with(|| (f(value), ()))\n            .0\n    }\n\n    /// Gets the given value's corresponding entry in the set for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_set::Entry::*;\n    ///\n    /// let mut singles = HashSet::new();\n    /// let mut dupes = HashSet::new();\n    ///\n    /// for ch in \"a short treatise on fungi\".chars() {\n    ///     if let Vacant(dupe_entry) = dupes.entry(ch) {\n    ///         // We haven't already seen a duplicate, so\n    ///         // check if we've at least seen it once.\n    ///         match singles.entry(ch) {\n    ///             Vacant(single_entry) => {\n"
- "    ///                 // We found a new character for the first time.\n    ///                 single_entry.insert();\n    ///             }\n    ///             Occupied(single_entry) => {\n    ///                 // We've already seen this once, \"move\" it to dupes.\n    ///                 single_entry.remove();\n    ///                 dupe_entry.insert();\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert!(!singles.contains(&'t') && dupes.contains(&'t'));\n    /// assert!("
- "singles.contains(&'u') && !dupes.contains(&'u'));\n    /// assert!(!singles.contains(&'v') && !dupes.contains(&'v'));\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn entry(&mut self, value: T) -> Entry<'_, T, S, A> {\n        match self.map.entry(value) {\n            map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { inner: entry }),\n            map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { inner: entry }),\n        }\n    }\n\n"
- "    /// Returns `true` if `self` has no elements in common with `other`.\n    /// This is equivalent to checking for an empty intersection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let mut b = HashSet::new();\n    ///\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(4);\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(1);\n    /// assert_eq!(a.is_disjoint(&b), false);\n"
- "    /// ```\n    pub fn is_disjoint(&self, other: &Self) -> bool {\n        self.iter().all(|v| !other.contains(v))\n    }\n\n    /// Returns `true` if the set is a subset of another,\n    /// i.e., `other` contains at least all the values in `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let sup: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(2);\n"
- "    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(4);\n    /// assert_eq!(set.is_subset(&sup), false);\n    /// ```\n    pub fn is_subset(&self, other: &Self) -> bool {\n        self.len() <= other.len() && self.iter().all(|v| other.contains(v))\n    }\n\n    /// Returns `true` if the set is a superset of another,\n    /// i.e., `self` contains at least all the values in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n"
- "    /// let sub: HashSet<_> = [1, 2].into_iter().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(0);\n    /// set.insert(1);\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.is_superset(&sub), true);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn is_superset(&self, other: &Self) -> bool {\n        other.is_subset(self)\n    }\n\n"
- "    /// Adds a value to the set.\n    ///\n    /// If the set did not have this value present, `true` is returned.\n    ///\n    /// If the set did have this value present, `false` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.insert(2), true);\n    /// assert_eq!(set.insert(2), false);\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n"
- "    pub fn insert(&mut self, value: T) -> bool {\n        self.map.insert(value, ()).is_none()\n    }\n\n    /// Insert a value the set without checking if the value already exists in the set.\n    ///\n    /// Returns a reference to the value just inserted.\n    ///\n    /// This operation is safe if a value does not exist in the set.\n    ///\n    /// However, if a value exists in the set already, the behavior is unspecified:\n    /// this operation may panic, loop forever, or any following operation with the set\n"
- "    /// may panic, loop forever or return arbitrary result.\n    ///\n    /// That said, this operation (and following operations) are guaranteed to\n    /// not violate memory safety.\n    ///\n    /// This operation is faster than regular insert, because it does not perform\n    /// lookup before insertion.\n    ///\n    /// This operation is useful during initial population of the set.\n    /// For example, when constructing a set from another set, we know\n    /// that values are unique.\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn insert_unique_unchecked(&mut self, value: T) -> &T {\n        self.map.insert_unique_unchecked(value, ()).0\n    }\n\n    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n    /// one. Returns the replaced value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    /// set.insert(Vec::<i32>::new());\n    ///\n    /// assert_eq!("
- "set.get(&[][..]).unwrap().capacity(), 0);\n    /// set.replace(Vec::with_capacity(10));\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n        match self.map.entry(value) {\n            map::Entry::Occupied(occupied) => Some(occupied.replace_key()),\n            map::Entry::Vacant(vacant) => {\n                vacant.insert(());\n                None\n            }\n        }\n    }\n\n"
- "    /// Removes a value from the set. Returns whether the value was\n    /// present in the set.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.remove(&2), true);\n    /// assert_eq!("
- "set.remove(&2), false);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n    where\n        Q: Hash + Equivalent<T>,\n    {\n        self.map.remove(value).is_some()\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the given one.\n    ///\n"
- "    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.take(&2), Some(2));\n    /// assert_eq!(set.take(&2), None);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n"
- "    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: Hash + Equivalent<T>,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.map.remove_entry(value) {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n}\n\nimpl<T, S, A: Allocator> HashSet<T, S, A> {\n"
- "    /// Returns a reference to the [`RawTable`] used underneath [`HashSet`].\n    /// This function is only available if the `raw` feature of the crate is enabled.\n    ///\n    /// # Note\n    ///\n    /// Calling this function is safe, but using the raw hash table API may require\n    /// unsafe functions or blocks.\n    ///\n    /// `RawTable` API gives the lowest level of control under the set that can be useful\n    /// for extending the HashSet's API, but may lead to *[undefined behavior]*.\n    ///\n"
- "    /// [`HashSet`]: struct.HashSet.html\n    /// [`RawTable`]: crate::raw::RawTable\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[cfg(feature = \"raw\")]\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn raw_table(&self) -> &RawTable<(T, ()), A> {\n        self.map.raw_table()\n    }\n\n    /// Returns a mutable reference to the [`RawTable`] used underneath [`HashSet`].\n"
- "    /// This function is only available if the `raw` feature of the crate is enabled.\n    ///\n    /// # Note\n    ///\n    /// Calling this function is safe, but using the raw hash table API may require\n    /// unsafe functions or blocks.\n    ///\n    /// `RawTable` API gives the lowest level of control under the set that can be useful\n    /// for extending the HashSet's API, but may lead to *[undefined behavior]*.\n    ///\n    /// [`HashSet`]: struct.HashSet.html\n    /// [`RawTable`]: crate::raw::RawTable\n"
- "    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[cfg(feature = \"raw\")]\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn raw_table_mut(&mut self) -> &mut RawTable<(T, ()), A> {\n        self.map.raw_table_mut()\n    }\n}\n\nimpl<T, S, A> PartialEq for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n"
- "\n        self.iter().all(|key| other.contains(key))\n    }\n}\n\nimpl<T, S, A> Eq for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}\n\nimpl<T, S, A> fmt::Debug for HashSet<T, S, A>\nwhere\n    T: fmt::Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}\n\nimpl<T, S, A> From<HashMap<T, (), S, A>> for HashSet<T, S, A>\nwhere\n    A: Allocator,\n{\n"
- "    fn from(map: HashMap<T, (), S, A>) -> Self {\n        Self { map }\n    }\n}\n\nimpl<T, S, A> FromIterator<T> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher + Default,\n    A: Default + Allocator,\n{\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        let mut set = Self::with_hasher_in(Default::default(), Default::default());\n        set.extend(iter);\n        set\n    }\n}\n\n"
- "// The default hasher is used to match the std implementation signature\n#[cfg(feature = \"ahash\")]\nimpl<T, A, const N: usize> From<[T; N]> for HashSet<T, DefaultHashBuilder, A>\nwhere\n    T: Eq + Hash,\n    A: Default + Allocator,\n{\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let set1 = HashSet::from([1, 2, 3, 4]);\n    /// let set2: HashSet<_> = [1, 2, 3, 4].into();\n    /// assert_eq!(set1, set2);\n    /// ```\n    fn from(arr: [T; N]) -> Self {\n"
- "        arr.into_iter().collect()\n    }\n}\n\nimpl<T, S, A> Extend<T> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        self.map.extend(iter.into_iter().map(|k| (k, ())));\n    }\n\n    #[inline]\n    #[cfg(feature = \"nightly\")]\n    fn extend_one(&mut self, k: T) {\n        self.map.insert(k, ());\n    }\n\n    #[inline]\n    #[cfg(feature = \"nightly\")]\n"
- "    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(T, ())>::extend_reserve(&mut self.map, additional);\n    }\n}\n\nimpl<'a, T, S, A> Extend<&'a T> for HashSet<T, S, A>\nwhere\n    T: 'a + Eq + Hash + Copy,\n    S: BuildHasher,\n    A: Allocator,\n{\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().copied());\n    }\n\n    #[inline]\n    #[cfg(feature = \"nightly\")]\n"
- "    fn extend_one(&mut self, k: &'a T) {\n        self.map.insert(*k, ());\n    }\n\n    #[inline]\n    #[cfg(feature = \"nightly\")]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(T, ())>::extend_reserve(&mut self.map, additional);\n    }\n}\n\nimpl<T, S, A> Default for HashSet<T, S, A>\nwhere\n    S: Default,\n    A: Default + Allocator,\n{\n    /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n    #[cfg_attr(feature = \"inline-more\", inline)]\n"
- "    fn default() -> Self {\n        Self {\n            map: HashMap::default(),\n        }\n    }\n}\n\nimpl<T, S, A> BitOr<&HashSet<T, S, A>> for &HashSet<T, S, A>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n    A: Allocator,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a | &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 3, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitor(self, rhs: &HashSet<T, S, A>) -> HashSet<T, S> {\n        self.union(rhs).cloned().collect()\n    }\n}\n\nimpl<T, S, A> BitAnd<&HashSet<T, S, A>> for &HashSet<T, S, A>\nwhere\n"
- "    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n    A: Allocator,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// let set = &a & &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [2, 3];\n"
- "    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitand(self, rhs: &HashSet<T, S, A>) -> HashSet<T, S> {\n        self.intersection(rhs).cloned().collect()\n    }\n}\n\nimpl<T, S> BitXor<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a ^ &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n"
- "    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.symmetric_difference(rhs).cloned().collect()\n    }\n}\n\nimpl<T, S> Sub<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a - &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.difference(rhs).cloned().collect()\n    }\n}\n\n/// An iterator over the items of a `HashSet`.\n///\n"
- "/// This `struct` is created by the [`iter`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`iter`]: struct.HashSet.html#method.iter\npub struct Iter<'a, K> {\n    iter: Keys<'a, K, ()>,\n}\n\n/// An owning iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n"
- "/// [`into_iter`]: struct.HashSet.html#method.into_iter\npub struct IntoIter<K, A: Allocator = Global> {\n    iter: map::IntoIter<K, (), A>,\n}\n\n/// A draining iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`drain`]: struct.HashSet.html#method.drain\npub struct Drain<'a, K, A: Allocator = Global> {\n    iter: map::Drain<'a, K, (), A>,\n}\n\n"
- "/// A draining iterator over entries of a `HashSet` which don't satisfy the predicate `f`.\n///\n/// This `struct` is created by the [`extract_if`] method on [`HashSet`]. See its\n/// documentation for more.\n///\n/// [`extract_if`]: struct.HashSet.html#method.extract_if\n/// [`HashSet`]: struct.HashSet.html\n#[must_use = \"Iterators are lazy unless consumed\"]\npub struct ExtractIf<'a, K, F, A: Allocator = Global>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    f: F,\n    inner: RawExtractIf<'a, (K, ()), A>,\n}\n\n"
- "/// A lazy iterator producing elements in the intersection of `HashSet`s.\n///\n/// This `struct` is created by the [`intersection`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`intersection`]: struct.HashSet.html#method.intersection\npub struct Intersection<'a, T, S, A: Allocator = Global> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S, A>,\n}\n\n"
- "/// A lazy iterator producing elements in the difference of `HashSet`s.\n///\n/// This `struct` is created by the [`difference`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`difference`]: struct.HashSet.html#method.difference\npub struct Difference<'a, T, S, A: Allocator = Global> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S, A>,\n}\n\n"
- "/// A lazy iterator producing elements in the symmetric difference of `HashSet`s.\n///\n/// This `struct` is created by the [`symmetric_difference`] method on\n/// [`HashSet`]. See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`symmetric_difference`]: struct.HashSet.html#method.symmetric_difference\npub struct SymmetricDifference<'a, T, S, A: Allocator = Global> {\n    iter: Chain<Difference<'a, T, S, A>, Difference<'a, T, S, A>>,\n}\n\n"
- "/// A lazy iterator producing elements in the union of `HashSet`s.\n///\n/// This `struct` is created by the [`union`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`union`]: struct.HashSet.html#method.union\npub struct Union<'a, T, S, A: Allocator = Global> {\n    iter: Chain<Iter<'a, T>, Difference<'a, T, S, A>>,\n}\n\nimpl<'a, T, S, A: Allocator> IntoIterator for &'a HashSet<T, S, A> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\nimpl<T, S, A: Allocator> IntoIterator for HashSet<T, S, A> {\n    type Item = T;\n    type IntoIter = IntoIter<T, A>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out\n    /// of the set in arbitrary order. The set cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n"
- "    /// let mut set = HashSet::new();\n    /// set.insert(\"a\".to_string());\n    /// set.insert(\"b\".to_string());\n    ///\n    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n    /// let v: Vec<String> = set.into_iter().collect();\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in &v {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn into_iter(self) -> IntoIter<T, A> {\n        IntoIter {\n"
- "            iter: self.map.into_iter(),\n        }\n    }\n}\n\nimpl<K> Clone for Iter<'_, K> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn clone(&self) -> Self {\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }\n}\nimpl<'a, K> Iterator for Iter<'a, K> {\n    type Item = &'a K;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<&'a K> {\n        self.iter.next()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}\nimpl<'a, K> ExactSizeIterator for Iter<'a, K> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\nimpl<K> FusedIterator for Iter<'_, K> {}\n\n"
- "impl<K: fmt::Debug> fmt::Debug for Iter<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\nimpl<K, A: Allocator> Iterator for IntoIter<K, A> {\n    type Item = K;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<K> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.iter.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, (k, ())| f(acc, k))\n    }\n}\nimpl<K, A: Allocator> ExactSizeIterator for IntoIter<K, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn len(&self) -> usize {\n"
- "        self.iter.len()\n    }\n}\nimpl<K, A: Allocator> FusedIterator for IntoIter<K, A> {}\n\nimpl<K: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<K, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let entries_iter = self.iter.iter().map(|(k, _)| k);\n        f.debug_list().entries(entries_iter).finish()\n    }\n}\n\nimpl<K, A: Allocator> Iterator for Drain<'_, K, A> {\n    type Item = K;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<K> {\n"
- "        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.iter.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, |acc, (k, ())| f(acc, k))\n    }\n}\nimpl<K, A: Allocator> ExactSizeIterator for Drain<'_, K, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\nimpl<K, A: Allocator> FusedIterator for Drain<'_, K, A> {}\n\nimpl<K: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, K, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let entries_iter = self.iter.iter().map(|(k, _)| k);\n"
- "        f.debug_list().entries(entries_iter).finish()\n    }\n}\n\nimpl<K, F, A: Allocator> Iterator for ExtractIf<'_, K, F, A>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    type Item = K;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next(|&mut (ref k, ())| (self.f)(k))\n            .map(|(k, ())| k)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.inner.iter.size_hint().1)\n    }\n}\n\n"
- "impl<K, F, A: Allocator> FusedIterator for ExtractIf<'_, K, F, A> where F: FnMut(&K) -> bool {}\n\nimpl<T, S, A: Allocator> Clone for Intersection<'_, T, S, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn clone(&self) -> Self {\n        Intersection {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }\n}\n\nimpl<'a, T, S, A> Iterator for Intersection<'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &'a T;\n\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<&'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, elt| {\n            if self.other.contains(elt) {\n                f(acc, elt)\n            } else {\n                acc\n            }\n        })\n    }\n}\n\nimpl<T, S, A> fmt::Debug for Intersection<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n"
- "        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\nimpl<T, S, A> FusedIterator for Intersection<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}\n\nimpl<T, S, A: Allocator> Clone for Difference<'_, T, S, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn clone(&self) -> Self {\n        Difference {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }\n}\n\nimpl<'a, T, S, A> Iterator for Difference<'a, T, S, A>\nwhere\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &'a T;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<&'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if !self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, elt| {\n            if self.other.contains(elt) {\n                acc\n            } else {\n                f(acc, elt)\n            }\n        })\n    }\n}\n\nimpl<T, S, A> FusedIterator for Difference<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for Difference<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\nimpl<T, S, A: Allocator> Clone for SymmetricDifference<'_, T, S, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn clone(&self) -> Self {\n        SymmetricDifference {\n            iter: self.iter.clone(),\n        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for SymmetricDifference<'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &'a T;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n"
- "    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}\n\nimpl<T, S, A> FusedIterator for SymmetricDifference<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}\n\nimpl<T, S, A> fmt::Debug for SymmetricDifference<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n"
- "\nimpl<T, S, A: Allocator> Clone for Union<'_, T, S, A> {\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn clone(&self) -> Self {\n        Union {\n            iter: self.iter.clone(),\n        }\n    }\n}\n\nimpl<T, S, A> FusedIterator for Union<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}\n\nimpl<T, S, A> fmt::Debug for Union<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n"
- "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\nimpl<'a, T, S, A> Iterator for Union<'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &'a T;\n\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n"
- "        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}\n\n/// A view into a single entry in a set, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashSet`].\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`entry`]: struct.HashSet.html#method.entry\n///\n/// # Examples\n"
- "///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet, OccupiedEntry};\n///\n/// let mut set = HashSet::new();\n/// set.extend([\"a\", \"b\", \"c\"]);\n/// assert_eq!(set.len(), 3);\n///\n/// // Existing value (insert)\n/// let entry: Entry<_, _> = set.entry(\"a\");\n/// let _raw_o: OccupiedEntry<_, _> = entry.insert();\n/// assert_eq!(set.len(), 3);\n/// // Nonexistent value (insert)\n/// set.entry(\"d\").insert();\n///\n/// // Existing value (or_insert)\n/// set.entry(\"b\").or_insert();\n/// // Nonexistent value (or_insert)\n"
- "/// set.entry(\"e\").or_insert();\n///\n/// println!(\"Our HashSet: {:?}\", set);\n///\n/// let mut vec: Vec<_> = set.iter().copied().collect();\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [\"a\", \"b\", \"c\", \"d\", \"e\"]);\n/// ```\npub enum Entry<'a, T, S, A = Global>\nwhere\n    A: Allocator,\n{\n    /// An occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n"
- "    /// use hashbrown::hash_set::{Entry, HashSet};\n    /// let mut set: HashSet<_> = [\"a\", \"b\"].into();\n    ///\n    /// match set.entry(\"a\") {\n    ///     Entry::Vacant(_) => unreachable!(),\n    ///     Entry::Occupied(_) => { }\n    /// }\n    /// ```\n    Occupied(OccupiedEntry<'a, T, S, A>),\n\n    /// A vacant entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// match set.entry(\"a\") {\n"
- "    ///     Entry::Occupied(_) => unreachable!(),\n    ///     Entry::Vacant(_) => { }\n    /// }\n    /// ```\n    Vacant(VacantEntry<'a, T, S, A>),\n}\n\nimpl<T: fmt::Debug, S, A: Allocator> fmt::Debug for Entry<'_, T, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n        }\n    }\n}\n\n"
- "/// A view into an occupied entry in a `HashSet`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet, OccupiedEntry};\n///\n/// let mut set = HashSet::new();\n/// set.extend([\"a\", \"b\", \"c\"]);\n///\n/// let _entry_o: OccupiedEntry<_, _> = set.entry(\"a\").insert();\n/// assert_eq!(set.len(), 3);\n///\n/// // Existing key\n/// match set.entry(\"a\") {\n///     Entry::Vacant(_) => unreachable!(),\n"
- "///     Entry::Occupied(view) => {\n///         assert_eq!(view.get(), &\"a\");\n///     }\n/// }\n///\n/// assert_eq!(set.len(), 3);\n///\n/// // Existing key (take)\n/// match set.entry(\"c\") {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(view) => {\n///         assert_eq!(view.remove(), \"c\");\n///     }\n/// }\n/// assert_eq!(set.get(&\"c\"), None);\n/// assert_eq!(set.len(), 2);\n/// ```\npub struct OccupiedEntry<'a, T, S, A: Allocator = Global> {\n    inner: map::OccupiedEntry<'a, T, (), S, A>,\n}\n\n"
- "impl<T: fmt::Debug, S, A: Allocator> fmt::Debug for OccupiedEntry<'_, T, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"OccupiedEntry\")\n            .field(\"value\", self.get())\n            .finish()\n    }\n}\n\n/// A view into a vacant entry in a `HashSet`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet, VacantEntry};\n///\n/// let mut set = HashSet::<&str>::new();\n"
- "///\n/// let entry_v: VacantEntry<_, _> = match set.entry(\"a\") {\n///     Entry::Vacant(view) => view,\n///     Entry::Occupied(_) => unreachable!(),\n/// };\n/// entry_v.insert();\n/// assert!(set.contains(\"a\") && set.len() == 1);\n///\n/// // Nonexistent key (insert)\n/// match set.entry(\"b\") {\n///     Entry::Vacant(view) => { view.insert(); },\n///     Entry::Occupied(_) => unreachable!(),\n/// }\n/// assert!(set.contains(\"b\") && set.len() == 2);\n/// ```\npub struct VacantEntry<'a, T, S, A: Allocator = Global> {\n"
- "    inner: map::VacantEntry<'a, T, (), S, A>,\n}\n\nimpl<T: fmt::Debug, S, A: Allocator> fmt::Debug for VacantEntry<'_, T, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"VacantEntry\").field(self.get()).finish()\n    }\n}\n\nimpl<'a, T, S, A: Allocator> Entry<'a, T, S, A> {\n    /// Sets the value of the entry, and returns an OccupiedEntry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n"
- "    /// let mut set: HashSet<&str> = HashSet::new();\n    /// let entry = set.entry(\"horseyland\").insert();\n    ///\n    /// assert_eq!(entry.get(), &\"horseyland\");\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn insert(self) -> OccupiedEntry<'a, T, S, A>\n    where\n        T: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(),\n        }\n    }\n\n"
- "    /// Ensures a value is in the entry by inserting if it was vacant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// // nonexistent key\n    /// set.entry(\"poneyland\").or_insert();\n    /// assert!(set.contains(\"poneyland\"));\n    ///\n    /// // existing key\n    /// set.entry(\"poneyland\").or_insert();\n    /// assert!(set.contains(\"poneyland\"));\n    /// assert_eq!(set.len(), 1);\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn or_insert(self)\n    where\n        T: Hash,\n        S: BuildHasher,\n    {\n        if let Entry::Vacant(entry) = self {\n            entry.insert();\n        }\n    }\n\n    /// Returns a reference to this entry's value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// set.entry(\"poneyland\").or_insert();\n    /// // existing key\n    /// assert_eq!("
- "set.entry(\"poneyland\").get(), &\"poneyland\");\n    /// // nonexistent key\n    /// assert_eq!(set.entry(\"horseland\").get(), &\"horseland\");\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get(&self) -> &T {\n        match *self {\n            Entry::Occupied(ref entry) => entry.get(),\n            Entry::Vacant(ref entry) => entry.get(),\n        }\n    }\n}\n\nimpl<T, S, A: Allocator> OccupiedEntry<'_, T, S, A> {\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// set.entry(\"poneyland\").or_insert();\n    ///\n    /// match set.entry(\"poneyland\") {\n    ///     Entry::Vacant(_) => panic!(),\n    ///     Entry::Occupied(entry) => assert_eq!(entry.get(), &\"poneyland\"),\n    /// }\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get(&self) -> &T {\n        self.inner.key()\n    }\n\n"
- "    /// Takes the value out of the entry, and returns it.\n    /// Keeps the allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_set::Entry;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// // The set is empty\n    /// assert!(set.is_empty() && set.capacity() == 0);\n    ///\n    /// set.entry(\"poneyland\").or_insert();\n    /// let capacity_before_remove = set.capacity();\n    ///\n"
- "    /// if let Entry::Occupied(o) = set.entry(\"poneyland\") {\n    ///     assert_eq!(o.remove(), \"poneyland\");\n    /// }\n    ///\n    /// assert_eq!(set.contains(\"poneyland\"), false);\n    /// // Now set hold none elements but capacity is equal to the old one\n    /// assert!(set.len() == 0 && set.capacity() == capacity_before_remove);\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn remove(self) -> T {\n        self.inner.remove_entry().0\n    }\n\n"
- "    /// Replaces the entry, returning the old value. The new value in the hash map will be\n    /// the value used to create this entry.\n    ///\n    /// # Panics\n    ///\n    /// Will panic if this OccupiedEntry was created through [`Entry::insert`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    ///  use hashbrown::hash_set::{Entry, HashSet};\n    ///  use std::rc::Rc;\n    ///\n    ///  let mut set: HashSet<Rc<String>> = HashSet::new();\n    ///  let key_one = Rc::new(\"Stringthing\".to_string());\n"
- "    ///  let key_two = Rc::new(\"Stringthing\".to_string());\n    ///\n    ///  set.insert(key_one.clone());\n    ///  assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n    ///\n    ///  match set.entry(key_two.clone()) {\n    ///      Entry::Occupied(entry) => {\n    ///          let old_key: Rc<String> = entry.replace();\n    ///          assert!(Rc::ptr_eq(&key_one, &old_key));\n    ///      }\n    ///      Entry::Vacant(_) => panic!(),\n    ///  }\n    ///\n    ///  assert!("
- "Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    ///  assert!(set.contains(&\"Stringthing\".to_owned()));\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn replace(self) -> T {\n        self.inner.replace_key()\n    }\n}\n\nimpl<'a, T, S, A: Allocator> VacantEntry<'a, T, S, A> {\n    /// Gets a reference to the value that would be used when inserting\n    /// through the `VacantEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n"
- "    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// assert_eq!(set.entry(\"poneyland\").get(), &\"poneyland\");\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn get(&self) -> &T {\n        self.inner.key()\n    }\n\n    /// Take ownership of the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// match set.entry(\"poneyland\") {\n"
- "    ///     Entry::Occupied(_) => panic!(),\n    ///     Entry::Vacant(v) => assert_eq!(v.into_value(), \"poneyland\"),\n    /// }\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn into_value(self) -> T {\n        self.inner.into_key()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_set::Entry;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n"
- "    ///\n    /// if let Entry::Vacant(o) = set.entry(\"poneyland\") {\n    ///     o.insert();\n    /// }\n    /// assert!(set.contains(\"poneyland\"));\n    /// ```\n    #[cfg_attr(feature = \"inline-more\", inline)]\n    pub fn insert(self) -> OccupiedEntry<'a, T, S, A>\n    where\n        T: Hash,\n        S: BuildHasher,\n    {\n        OccupiedEntry {\n            inner: self.inner.insert_entry(()),\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n"
- "    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> {\n        v\n    }\n    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n        v\n    }\n    fn into_iter<'new, A: Allocator>(v: IntoIter<&'static str, A>) -> IntoIter<&'new str, A> {\n        v\n    }\n    fn difference<'a, 'new, A: Allocator>(\n        v: Difference<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Difference<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n"
- "    fn symmetric_difference<'a, 'new, A: Allocator>(\n        v: SymmetricDifference<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> SymmetricDifference<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn intersection<'a, 'new, A: Allocator>(\n        v: Intersection<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Intersection<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn union<'a, 'new, A: Allocator>(\n        v: Union<'a, &'static str, DefaultHashBuilder, A>,\n"
- "    ) -> Union<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn drain<'new, A: Allocator>(d: Drain<'static, &'static str, A>) -> Drain<'new, &'new str, A> {\n        d\n    }\n}\n\n#[cfg(test)]\nmod test_set {\n    use super::super::map::DefaultHashBuilder;\n    use super::HashSet;\n    use std::vec::Vec;\n\n    #[test]\n    fn test_zero_capacities() {\n        type HS = HashSet<i32>;\n\n        let s = HS::new();\n        assert_eq!(s.capacity(), 0);\n\n        let s = HS::default();\n        assert_eq!("
- "s.capacity(), 0);\n\n        let s = HS::with_hasher(DefaultHashBuilder::default());\n        assert_eq!(s.capacity(), 0);\n\n        let s = HS::with_capacity(0);\n        assert_eq!(s.capacity(), 0);\n\n        let s = HS::with_capacity_and_hasher(0, DefaultHashBuilder::default());\n        assert_eq!(s.capacity(), 0);\n\n        let mut s = HS::new();\n        s.insert(1);\n        s.insert(2);\n        s.remove(&1);\n        s.remove(&2);\n        s.shrink_to_fit();\n        assert_eq!(s.capacity(), 0);\n\n"
- "        let mut s = HS::new();\n        s.reserve(0);\n        assert_eq!(s.capacity(), 0);\n    }\n\n    #[test]\n    fn test_disjoint() {\n        let mut xs = HashSet::new();\n        let mut ys = HashSet::new();\n        assert!(xs.is_disjoint(&ys));\n        assert!(ys.is_disjoint(&xs));\n        assert!(xs.insert(5));\n        assert!(ys.insert(11));\n        assert!(xs.is_disjoint(&ys));\n        assert!(ys.is_disjoint(&xs));\n        assert!(xs.insert(7));\n        assert!(xs.insert(19));\n        assert!("
- "xs.insert(4));\n        assert!(ys.insert(2));\n        assert!(ys.insert(-11));\n        assert!(xs.is_disjoint(&ys));\n        assert!(ys.is_disjoint(&xs));\n        assert!(ys.insert(7));\n        assert!(!xs.is_disjoint(&ys));\n        assert!(!ys.is_disjoint(&xs));\n    }\n\n    #[test]\n    fn test_subset_and_superset() {\n        let mut a = HashSet::new();\n        assert!(a.insert(0));\n        assert!(a.insert(5));\n        assert!(a.insert(11));\n        assert!(a.insert(7));\n\n"
- "        let mut b = HashSet::new();\n        assert!(b.insert(0));\n        assert!(b.insert(7));\n        assert!(b.insert(19));\n        assert!(b.insert(250));\n        assert!(b.insert(11));\n        assert!(b.insert(200));\n\n        assert!(!a.is_subset(&b));\n        assert!(!a.is_superset(&b));\n        assert!(!b.is_subset(&a));\n        assert!(!b.is_superset(&a));\n\n        assert!(b.insert(5));\n\n        assert!(a.is_subset(&b));\n        assert!(!a.is_superset(&b));\n        assert!(!b.is_subset(&a));\n"
- "        assert!(b.is_superset(&a));\n    }\n\n    #[test]\n    fn test_iterate() {\n        let mut a = HashSet::new();\n        for i in 0..32 {\n            assert!(a.insert(i));\n        }\n        let mut observed: u32 = 0;\n        for k in &a {\n            observed |= 1 << *k;\n        }\n        assert_eq!(observed, 0xFFFF_FFFF);\n    }\n\n    #[test]\n    fn test_intersection() {\n        let mut a = HashSet::new();\n        let mut b = HashSet::new();\n\n        assert!(a.insert(11));\n        assert!(a.insert(1));\n"
- "        assert!(a.insert(3));\n        assert!(a.insert(77));\n        assert!(a.insert(103));\n        assert!(a.insert(5));\n        assert!(a.insert(-5));\n\n        assert!(b.insert(2));\n        assert!(b.insert(11));\n        assert!(b.insert(77));\n        assert!(b.insert(-9));\n        assert!(b.insert(-42));\n        assert!(b.insert(5));\n        assert!(b.insert(3));\n\n        let mut i = 0;\n        let expected = [3, 5, 11, 77];\n        for x in a.intersection(&b) {\n            assert!("
- "expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_difference() {\n        let mut a = HashSet::new();\n        let mut b = HashSet::new();\n\n        assert!(a.insert(1));\n        assert!(a.insert(3));\n        assert!(a.insert(5));\n        assert!(a.insert(9));\n        assert!(a.insert(11));\n\n        assert!(b.insert(3));\n        assert!(b.insert(9));\n\n        let mut i = 0;\n        let expected = [1, 5, 11];\n"
- "        for x in a.difference(&b) {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_symmetric_difference() {\n        let mut a = HashSet::new();\n        let mut b = HashSet::new();\n\n        assert!(a.insert(1));\n        assert!(a.insert(3));\n        assert!(a.insert(5));\n        assert!(a.insert(9));\n        assert!(a.insert(11));\n\n        assert!(b.insert(-2));\n        assert!(b.insert(3));\n        assert!("
- "b.insert(9));\n        assert!(b.insert(14));\n        assert!(b.insert(22));\n\n        let mut i = 0;\n        let expected = [-2, 1, 5, 11, 14, 22];\n        for x in a.symmetric_difference(&b) {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_union() {\n        let mut a = HashSet::new();\n        let mut b = HashSet::new();\n\n        assert!(a.insert(1));\n        assert!(a.insert(3));\n        assert!(a.insert(5));\n"
- "        assert!(a.insert(9));\n        assert!(a.insert(11));\n        assert!(a.insert(16));\n        assert!(a.insert(19));\n        assert!(a.insert(24));\n\n        assert!(b.insert(-2));\n        assert!(b.insert(1));\n        assert!(b.insert(5));\n        assert!(b.insert(9));\n        assert!(b.insert(13));\n        assert!(b.insert(19));\n\n        let mut i = 0;\n        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n        for x in a.union(&b) {\n            assert!(expected.contains(x));\n"
- "            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_from_map() {\n        let mut a = crate::HashMap::new();\n        a.insert(1, ());\n        a.insert(2, ());\n        a.insert(3, ());\n        a.insert(4, ());\n\n        let a: HashSet<_> = a.into();\n\n        assert_eq!(a.len(), 4);\n        assert!(a.contains(&1));\n        assert!(a.contains(&2));\n        assert!(a.contains(&3));\n        assert!(a.contains(&4));\n    }\n\n    #[test]\n    fn test_from_iter() {\n"
- "        let xs = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];\n\n        let set: HashSet<_> = xs.iter().copied().collect();\n\n        for x in &xs {\n            assert!(set.contains(x));\n        }\n\n        assert_eq!(set.iter().len(), xs.len() - 1);\n    }\n\n    #[test]\n    fn test_move_iter() {\n        let hs = {\n            let mut hs = HashSet::new();\n\n            hs.insert('a');\n            hs.insert('b');\n\n            hs\n        };\n\n        let v = hs.into_iter().collect::<Vec<char>>();\n        assert!("
- "v == ['a', 'b'] || v == ['b', 'a']);\n    }\n\n    #[test]\n    fn test_eq() {\n        // These constants once happened to expose a bug in insert().\n        // I'm keeping them around to prevent a regression.\n        let mut s1 = HashSet::new();\n\n        s1.insert(1);\n        s1.insert(2);\n        s1.insert(3);\n\n        let mut s2 = HashSet::new();\n\n        s2.insert(1);\n        s2.insert(2);\n\n        assert!(s1 != s2);\n\n        s2.insert(3);\n\n        assert_eq!(s1, s2);\n    }\n\n    #[test]\n    fn test_show() {\n"
- "        let mut set = HashSet::new();\n        let empty = HashSet::<i32>::new();\n\n        set.insert(1);\n        set.insert(2);\n\n        let set_str = format!(\"{set:?}\");\n\n        assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n        assert_eq!(format!(\"{empty:?}\"), \"{}\");\n    }\n\n    #[test]\n    fn test_trivial_drain() {\n        let mut s = HashSet::<i32>::new();\n        for _ in s.drain() {}\n        assert!(s.is_empty());\n        drop(s);\n\n        let mut s = HashSet::<i32>::new();\n"
- "        drop(s.drain());\n        assert!(s.is_empty());\n    }\n\n    #[test]\n    fn test_drain() {\n        let mut s: HashSet<_> = (1..100).collect();\n\n        // try this a bunch of times to make sure we don't screw up internal state.\n        for _ in 0..20 {\n            assert_eq!(s.len(), 99);\n\n            {\n                let mut last_i = 0;\n                let mut d = s.drain();\n                for (i, x) in d.by_ref().take(50).enumerate() {\n                    last_i = i;\n                    assert!("
- "x != 0);\n                }\n                assert_eq!(last_i, 49);\n            }\n\n            if !s.is_empty() {\n                panic!(\"s should be empty!\");\n            }\n\n            // reset to try again.\n            s.extend(1..100);\n        }\n    }\n\n    #[test]\n    fn test_replace() {\n        use core::hash;\n\n        #[derive(Debug)]\n        #[allow(dead_code)]\n        struct Foo(&'static str, i32);\n\n        impl PartialEq for Foo {\n            fn eq(&self, other: &Self) -> bool {\n"
- "                self.0 == other.0\n            }\n        }\n\n        impl Eq for Foo {}\n\n        impl hash::Hash for Foo {\n            fn hash<H: hash::Hasher>(&self, h: &mut H) {\n                self.0.hash(h);\n            }\n        }\n\n        let mut s = HashSet::new();\n        assert_eq!(s.replace(Foo(\"a\", 1)), None);\n        assert_eq!(s.len(), 1);\n        assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n        assert_eq!(s.len(), 1);\n\n        let mut it = s.iter();\n        assert_eq!("
- "it.next(), Some(&Foo(\"a\", 2)));\n        assert_eq!(it.next(), None);\n    }\n\n    #[test]\n    #[allow(clippy::needless_borrow)]\n    fn test_extend_ref() {\n        let mut a = HashSet::new();\n        a.insert(1);\n\n        a.extend([2, 3, 4]);\n\n        assert_eq!(a.len(), 4);\n        assert!(a.contains(&1));\n        assert!(a.contains(&2));\n        assert!(a.contains(&3));\n        assert!(a.contains(&4));\n\n        let mut b = HashSet::new();\n        b.insert(5);\n        b.insert(6);\n\n        a.extend(&b);\n\n"
- "        assert_eq!(a.len(), 6);\n        assert!(a.contains(&1));\n        assert!(a.contains(&2));\n        assert!(a.contains(&3));\n        assert!(a.contains(&4));\n        assert!(a.contains(&5));\n        assert!(a.contains(&6));\n    }\n\n    #[test]\n    fn test_retain() {\n        let xs = [1, 2, 3, 4, 5, 6];\n        let mut set: HashSet<i32> = xs.iter().copied().collect();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&2));\n        assert!("
- "set.contains(&4));\n        assert!(set.contains(&6));\n    }\n\n    #[test]\n    fn test_extract_if() {\n        {\n            let mut set: HashSet<i32> = (0..8).collect();\n            let drained = set.extract_if(|&k| k % 2 == 0);\n            let mut out = drained.collect::<Vec<_>>();\n            out.sort_unstable();\n            assert_eq!(vec![0, 2, 4, 6], out);\n            assert_eq!(set.len(), 4);\n        }\n        {\n            let mut set: HashSet<i32> = (0..8).collect();\n"
- "            set.extract_if(|&k| k % 2 == 0).for_each(drop);\n            assert_eq!(set.len(), 4, \"Removes non-matching items on drop\");\n        }\n    }\n\n    #[test]\n    fn test_const_with_hasher() {\n        use core::hash::BuildHasher;\n        use std::collections::hash_map::DefaultHasher;\n\n        #[derive(Clone)]\n        struct MyHasher;\n        impl BuildHasher for MyHasher {\n            type Hasher = DefaultHasher;\n\n            fn build_hasher(&self) -> DefaultHasher {\n"
- "                DefaultHasher::new()\n            }\n        }\n\n        const EMPTY_SET: HashSet<u32, MyHasher> = HashSet::with_hasher(MyHasher);\n\n        let mut set = EMPTY_SET;\n        set.insert(19);\n        assert!(set.contains(&19));\n    }\n\n    #[test]\n    fn rehash_in_place() {\n        let mut set = HashSet::new();\n\n        for i in 0..224 {\n            set.insert(i);\n        }\n\n        assert_eq!(\n            set.capacity(),\n            224,\n"
- "            \"The set must be at or close to capacity to trigger a re hashing\"\n        );\n\n        for i in 100..1400 {\n            set.remove(&(i - 100));\n            set.insert(i);\n        }\n    }\n\n    #[test]\n    fn collect() {\n        // At the time of writing, this hits the ZST case in from_base_index\n        // (and without the `map`, it does not).\n        let mut _set: HashSet<_> = (0..3).map(|_| ()).collect();\n    }\n}\n"
