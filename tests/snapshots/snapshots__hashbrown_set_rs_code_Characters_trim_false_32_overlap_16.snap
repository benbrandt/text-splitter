---
source: tests/snapshots.rs
expression: chunks
---
- //
- " https://github.com/rust-lang/"
- /rust-lang/hashbrown/blob/
- 1167d19935f79320d666bf8549f05322
- d666bf8549f053229567d778/src/
- "/src/rustc_entry.rs\n"
- "#[cfg(feature = \"raw\")]\n"
- "\nuse crate::raw::RawTable;\n"
- "use "
- "crate::"
- "::{Equivalent, TryReserveError};"
- ";\nuse alloc::borrow::ToOwned;\n"
- "\nuse core::fmt;\n"
- "use "
- " core::hash::{BuildHasher, Hash}"
- ";\n"
- "use "
- "core::iter::"
- "::{Chain, FusedIterator};\n"
- "use "
- "core::ops::"
- "::{BitAnd, BitOr, BitXor, Sub};"
- ";\n\n"
- "use "
- "super::map::"
- "{self, DefaultHashBuilder, "
- ", HashMap, Keys};\n"
- "use "
- "crate::raw::"
- "{Allocator, Global, RawExtractIf"
- ", RawExtractIf};\n\n"
- "// Future Optimization (FIXME!)\n"
- // =============================
- "\n//\n"
- //
- " Iteration over zero sized "
- over zero sized values is a noop
- "values is a noop. "
- "There is no need\n"
- //
- " for `bucket.val` in the case of"
- "` in the case of HashSet. "
- "I suppose we would need HKT\n"
- "// to get rid of it properly.\n\n"
- ///
- " A hash set implemented as a `"
- " as a `HashMap` where the value "
- "where the value is `()`.\n///\n"
- ///
- " As with the [`HashMap`] type, a"
- "`] type, a `HashSet` requires "
- "` requires that the elements\n"
- ///
- " implement the [`Eq`] and [`Hash"
- "`Eq`] and [`Hash`] traits. "
- "This can frequently be achieved "
- " be achieved by\n"
- ///
- " using `#[derive(PartialEq, Eq, "
- "(PartialEq, Eq, Hash)]`. "
- "If you implement these yourself,"
- " these yourself,\n"
- ///
- " it is important that the "
- " that the following property "
- " property holds:\n///\n"
- "///\n/// ```text\n"
- ///
- " k1 == k2 -> hash(k1) == hash(k2"
- "(k1) == hash(k2)\n/// ```\n///\n"
- ///
- " In other words, if two keys are"
- " if two keys are equal, their "
- " equal, their hashes must be "
- " hashes must be equal.\n///\n///\n"
- ///
- " It is a logic error for an item"
- " for an item to be modified in "
- " be modified in such a way that "
- "such a way that the\n"
- ///
- " item's hash, as determined by "
- " determined by the [`Hash`] "
- "by the [`Hash`] trait, or its "
- "] trait, or its equality, as\n"
- ///
- " determined by the [`Eq`] trait,"
- " [`Eq`] trait, changes while it "
- " while it is in the set. "
- "This is\n"
- ///
- " normally only possible through "
- " through [`Cell`], [`RefCell`], "
- "], [`RefCell`], global state, I/"
- "global state, I/O, or\n"
- "/// unsafe code.\n///\n"
- ///
- " It is also a logic error for "
- "logic error for the [`Hash`] "
- " the [`Hash`] implementation of "
- " of a key to panic.\n"
- ///
- " This is generally only possible"
- " only possible if the trait is "
- "if the trait is implemented "
- " is implemented manually. If a\n"
- ///
- " panic does occur then the "
- " occur then the contents of the "
- "contents of the `HashSet` may "
- " `HashSet` may become corrupted "
- " corrupted and\n"
- ///
- " some items may be dropped from "
- "be dropped from the table.\n///\n"
- "///\n/// # Examples\n///\n/// ```\n"
- "/// use hashbrown::HashSet;\n"
- ///
- " // Type inference lets us omit "
- " lets us omit an explicit type "
- " explicit type signature (which\n"
- ///
- " // would be `HashSet<String>` "
- "<String>` in this example).\n"
- ///
- " let mut books = HashSet::new();"
- " HashSet::new();\n///\n"
- "///\n/// // Add some books.\n"
- ///
- " books.insert(\"A Dance With "
- "(\"A Dance With Dragons\"."
- " With Dragons\".to_string());\n"
- ///
- " books.insert(\"To Kill a "
- "(\"To Kill a Mockingbird\"."
- " a Mockingbird\".to_string());\n"
- ///
- " books.insert(\"The Odyssey\"."
- "(\"The Odyssey\".to_string());\n"
- ///
- " books.insert(\"The Great Gatsby\""
- " Great Gatsby\".to_string());\n"
- "///\n"
- ///
- "/ // Check for a specific one.\n"
- ///
- " if !"
- "books.contains(\"The Winds of "
- "(\"The Winds of Winter\") {\n"
- ///
- "     println!(\""
- "We have {} books, but The Winds "
- ", but The Winds of Winter ain't "
- "of Winter ain't one.\",\n"
- "///              books.len());\n"
- "/// }\n///\n/// // Remove a book.\n"
- ///
- "/ books.remove(\"The Odyssey\");\n"
- "///\n"
- "/// // Iterate over everything.\n"
- "/// for book in &books {\n"
- "///     println!(\"{}\", book);\n"
- "/// }\n/// ```\n///\n"
- ///
- " The easiest way to use `HashSet"
- " to use `HashSet` with a custom "
- "` with a custom type is to "
- " type is to derive\n"
- ///
- " [`Eq`] and [`Hash`]. "
- "We must also derive [`PartialEq`"
- " [`PartialEq`]. "
- "This will in the\n"
- ///
- "/ future be implied by [`Eq`].\n"
- "///\n/// ```\n"
- "/// use hashbrown::HashSet;\n"
- ///
- " #[derive(Hash, Eq, PartialEq, "
- " Eq, PartialEq, Debug)]\n"
- "/// struct Viking {\n"
- "///     name: String,\n"
- "///     power: usize,\n/// }\n///\n"
- ///
- " let mut vikings = HashSet::new("
- " = HashSet::new();\n///\n"
- ///
- " vikings.insert(Viking { name: \""
- "Viking { name: \"Einar\".to_string"
- "Einar\".to_string(), power: 9 });"
- "(), power: 9 });\n"
- ///
- " vikings.insert(Viking { name: \""
- "Viking { name: \"Einar\".to_string"
- "Einar\".to_string(), power: 9 });"
- "(), power: 9 });\n"
- ///
- " vikings.insert(Viking { name: \""
- "Viking { name: \"Olaf\".to_string("
- "Olaf\".to_string(), power: 4 });\n"
- ///
- " vikings.insert(Viking { name: \""
- "Viking { name: \"Harald\"."
- " name: \"Harald\".to_string(), "
- "\".to_string(), power: 8 });\n///\n"
- ///
- " // Use derived implementation "
- " implementation to print the "
- " to print the vikings.\n"
- "/// for x in &vikings {\n"
- "///     println!(\"{:?}\", x);\n"
- "/// }\n/// ```\n///\n"
- ///
- " A `HashSet` with fixed list of "
- " fixed list of elements can be "
- elements can be initialized from
- "initialized from an array:\n///\n"
- "///\n/// ```\n"
- "/// use hashbrown::HashSet;\n///\n"
- ///
- " let viking_names: HashSet<&'"
- ": HashSet<&'static str> =\n"
- ///
- "     [ \"Einar\", \"Olaf\", \"Harald\""
- "\"Olaf\", \"Harald\" ].into_iter()."
- "\" ].into_iter().collect();\n"
- ///
- " // use the values stored in the"
- " stored in the set\n/// ```\n///\n"
- ///
- " [`Cell`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cell/"
- "/std/cell/struct.Cell.html\n"
- ///
- " [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- "/std/cmp/trait.Eq.html\n"
- ///
- " [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n"
- ///
- " [`HashMap`]: "
- "[`HashMap`]: struct.HashMap.html"
- "\n"
- ///
- " [`PartialEq`]: https://doc.rust"
- "https://doc.rust-lang.org/std/"
- "-lang.org/std/cmp/"
- "/std/cmp/trait.PartialEq.html\n"
- ///
- " [`RefCell`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cell/"
- "/std/cell/struct.RefCell.html\n"
- pub struct HashSet
- "<T, S = DefaultHashBuilder, "
- ", A: Allocator = Global> "
- "{\n    "
- "pub(crate) map: "
- " map: HashMap<T, (), S, A>,\n}\n\n"
- impl
- "<T: Clone, S: Clone, "
- ", S: Clone, A: Allocator + Clone"
- "> Clone for HashSet<T, S, A> "
- "{\n    "
- "fn clone(&self) -> Self "
- "{\n        "
- "HashSet "
- "{\n            "
- "map: self.map.clone(),\n        }"
- ",\n        }\n    }\n\n    "
- fn clone_from
- "(&mut self, source: &Self) "
- "{\n        "
- self.map.clone_from(&source.map)
- ";\n    }\n}\n\n"
- "#[cfg(feature = \"ahash\")]\n"
- "impl<T> "
- " HashSet<T, DefaultHashBuilder> "
- "{\n    "
- "/// Creates an empty `HashSet`.\n"
- "    ///\n    "
- ///
- " The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not "
- " so it will not allocate until "
- " allocate until it\n    "
- "/// is first inserted into.\n    "
- "    ///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    "
- ///
- " [`with_hasher`](HashSet::"
- "`](HashSet::with_hasher) method."
- ") method.\n    ///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let set: HashSet<i32> = HashSet"
- "<i32> = HashSet::new();\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn new() -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "\n            map: HashMap::new()"
- ",\n        }\n    }\n\n    "
- ///
- " Creates an empty `HashSet` with"
- " `HashSet` with the specified "
- " the specified capacity.\n    "
- "///\n    "
- ///
- " The hash set will be able to "
- "will be able to hold at least `"
- " hold at least `capacity` "
- " `capacity` elements without\n"
- "    "
- ///
- " reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    "
- ///
- " [`with_capacity_and_hasher`]("
- "`](HashSet::"
- "::with_capacity_and_hasher) "
- ") method.\n    ///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let set: HashSet<i32> = HashSet"
- "<i32> = HashSet::with_capacity("
- "::with_capacity(10);\n    "
- ///
- " assert!(set.capacity() >= 10);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn with_capacity
- " with_capacity(capacity: usize) "
- " -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: "
- "HashMap::with_capacity(capacity)"
- ",\n        }\n    }\n}\n\n"
- "#[cfg(feature = \"ahash\")]\n"
- "impl<T: Hash + Eq, A: Allocator>"
- " "
- HashSet
- "<T, DefaultHashBuilder, A> "
- "{\n    "
- "/// Creates an empty `HashSet`.\n"
- "    ///\n    "
- ///
- " The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not "
- " so it will not allocate until "
- " allocate until it\n    "
- "/// is first inserted into.\n    "
- "    ///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    "
- ///
- " [`with_hasher_in`](HashSet::"
- "`](HashSet::with_hasher_in) "
- "with_hasher_in) method.\n    ///\n"
- "///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let set: HashSet<i32> = HashSet"
- "<i32> = HashSet::new();\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn new_in(alloc: A) -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: HashMap::new_in(alloc),"
- ",\n        }\n    }\n\n    "
- ///
- " Creates an empty `HashSet` with"
- " `HashSet` with the specified "
- " the specified capacity.\n    "
- "///\n    "
- ///
- " The hash set will be able to "
- "will be able to hold at least `"
- " hold at least `capacity` "
- " `capacity` elements without\n"
- "    "
- ///
- " reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    "
- ///
- " [`with_capacity_and_hasher_in`]"
- "`](HashSet::"
- "::with_capacity_and_hasher_in) "
- ") method.\n    ///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let set: HashSet<i32> = HashSet"
- "<i32> = HashSet::with_capacity("
- "::with_capacity(10);\n    "
- ///
- " assert!(set.capacity() >= 10);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn with_capacity_in
- "(capacity: usize, alloc: A) -> "
- " -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: "
- "HashMap::with_capacity_in"
- "(capacity, alloc),\n        }"
- ",\n        }\n    }\n}\n\n"
- "impl<T, S, A: Allocator> "
- " HashSet<T, S, A> "
- "{\n    "
- ///
- " Returns the number of elements "
- " of elements the set can hold "
- " set can hold without "
- " hold without reallocating.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let set: HashSet<i32> = HashSet"
- "<i32> = HashSet::with_capacity("
- "::with_capacity(100);\n    "
- ///
- " assert!("
- "set.capacity() >= 100);\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn capacity(&self) -> usize "
- "{\n        self.map.capacity()"
- "\n    }\n\n    "
- ///
- " An iterator visiting all "
- " visiting all elements in "
- all elements in arbitrary order.
- "arbitrary order.\n    "
- ///
- " The iterator element type is `&"
- " type is `&'a T`.\n    ///\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    /// set.insert(\"a\");\n    "
- "    /// set.insert(\"b\");\n    "
- "    ///\n    "
- ///
- " // Will print in an arbitrary "
- "in an arbitrary order.\n    "
- "/// for x in set.iter() {\n    "
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn iter(&self) -> "
- " iter(&self) -> Iter<'_, T> "
- "{\n        "
- "Iter "
- "{\n            "
- "iter: self.map.keys(),\n        }"
- ",\n        }\n    }\n\n    "
- ///
- " Returns the number of elements "
- " of elements in the set.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- "/// let mut v = HashSet::new();\n"
- "    /// assert_eq!(v.len(), 0);\n"
- "    /// v.insert(1);\n    "
- "    /// assert_eq!(v.len(), 1);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn len(&self) -> usize "
- " {\n        self.map.len()\n    }"
- "\n\n    "
- ///
- " Returns `true` if the set "
- "` if the set contains no "
- "set contains no elements.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- "/// let mut v = HashSet::new();\n"
- "    /// assert!(v.is_empty());\n"
- "    /// v.insert(1);\n    "
- "    /// assert!(!v.is_empty());\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn is_empty(&self) -> bool "
- "{\n        self.map.is_empty()"
- "\n    }\n\n    "
- ///
- " Clears the set, returning all "
- ", returning all elements in an "
- " elements in an iterator.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<_> = [1, 2"
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- "/// assert!(!set.is_empty());\n"
- "    ///\n    "
- ///
- " // print 1, 2, 3 in an "
- " 1, 2, 3 in an arbitrary order\n"
- "    /// for i in set.drain() {\n"
- "    ///     println!(\"{}\", i);\n"
- "    /// }\n    ///\n    "
- "/// assert!(set.is_empty());\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn drain(&mut self) -> "
- "(&mut self) -> Drain<'_, T, A> "
- "{\n        "
- "Drain "
- "{\n            "
- "iter: self.map.drain(),\n        "
- ",\n        }\n    }\n\n    "
- ///
- " Retains only the elements "
- " the elements specified by the "
- " by the predicate.\n    ///\n    "
- ///
- " In other words, remove all "
- ", remove all elements `e` such "
- " `e` such that `f(&e)` returns `"
- "f(&e)` returns `false`.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- "    /// let xs = [1,2,3,4,5,6];\n"
- "    "
- ///
- " let mut set: HashSet<i32> = "
- " HashSet<i32> = xs.into_iter()."
- " xs.into_iter().collect();\n    "
- ///
- "/ set.retain(|&k| k % 2 == 0);\n"
- "    "
- "/// assert_eq!(set.len(), 3);\n"
- "    /// ```\n    "
- pub fn retain<F>
- " retain<F>(&mut self, mut f: F)"
- "\n    "
- "where\n        "
- "\n        F: FnMut(&T) -> bool,"
- ",\n    "
- "{\n        "
- "self.map.retain(|k, _| f(k));"
- "\n    }\n\n    "
- ///
- " Drains elements which are true "
- " which are true under the given "
- "under the given predicate,\n    "
- ///
- " and returns an iterator over "
- " iterator over the removed items"
- " removed items.\n    ///\n    "
- ///
- " In other words, move all "
- "words, move all elements `e` "
- " elements `e` such that `f(&e)` "
- " that `f(&e)` returns `true` out"
- " `true` out\n    "
- "/// into another iterator.\n    "
- "    ///\n    "
- ///
- " If the returned `ExtractIf` is "
- " `ExtractIf` is not exhausted, "
- " not exhausted, e.g. because it "
- "e.g. because it is dropped "
- " it is dropped without iterating"
- " iterating\n    "
- ///
- " or the iteration short-circuits"
- " short-circuits, then the "
- ", then the remaining elements "
- " elements will be retained.\n    "
- ///
- " Use [`retain()`] with a negated"
- "] with a negated predicate if "
- " predicate if you do not need "
- "you do not need the returned "
- " the returned iterator.\n    ///\n"
- "///\n    "
- ///
- "/ [`retain()`]: HashSet::retain\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<i32> = (0."
- "<i32> = (0..8).collect();\n    "
- ///
- " let drained: HashSet<i32> = "
- " HashSet<i32> = set.extract_if(|"
- set.extract_if(|v| v % 2 == 0).
- "|v| v % 2 == 0).collect();\n    "
- "///\n    "
- ///
- " let mut evens = "
- " mut evens = drained.into_iter()"
- "().collect::<Vec<_>>();\n    "
- ///
- " let mut odds = set.into_iter()."
- "set.into_iter().collect::<Vec<_>"
- "collect::<Vec<_>>();\n    "
- "/// evens.sort();\n    "
- "    /// odds.sort();\n    ///\n"
- "    ///\n    "
- ///
- " assert_eq!(evens, vec!["
- "evens, vec![0, 2, 4, 6]);\n    "
- ///
- " assert_eq!(odds, vec!["
- "odds, vec![1, 3, 5, 7]);\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn extract_if<F>
- " extract_if<F>(&mut self, f: F) "
- " -> ExtractIf<'_, T, F, A>\n    "
- "where\n        "
- "\n        F: FnMut(&T) -> bool,"
- ",\n    "
- "{\n        "
- "ExtractIf "
- "{\n            f,\n            "
- "inner: "
- "RawExtractIf "
- "{\n                "
- "iter: "
- "unsafe { self.map.table.iter() }"
- ",\n                "
- "table: &mut self.map.table,"
- ",\n            },\n        }\n    }"
- "}\n\n    "
- ///
- " Clears the set, removing all "
- ", removing all values.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- "/// let mut v = HashSet::new();\n"
- "    /// v.insert(1);\n    "
- "    /// v.clear();\n    "
- "    /// assert!(v.is_empty());\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn clear(&mut self) "
- "{\n        self.map.clear();\n    "
- "\n    }\n}\n\n"
- "impl<T, S> HashSet<T, S, Global>"
- " "
- "{\n    "
- ///
- " Creates a new empty hash set "
- " empty hash set which will use "
- " which will use the given hasher"
- "the given hasher to hash\n    "
- "/// keys.\n    ///\n    "
- ///
- " The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not\n"
- "    "
- ///
- " allocate until it is first "
- " it is first inserted into.\n    "
- "///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`].\n    "
- "///\n    "
- ///
- " The `hash_builder` passed "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n    "
- ///
- " the HashSet to be useful, see "
- " be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n    "
- "///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    "
- ///
- " [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n    "
- ///
- " let s = DefaultHashBuilder::"
- "::default();\n    "
- ///
- " let mut set = HashSet::"
- " set = HashSet::with_hasher(s);\n"
- "    /// set.insert(2);\n    "
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub const fn with_hasher
- " fn with_hasher(hasher: S) -> "
- "(hasher: S) -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: "
- ": HashMap::with_hasher(hasher),"
- ",\n        }\n    }\n\n    "
- ///
- " Creates an empty `HashSet` with"
- " `HashSet` with the specified "
- " the specified capacity, using\n"
- "    "
- "/// `hasher` to hash the keys.\n"
- "    ///\n    "
- ///
- " The hash set will be able to "
- "will be able to hold at least `"
- " hold at least `capacity` "
- " `capacity` elements without\n"
- "    "
- ///
- " reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`].\n    "
- "///\n    "
- ///
- " The `hash_builder` passed "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n    "
- ///
- " the HashSet to be useful, see "
- " be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n    "
- "///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    "
- ///
- " [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n    "
- ///
- " let s = DefaultHashBuilder::"
- "::default();\n    "
- ///
- " let mut set = HashSet::"
- "::with_capacity_and_hasher(10, s"
- "(10, s);\n    /// set.insert(1);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn with_capacity_and_hasher
- "(capacity: usize, hasher: S) -> "
- " -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: "
- "HashMap::"
- "::with_capacity_and_hasher"
- "(capacity, hasher),\n        }"
- ",\n        }\n    }\n}\n\n"
- "impl<T, S, A> HashSet<T, S, A>\n"
- "\nwhere\n    A: Allocator,\n"
- "{\n    "
- ///
- " Returns a reference to the "
- " to the underlying allocator.\n"
- "    #[inline]\n    "
- "pub fn allocator(&self) -> &A "
- "{\n        self.map.allocator()"
- "\n    }\n\n    "
- ///
- " Creates a new empty hash set "
- " empty hash set which will use "
- " which will use the given hasher"
- "the given hasher to hash\n    "
- "/// keys.\n    ///\n    "
- ///
- " The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not\n"
- "    "
- ///
- " allocate until it is first "
- " it is first inserted into.\n    "
- "///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`].\n    "
- "///\n    "
- ///
- " The `hash_builder` passed "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n    "
- ///
- " the HashSet to be useful, see "
- " be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n    "
- "///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    "
- ///
- " [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n    "
- ///
- " let s = DefaultHashBuilder::"
- "::default();\n    "
- ///
- " let mut set = HashSet::"
- " set = HashSet::with_hasher(s);\n"
- "    /// set.insert(2);\n    "
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub const fn with_hasher_in
- "(hasher: S, alloc: A) -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: "
- "HashMap::with_hasher_in"
- "(hasher, alloc),\n        }\n    }"
- "}\n\n    "
- ///
- " Creates an empty `HashSet` with"
- " `HashSet` with the specified "
- " the specified capacity, using\n"
- "    "
- "/// `hasher` to hash the keys.\n"
- "    ///\n    "
- ///
- " The hash set will be able to "
- "will be able to hold at least `"
- " hold at least `capacity` "
- " `capacity` elements without\n"
- "    "
- ///
- " reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "///\n    "
- "    /// # HashDoS resistance\n"
- "    ///\n    "
- ///
- " The `hash_builder` normally use"
- "` normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n    "
- ///
- " not allow the `HashSet` to be "
- "`HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n    "
- ///
- " Users who require HashDoS "
- "require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n    "
- ///
- " [`ahash::RandomState`] or [`std"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n    "
- ///
- " as the hasher when creating a ["
- " creating a [`HashSet`].\n    "
- "///\n    "
- ///
- " The `hash_builder` passed "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n    "
- ///
- " the HashSet to be useful, see "
- " be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n    "
- "///\n    "
- ///
- " [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n    "
- ///
- " [`std::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    "
- ///
- " [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n    "
- ///
- " let s = DefaultHashBuilder::"
- "::default();\n    "
- ///
- " let mut set = HashSet::"
- "::with_capacity_and_hasher(10, s"
- "(10, s);\n    /// set.insert(1);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn "
- " fn with_capacity_and_hasher_in"
- "(capacity: usize, hasher: S, "
- ", hasher: S, alloc: A) -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: "
- "HashMap::"
- "::with_capacity_and_hasher_in"
- "(capacity, hasher, alloc),"
- ",\n        }\n    }\n\n    "
- ///
- " Returns a reference to the "
- " to the set's [`BuildHasher`].\n"
- "    ///\n    "
- ///
- " [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n    "
- ///
- " let hasher = DefaultHashBuilder"
- "::default();\n    "
- ///
- " let set: HashSet<i32> = HashSet"
- "<i32> = HashSet::with_hasher("
- "::with_hasher(hasher);\n    "
- ///
- " let hasher: &DefaultHashBuilder"
- " = set.hasher();\n    /// ```\n"
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn hasher(&self) -> &S "
- "{\n        self.map.hasher()\n    "
- "\n    }\n}\n\n"
- "impl<T, S, A> HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- ///
- " Reserves capacity for at least "
- " for at least `additional` more "
- "` more elements to be inserted\n"
- "    "
- ///
- " in the `HashSet`. "
- "The collection may reserve more "
- " reserve more space to avoid\n"
- "    /// frequent reallocations.\n"
- "    ///\n    /// # Panics\n    "
- "    ///\n    "
- ///
- " Panics if the new capacity "
- " new capacity exceeds [`isize::"
- " [`isize::MAX`] bytes and [`"
- "`] bytes and [`abort`] the "
- " [`abort`] the program\n    "
- ///
- " in case of allocation error. "
- "Use [`try_reserve`](HashSet::"
- "`](HashSet::try_reserve) instead"
- ") instead\n    "
- ///
- " if you want to handle memory "
- " handle memory allocation "
- " allocation failure.\n    ///\n"
- "///\n    "
- ///
- " [`isize::MAX`]: https://"
- ":MAX`]: https://doc.rust-"
- "://doc.rust-lang.org/std/"
- "/std/primitive.isize.html\n    "
- ///
- " [`abort`]: https://doc.rust-"
- "://doc.rust-lang.org/alloc/alloc"
- /alloc/alloc/
- alloc/fn.handle_alloc_error.html
- "\n    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let mut set: HashSet<i32> = "
- " HashSet<i32> = HashSet::new();\n"
- "    /// set.reserve(10);\n    "
- ///
- " assert!(set.capacity() >= 10);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn reserve
- "(&mut self, additional: usize) "
- "{\n        "
- self.map.reserve(additional);
- "\n    }\n\n    "
- ///
- " Tries to reserve capacity for "
- " capacity for at least `"
- " for at least `additional` more "
- "` more elements to be inserted\n"
- "    "
- ///
- " in the given `HashSet<K,V>`. "
- "The collection may reserve more "
- " reserve more space to avoid\n"
- "    /// frequent reallocations.\n"
- "    ///\n    /// # Errors\n    "
- "    ///\n    "
- ///
- " If the capacity overflows, or "
- " overflows, or the allocator "
- " the allocator reports a failure"
- " a failure, then an error\n    "
- "/// is returned.\n    ///\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let mut set: HashSet<i32> = "
- " HashSet<i32> = HashSet::new();\n"
- "    "
- ///
- " set.try_reserve(10).expect(\"why"
- "(10).expect(\"why is the test "
- "why is the test harness OOMing "
- " harness OOMing on 10 bytes?\");\n"
- ";\n    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn try_reserve
- "(&mut self, additional: usize) "
- " -> Result<(), TryReserveError> "
- "{\n        "
- self.map.try_reserve(additional)
- "\n    }\n\n    "
- ///
- " Shrinks the capacity of the set"
- " of the set as much as possible."
- " as possible. It will drop\n    "
- ///
- " down as much as possible while "
- " possible while maintaining the "
- "maintaining the internal rules\n"
- "    "
- ///
- " and possibly leaving some space"
- " some space in accordance with "
- "accordance with the resize "
- "with the resize policy.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set = HashSet::"
- " set = HashSet::with_capacity("
- "::with_capacity(100);\n    "
- "/// set.insert(1);\n    "
- "    /// set.insert(2);\n    "
- ///
- " assert!("
- "set.capacity() >= 100);\n    "
- "/// set.shrink_to_fit();\n    "
- ///
- "/ assert!(set.capacity() >= 2);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn shrink_to_fit(&mut self) "
- "{\n        "
- "self.map.shrink_to_fit();\n    }"
- "\n    }\n\n    "
- ///
- " Shrinks the capacity of the set"
- " of the set with a lower limit. "
- "It will drop\n    "
- ///
- " down no lower than the supplied"
- " the supplied limit while "
- " limit while maintaining the "
- "maintaining the internal rules\n"
- "    "
- ///
- " and possibly leaving some space"
- " some space in accordance with "
- "accordance with the resize "
- "with the resize policy.\n    ///\n"
- "///\n    "
- ///
- " Panics if the current capacity "
- " capacity is smaller than the "
- " than the supplied\n    "
- "/// minimum capacity.\n    ///\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set = HashSet::"
- " set = HashSet::with_capacity("
- "::with_capacity(100);\n    "
- "/// set.insert(1);\n    "
- "    /// set.insert(2);\n    "
- ///
- " assert!("
- "set.capacity() >= 100);\n    "
- "/// set.shrink_to(10);\n    "
- ///
- " assert!(set.capacity() >= 10);\n"
- "    /// set.shrink_to(0);\n    "
- ///
- "/ assert!(set.capacity() >= 2);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn shrink_to
- "(&mut self, min_capacity: usize)"
- " "
- "{\n        "
- self.map.shrink_to(min_capacity)
- ";\n    }\n\n    "
- ///
- " Visits the values representing "
- " representing the difference,\n"
- "    "
- ///
- " i.e., the values that are in `"
- " that are in `self` but not in `"
- "` but not in `other`.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let a: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " let b: HashSet<_> = [4, 2, 3, 4"
- "_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n    "
- "///\n    "
- "/// // Can be seen as `a - b`.\n"
- "    "
- "/// for x in a.difference(&b) {\n"
- "    "
- ///
- "     println!(\"{}\", x); // Print"
- "}\", x); // Print 1\n    /// }\n"
- "/// }\n    ///\n    "
- ///
- " let diff: HashSet<_> = "
- ": HashSet<_> = a.difference(&b)."
- "(&b).collect();\n    "
- ///
- " assert_eq!("
- "diff, [1].iter().collect());\n"
- "    ///\n    "
- ///
- " // Note that difference is not "
- " is not symmetric,\n    "
- ///
- " // and `b - a` means something "
- "means something else:\n    "
- ///
- " let diff: HashSet<_> = "
- ": HashSet<_> = b.difference(&a)."
- "(&a).collect();\n    "
- ///
- " assert_eq!("
- "diff, [4].iter().collect());\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn difference<'a>"
- "<'a>(&'a self, other: &'a Self) "
- " -> Difference<'a, T, S, A> "
- "{\n        "
- "Difference "
- "{\n            iter: self.iter(),"
- ",\n            other,\n        }"
- "other,\n        }\n    }\n\n    "
- ///
- " Visits the values representing "
- " representing the symmetric "
- " the symmetric difference,\n    "
- ///
- " i.e., the values that are in `"
- " that are in `self` or in `other"
- "` or in `other` but not in both."
- "but not in both.\n    ///\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let a: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " let b: HashSet<_> = [4, 2, 3, 4"
- "_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n    "
- "///\n    "
- ///
- " // Print 1, 4 in arbitrary "
- " 4 in arbitrary order.\n    "
- ///
- " for x in a.symmetric_difference"
- "(&b) {\n    "
- "///     println!(\"{}\", x);\n    "
- "    /// }\n    ///\n    "
- ///
- " let diff1: HashSet<_> = "
- "<_> = a.symmetric_difference(&b)"
- "(&b).collect();\n    "
- ///
- " let diff2: HashSet<_> = "
- "<_> = b.symmetric_difference(&a)"
- "(&a).collect();\n    ///\n    "
- "/// assert_eq!(diff1, diff2);\n"
- "    "
- ///
- " assert_eq!("
- "diff1, [1, 4].iter().collect());"
- "().collect());\n    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn symmetric_difference<'a>"
- "<'a>(&'a self, other: &'a Self) "
- " -> "
- "SymmetricDifference<'a, T, S, A>"
- " "
- "{\n        "
- "SymmetricDifference "
- "{\n            "
- "iter: "
- self.difference(other).chain
- "(other.difference(self)),"
- ",\n        }\n    }\n\n    "
- ///
- " Visits the values representing "
- " representing the intersection,\n"
- "    "
- ///
- " i.e., the values that are both "
- " that are both in `self` and `"
- " in `self` and `other`.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let a: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " let b: HashSet<_> = [4, 2, 3, 4"
- "_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n    "
- "///\n    "
- ///
- " // Print 2, 3 in arbitrary "
- " 3 in arbitrary order.\n    "
- ///
- "/ for x in a.intersection(&b) {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    ///\n    "
- ///
- " let intersection: HashSet<_> = "
- ": HashSet<_> = a.intersection(&b"
- "(&b).collect();\n    "
- ///
- " assert_eq!("
- "intersection, [2, 3].iter()."
- ", [2, 3].iter().collect());\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn intersection<'a>"
- "<'a>(&'a self, other: &'a Self) "
- " -> Intersection<'a, T, S, A> "
- "{\n        "
- "let (smaller, larger) = "
- "if self.len() <= other.len() "
- "{\n            (self, other)"
- "(self, other)\n        } "
- "else "
- "{\n            (other, self)"
- "(other, self)\n        };"
- ";\n        "
- "Intersection "
- "{\n            "
- "iter: smaller.iter(),"
- ",\n            other: larger,"
- "other: larger,\n        }\n    }"
- "}\n\n    "
- ///
- " Visits the values representing "
- " representing the union,\n    "
- ///
- " i.e., all the values in `self` "
- " in `self` or `other`, without "
- "other`, without duplicates.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " let a: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " let b: HashSet<_> = [4, 2, 3, 4"
- "_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n    "
- "///\n    "
- ///
- " // Print 1, 2, 3, 4 in "
- " 1, 2, 3, 4 in arbitrary order.\n"
- "    /// for x in a.union(&b) {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    ///\n    "
- ///
- " let union: HashSet<_> = a.union"
- "<_> = a.union(&b).collect();\n"
- "    "
- ///
- " assert_eq!("
- "union, [1, 2, 3, 4].iter()."
- "2, 3, 4].iter().collect());\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn union<'a>"
- "<'a>(&'a self, other: &'a Self) "
- " -> Union<'a, T, S, A> "
- "{\n        "
- //
- " We'll iterate one set in full, "
- " set in full, and only the "
- ", and only the remaining "
- " the remaining difference from "
- "difference from the other.\n"
- "        "
- //
- " Use the smaller set for the "
- " set for the difference in order"
- " in order to reduce hash lookups"
- " hash lookups.\n        "
- "let (smaller, larger) = "
- "if self.len() <= other.len() "
- "{\n            (self, other)"
- "(self, other)\n        } "
- "else "
- "{\n            (other, self)"
- "(other, self)\n        };"
- ";\n        "
- "Union "
- "{\n            "
- "iter: "
- larger.iter().chain
- "(smaller.difference(larger)),"
- ",\n        }\n    }\n\n    "
- ///
- " Returns `true` if the set "
- "` if the set contains a value.\n"
- "    ///\n    "
- ///
- " The value may be any borrowed "
- "be any borrowed form of the "
- " form of the set's value type, "
- " value type, but\n    "
- ///
- " [`Hash`] and [`Eq`] on the "
- " [`Eq`] on the borrowed form *"
- " borrowed form *must* match "
- " *must* match those for\n    "
- "/// the value type.\n    ///\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let set: HashSet<_> = [1, 2, 3]"
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " assert_eq!("
- "set.contains(&1), true);\n    "
- ///
- " assert_eq!("
- "set.contains(&4), false);\n    "
- "/// ```\n    ///\n    "
- ///
- " [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- "/std/cmp/trait.Eq.html\n    "
- ///
- " [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn contains<Q: ?Sized>"
- "<Q: ?Sized>(&self, value: &Q) ->"
- " -> bool\n    "
- "where\n        "
- "\n        Q: Hash + Equivalent<T>"
- ",\n    "
- "{\n        "
- self.map.contains_key(value)
- "\n    }\n\n    "
- ///
- " Returns a reference to the "
- " to the value in the set, if any"
- " the set, if any, that is equal "
- ", that is equal to the given "
- " to the given value.\n    ///\n"
- "///\n    "
- ///
- " The value may be any borrowed "
- "be any borrowed form of the "
- " form of the set's value type, "
- " value type, but\n    "
- ///
- " [`Hash`] and [`Eq`] on the "
- " [`Eq`] on the borrowed form *"
- " borrowed form *must* match "
- " *must* match those for\n    "
- "/// the value type.\n    ///\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let set: HashSet<_> = [1, 2, 3]"
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " assert_eq!("
- "set.get(&2), Some(&2));\n    "
- ///
- " assert_eq!(set.get(&4), None);\n"
- "    /// ```\n    ///\n    "
- ///
- " [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- "/std/cmp/trait.Eq.html\n    "
- ///
- " [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn get<Q: ?Sized>"
- "get<Q: ?Sized>(&self, value: &Q)"
- " -> Option<&T>\n    "
- "where\n        "
- "\n        Q: Hash + Equivalent<T>"
- ",\n    "
- "{\n        "
- //
- " Avoid `Option::map` because it "
- "map` because it bloats LLVM IR.\n"
- "        "
- "match "
- " self.map.get_key_value(value) "
- "{\n            "
- "Some((k, _)) => Some(k),"
- "\n            None => None,"
- "None => None,\n        }\n    }"
- "}\n\n    "
- ///
- " Inserts the given `value` into "
- " `value` into the set if it is "
- " set if it is not present, then\n"
- "    "
- ///
- " returns a reference to the "
- " to the value in the set.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<_> = [1, 2"
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- "/// assert_eq!(set.len(), 3);\n"
- "    "
- ///
- " assert_eq!("
- "set.get_or_insert(2), &2);\n    "
- ///
- " assert_eq!("
- "set.get_or_insert(100), &100);\n"
- "    "
- ///
- " assert_eq!("
- "set.len(), 4); // 100 was "
- " 4); // 100 was inserted\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn get_or_insert
- "(&mut self, value: T) -> &T "
- "{\n        "
- //
- " Although the raw entry gives us"
- " entry gives us `&mut T`, we "
- "us `&mut T`, we only return `&T`"
- "only return `&T` to be "
- " `&T` to be consistent with\n"
- "        "
- //
- " `get`. "
- "Key mutation is \"raw\" because "
- " \"raw\" because you're not "
- " you're not supposed to affect `"
- " to affect `Eq` or `Hash`.\n"
- "        "
- "self.map\n            ."
- "\n            .raw_entry_mut()"
- "()\n            .from_key(&value)"
- "(&value)\n            .or_insert"
- "(value, ())\n            .0\n    }"
- "}\n\n    "
- ///
- " Inserts an owned copy of the "
- " copy of the given `value` into "
- " `value` into the set if it is "
- " set if it is not\n    "
- ///
- " present, then returns a "
- " then returns a reference to the"
- "reference to the value in the "
- " value in the set.\n    ///\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<String> = "
- "<String> = [\"cat\", \"dog\", \"horse"
- "\", \"dog\", \"horse\"]\n    "
- ///
- "     .iter().map(|&pet| "
- ().map(|&pet| pet.to_owned()).
- "pet.to_owned()).collect();\n    "
- "///\n    "
- "/// assert_eq!(set.len(), 3);\n"
- "    "
- ///
- " for &pet in &[\"cat\", \"dog\", \""
- "[\"cat\", \"dog\", \"fish\"] {\n    "
- ///
- "     let value = "
- " value = set.get_or_insert_owned"
- "(pet);\n    "
- "///     assert_eq!(value, pet);\n"
- "    /// }\n    "
- ///
- " assert_eq!("
- "set.len(), 4); // a new \"fish\" "
- "// a new \"fish\" was inserted\n"
- "    /// ```\n    #[inline]\n    "
- pub fn get_or_insert_owned
- "<Q: ?Sized>"
- "(&mut self, value: &Q) -> &T"
- " -> &T\n    "
- "where\n        "
- Q
- ": Hash + Equivalent<T> + "
- " + ToOwned<Owned = T>,\n    "
- "{\n        "
- //
- " Although the raw entry gives us"
- " entry gives us `&mut T`, we "
- "us `&mut T`, we only return `&T`"
- "only return `&T` to be "
- " `&T` to be consistent with\n"
- "        "
- //
- " `get`. "
- "Key mutation is \"raw\" because "
- " \"raw\" because you're not "
- " you're not supposed to affect `"
- " to affect `Eq` or `Hash`.\n"
- "        "
- "self.map\n            ."
- "\n            .raw_entry_mut()"
- "()\n            .from_key(value)"
- "(value)\n            ."
- ".or_insert_with"
- "(|| (value.to_owned(), ()))"
- "\n            .0\n    }\n\n    "
- ///
- " Inserts a value computed from `"
- " computed from `f` into the set "
- "f` into the set if the given `"
- " if the given `value` is\n    "
- ///
- " not present, then returns a "
- " then returns a reference to the"
- "reference to the value in the "
- " value in the set.\n    ///\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<String> = "
- "<String> = [\"cat\", \"dog\", \"horse"
- "\", \"dog\", \"horse\"]\n    "
- ///
- "     .iter().map(|&pet| "
- ().map(|&pet| pet.to_owned()).
- "pet.to_owned()).collect();\n    "
- "///\n    "
- "/// assert_eq!(set.len(), 3);\n"
- "    "
- ///
- " for &pet in &[\"cat\", \"dog\", \""
- "[\"cat\", \"dog\", \"fish\"] {\n    "
- ///
- "     let value = "
- " value = set.get_or_insert_with("
- "(pet, str::to_owned);\n    "
- "///     assert_eq!(value, pet);\n"
- "    /// }\n    "
- ///
- " assert_eq!("
- "set.len(), 4); // a new \"fish\" "
- "// a new \"fish\" was inserted\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn get_or_insert_with
- "<Q: ?Sized, F>"
- "(&mut self, value: &Q, f: F) -> "
- " -> &T\n    "
- "where\n        "
- "\n        Q: Hash + Equivalent<T>"
- ",\n        F: FnOnce(&Q) -> T,"
- ",\n    "
- "{\n        "
- //
- " Although the raw entry gives us"
- " entry gives us `&mut T`, we "
- "us `&mut T`, we only return `&T`"
- "only return `&T` to be "
- " `&T` to be consistent with\n"
- "        "
- //
- " `get`. "
- "Key mutation is \"raw\" because "
- " \"raw\" because you're not "
- " you're not supposed to affect `"
- " to affect `Eq` or `Hash`.\n"
- "        "
- "self.map\n            ."
- "\n            .raw_entry_mut()"
- "()\n            .from_key(value)"
- "(value)\n            ."
- ".or_insert_with"
- "(|| (f(value), ()))\n            "
- ".0\n    }\n\n    "
- ///
- " Gets the given value's "
- " given value's corresponding "
- " corresponding entry in the set "
- " in the set for in-place "
- " for in-place manipulation.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_set::Entry:"
- "hash_set::Entry::*;\n    ///\n    "
- ///
- " let mut singles = HashSet::new("
- " = HashSet::new();\n    "
- ///
- " let mut dupes = HashSet::new();"
- " HashSet::new();\n    ///\n    "
- ///
- " for ch in \"a short treatise on "
- " treatise on fungi\".chars() {\n"
- "    "
- ///
- "     if let Vacant(dupe_entry) ="
- "(dupe_entry) = dupes.entry(ch) {"
- "(ch) {\n    "
- ///
- "         // We haven't already "
- "haven't already seen a duplicate"
- "seen a duplicate, so\n    "
- ///
- "         // check if we've at "
- " if we've at least seen it once."
- " seen it once.\n    "
- ///
- "         match singles.entry(ch)"
- "(ch) {\n    "
- ///
- "             Vacant(single_entry"
- "(single_entry) => {\n    "
- ///
- "                 // We found a "
- "// We found a new character for "
- " character for the first time.\n"
- "    "
- ///
- "                 "
- "single_entry.insert();\n    "
- "///             }\n    "
- ///
- "             Occupied("
- "Occupied(single_entry) => {\n    "
- ///
- "                 // We've "
- "// We've already seen this once,"
- " seen this once, \"move\" it to "
- ", \"move\" it to dupes.\n    "
- ///
- "                 "
- "single_entry.remove();\n    "
- ///
- "                 "
- "dupe_entry.insert();\n    "
- "///             }\n    "
- "    ///         }\n    ///     }\n"
- "    ///     }\n    /// }\n    ///\n"
- "/// }\n    ///\n    "
- ///
- " assert!(!"
- "singles.contains(&'t') && "
- "(&'t') && dupes.contains(&'t'));"
- "(&'t'));\n    "
- ///
- " assert!("
- "singles.contains(&'u') && !"
- "dupes.contains(&'u'));\n    "
- ///
- " assert!(!"
- "singles.contains(&'v') && !"
- "dupes.contains(&'v'));\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn entry
- " fn entry(&mut self, value: T) "
- " -> Entry<'_, T, S, A> "
- "{\n        "
- "match self.map.entry(value) "
- "{\n            "
- "map::Entry::Occupied(entry) => "
- "Entry::Occupied"
- "(OccupiedEntry { inner: entry })"
- ",\n            "
- "map::Entry::Vacant(entry) => "
- "Entry::Vacant"
- "(VacantEntry { inner: entry }),"
- ",\n        }\n    }\n\n    "
- ///
- " Returns `true` if `self` has no"
- "if `self` has no elements in "
- " no elements in common with `"
- "in common with `other`.\n    "
- ///
- " This is equivalent to checking "
- " to checking for an empty "
- " for an empty intersection.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let a: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- "/// let mut b = HashSet::new();\n"
- "    ///\n    "
- ///
- " assert_eq!("
- "a.is_disjoint(&b), true);\n    "
- "/// b.insert(4);\n    "
- ///
- " assert_eq!("
- "a.is_disjoint(&b), true);\n    "
- "/// b.insert(1);\n    "
- ///
- " assert_eq!("
- "a.is_disjoint(&b), false);\n    "
- "/// ```\n    "
- pub fn is_disjoint
- "is_disjoint(&self, other: &Self)"
- " -> bool "
- "{\n        "
- self.iter().all
- "(|v| !other.contains(v))\n    }"
- "}\n\n    "
- ///
- " Returns `true` if the set is a "
- "if the set is a subset of "
- " is a subset of another,\n    "
- ///
- " i.e., `other` contains at least"
- " at least all the values in `"
- " the values in `self`.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let sup: HashSet<_> = [1, 2, 3]"
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    ///\n    "
- ///
- " assert_eq!("
- "set.is_subset(&sup), true);\n    "
- "/// set.insert(2);\n    "
- ///
- " assert_eq!("
- "set.is_subset(&sup), true);\n    "
- "/// set.insert(4);\n    "
- ///
- " assert_eq!("
- "set.is_subset(&sup), false);\n"
- "    /// ```\n    "
- pub fn is_subset
- " is_subset(&self, other: &Self) "
- " -> bool "
- "{\n        "
- "self.len() <= other.len() && "
- self.iter().all
- "(|v| other.contains(v))\n    }"
- "}\n\n    "
- ///
- " Returns `true` if the set is a "
- "if the set is a superset of "
- " a superset of another,\n    "
- ///
- " i.e., `self` contains at least "
- " at least all the values in `"
- " the values in `other`.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let sub: HashSet<_> = [1, 2]."
- "<_> = [1, 2].into_iter().collect"
- "().collect();\n    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    ///\n    "
- ///
- " assert_eq!("
- "set.is_superset(&sub), false);\n"
- "    ///\n    /// set.insert(0);\n"
- "    /// set.insert(1);\n    "
- ///
- " assert_eq!("
- "set.is_superset(&sub), false);\n"
- "    ///\n    /// set.insert(2);\n"
- "    "
- ///
- " assert_eq!("
- "set.is_superset(&sub), true);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn is_superset
- "is_superset(&self, other: &Self)"
- " -> bool "
- "{\n        other.is_subset(self)"
- "\n    }\n\n    "
- "/// Adds a value to the set.\n"
- "    ///\n    "
- ///
- " If the set did not have this "
- " not have this value present, `"
- "value present, `true` is "
- ", `true` is returned.\n    ///\n"
- "///\n    "
- ///
- " If the set did have this value "
- "have this value present, `false`"
- "present, `false` is returned.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    ///\n    "
- ///
- " assert_eq!("
- "set.insert(2), true);\n    "
- ///
- " assert_eq!("
- "set.insert(2), false);\n    "
- "/// assert_eq!(set.len(), 1);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn insert
- " fn insert(&mut self, value: T) "
- " -> bool "
- "{\n        "
- "self.map.insert(value, ())."
- ".is_none()\n    }\n\n    "
- ///
- " Insert a value the set without "
- "the set without checking if the "
- "checking if the value already "
- " value already exists in the set"
- " in the set.\n    ///\n    "
- ///
- " Returns a reference to the "
- " to the value just inserted.\n"
- "    ///\n    "
- ///
- " This operation is safe if a "
- " is safe if a value does not "
- " value does not exist in the set"
- "exist in the set.\n    ///\n    "
- ///
- " However, if a value exists in "
- "value exists in the set already,"
- "the set already, the behavior is"
- " the behavior is unspecified:\n"
- "    "
- ///
- " this operation may panic, loop "
- "may panic, loop forever, or any "
- "forever, or any following "
- " any following operation with "
- " operation with the set\n    "
- ///
- " may panic, loop forever or "
- loop forever or return arbitrary
- "return arbitrary result.\n    "
- "///\n    "
- ///
- " That said, this operation (and "
- " operation (and following "
- " (and following operations) are "
- "operations) are guaranteed to\n"
- "    "
- "/// not violate memory safety.\n"
- "    ///\n    "
- ///
- " This operation is faster than "
- " is faster than regular insert, "
- "regular insert, because it does "
- "because it does not perform\n    "
- "/// lookup before insertion.\n"
- "    ///\n    "
- ///
- " This operation is useful during"
- "is useful during initial "
- " during initial population of "
- " population of the set.\n    "
- ///
- " For example, when constructing "
- " constructing a set from another"
- "set from another set, we know\n"
- "    /// that values are unique.\n"
- "    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn insert_unique_unchecked
- "(&mut self, value: T) -> &T "
- "{\n        "
- self.map.insert_unique_unchecked
- "(value, ()).0\n    }\n\n    "
- ///
- " Adds a value to the set, "
- " to the set, replacing the "
- ", replacing the existing value, "
- "existing value, if any, that is "
- "if any, that is equal to the "
- "is equal to the given\n    "
- ///
- " one. "
- "Returns the replaced value.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    "
- ///
- " set.insert(Vec::<i32>::new());\n"
- "    ///\n    "
- ///
- " assert_eq!("
- "set.get(&[][..]).unwrap()."
- "][..]).unwrap().capacity(), 0);\n"
- "    "
- ///
- " set.replace(Vec::with_capacity("
- "::with_capacity(10));\n    "
- ///
- " assert_eq!("
- "set.get(&[][..]).unwrap()."
- "][..]).unwrap().capacity(), 10);"
- "capacity(), 10);\n    /// ```\n"
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- pub fn replace
- " fn replace(&mut self, value: T)"
- " -> Option<T> "
- "{\n        "
- "match self.map.entry(value) "
- "{\n            "
- "map::Entry::Occupied(occupied) "
- " => Some(occupied.replace_key())"
- ",\n            "
- "map::Entry::Vacant(vacant) => "
- "{\n                "
- vacant.insert(());
- "\n                None"
- "None\n            }\n        }"
- "}\n    }\n\n    "
- ///
- " Removes a value from the set. "
- "Returns whether the value was\n"
- "    /// present in the set.\n    "
- "    ///\n    "
- ///
- " The value may be any borrowed "
- "be any borrowed form of the "
- " form of the set's value type, "
- " value type, but\n    "
- ///
- " [`Hash`] and [`Eq`] on the "
- " [`Eq`] on the borrowed form *"
- " borrowed form *must* match "
- " *must* match those for\n    "
- "/// the value type.\n    ///\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    ///\n    /// set.insert(2);\n"
- "    "
- ///
- " assert_eq!("
- "set.remove(&2), true);\n    "
- ///
- " assert_eq!("
- "set.remove(&2), false);\n    "
- "/// ```\n    ///\n    "
- ///
- " [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- "/std/cmp/trait.Eq.html\n    "
- ///
- " [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn remove<Q: ?Sized>"
- "(&mut self, value: &Q) -> bool"
- " -> bool\n    "
- "where\n        "
- "\n        Q: Hash + Equivalent<T>"
- ",\n    "
- "{\n        "
- self.map.remove(value).is_some()
- "\n    }\n\n    "
- ///
- " Removes and returns the value "
- " the value in the set, if any, "
- " set, if any, that is equal to "
- " is equal to the given one.\n    "
- "///\n    "
- ///
- " The value may be any borrowed "
- "be any borrowed form of the "
- " form of the set's value type, "
- " value type, but\n    "
- ///
- " [`Hash`] and [`Eq`] on the "
- " [`Eq`] on the borrowed form *"
- " borrowed form *must* match "
- " *must* match those for\n    "
- "/// the value type.\n    ///\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<_> = [1, 2"
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n    "
- ///
- " assert_eq!("
- "set.take(&2), Some(2));\n    "
- ///
- " assert_eq!("
- "set.take(&2), None);\n    "
- "/// ```\n    ///\n    "
- ///
- " [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- "/std/cmp/trait.Eq.html\n    "
- ///
- " [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn take<Q: ?Sized>"
- "(&mut self, value: &Q) -> "
- " -> Option<T>\n    "
- "where\n        "
- "\n        Q: Hash + Equivalent<T>"
- ",\n    "
- "{\n        "
- //
- " Avoid `Option::map` because it "
- "map` because it bloats LLVM IR.\n"
- "        "
- "match "
- " self.map.remove_entry(value) "
- "{\n            "
- "Some((k, _)) => Some(k),"
- "\n            None => None,"
- "None => None,\n        }\n    }\n}"
- "}\n\n"
- "impl<T, S, A: Allocator> "
- " HashSet<T, S, A> "
- "{\n    "
- ///
- " Returns a reference to the [`"
- " to the [`RawTable`] used "
- "RawTable`] used underneath [`"
- " underneath [`HashSet`].\n    "
- ///
- " This function is only available"
- " only available if the `raw` "
- " if the `raw` feature of the "
- " feature of the crate is enabled"
- "crate is enabled.\n    ///\n    "
- "///\n    /// # Note\n    ///\n    "
- ///
- " Calling this function is safe, "
- " is safe, but using the raw hash"
- " the raw hash table API may "
- " table API may require\n    "
- "/// unsafe functions or blocks.\n"
- "    ///\n    "
- ///
- " `RawTable` API gives the lowest"
- "gives the lowest level of "
- "lowest level of control under "
- " control under the set that can "
- " set that can be useful\n    "
- ///
- " for extending the HashSet's API"
- " HashSet's API, but may lead to "
- "but may lead to *[undefined "
- " to *[undefined behavior]*.\n    "
- "///\n    "
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n    "
- ///
- " [`RawTable`]: crate::raw::"
- "`]: crate::raw::RawTable\n    "
- ///
- " [undefined behavior]: https://"
- "]: https://doc.rust-lang.org/"
- "-lang.org/reference/behavior-"
- /behavior-considered-
- "-considered-undefined.html\n    "
- "#[cfg(feature = \"raw\")]\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn raw_table(&self) -> "
- "(&self) -> &RawTable<(T, ()), A>"
- " "
- "{\n        self.map.raw_table()"
- "\n    }\n\n    "
- ///
- " Returns a mutable reference to "
- " reference to the [`RawTable`] "
- " [`RawTable`] used underneath [`"
- " underneath [`HashSet`].\n    "
- ///
- " This function is only available"
- " only available if the `raw` "
- " if the `raw` feature of the "
- " feature of the crate is enabled"
- "crate is enabled.\n    ///\n    "
- "///\n    /// # Note\n    ///\n    "
- ///
- " Calling this function is safe, "
- " is safe, but using the raw hash"
- " the raw hash table API may "
- " table API may require\n    "
- "/// unsafe functions or blocks.\n"
- "    ///\n    "
- ///
- " `RawTable` API gives the lowest"
- "gives the lowest level of "
- "lowest level of control under "
- " control under the set that can "
- " set that can be useful\n    "
- ///
- " for extending the HashSet's API"
- " HashSet's API, but may lead to "
- "but may lead to *[undefined "
- " to *[undefined behavior]*.\n    "
- "///\n    "
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n    "
- ///
- " [`RawTable`]: crate::raw::"
- "`]: crate::raw::RawTable\n    "
- ///
- " [undefined behavior]: https://"
- "]: https://doc.rust-lang.org/"
- "-lang.org/reference/behavior-"
- /behavior-considered-
- "-considered-undefined.html\n    "
- "#[cfg(feature = \"raw\")]\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn raw_table_mut(&mut self) "
- "(&mut self) -> "
- " -> &mut RawTable<(T, ()), A> "
- "{\n        "
- "self.map.raw_table_mut()\n    }\n}"
- "}\n\n"
- "impl<T, S, A> PartialEq for "
- " PartialEq for HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- "fn eq(&self, other: &Self) -> "
- " -> bool "
- "{\n        "
- "if self.len() != other.len() "
- "{\n            return false;"
- "return false;\n        }"
- "\n        }\n\n        "
- self.iter().all
- "(|key| other.contains(key))\n    "
- "}\n}\n\n"
- "impl<T, S, A> Eq for "
- " Eq for HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " fmt::Debug for HashSet<T, S, A>"
- "HashSet<T, S, A>\n"
- "where\n    T: fmt::Debug,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- f.debug_set().entries
- "(self.iter()).finish()\n    }\n}\n\n"
- "impl<T, S, A> "
- " From<HashMap<T, (), S, A>> for "
- " for HashSet<T, S, A>\n"
- "\nwhere\n    A: Allocator,\n"
- "{\n    "
- fn from
- " from(map: HashMap<T, (), S, A>)"
- " -> Self "
- " {\n        Self { map }\n    }\n}"
- "}\n\n"
- "impl<T, S, A> FromIterator<T> "
- "FromIterator<T> for "
- " for HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher + Default,"
- ",\n    A: Default + Allocator,\n"
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- fn from_iter
- "<I: IntoIterator<Item = T>>"
- "(iter: I) -> Self "
- "{\n        "
- "let mut set = "
- "Self::with_hasher_in"
- "(Default::default(), "
- ", Default::default());\n        "
- "set.extend(iter);\n        set"
- "\n        set\n    }\n}\n\n"
- //
- " The default hasher is used to "
- " is used to match the std "
- " match the std implementation "
- " implementation signature\n"
- "#[cfg(feature = \"ahash\")]\n"
- "impl<T, A, const N: usize> "
- " From<[T; N]> for "
- HashSet
- "<T, DefaultHashBuilder, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    A: Default + Allocator,\n"
- "{\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let set1 = HashSet::from([1, 2,"
- "::from([1, 2, 3, 4]);\n    "
- ///
- " let set2: HashSet<_> = [1, 2, 3"
- "<_> = [1, 2, 3, 4].into();\n    "
- "/// assert_eq!(set1, set2);\n    "
- "    /// ```\n    "
- "fn from(arr: [T; N]) -> Self "
- "{\n        "
- "arr.into_iter().collect()\n    }\n"
- "}\n\n"
- "impl<T, S, A> Extend<T> for "
- " Extend<T> for HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- fn extend
- "<I: IntoIterator<Item = T>>"
- "(&mut self, iter: I) "
- "{\n        "
- self.map.extend
- (
- iter.into_iter().map
- "(|k| (k, ())));\n    }\n\n    "
- "#[inline]\n    "
- "\n    #[cfg(feature = \"nightly\")]"
- "\n    "
- "fn extend_one(&mut self, k: T) "
- "{\n        "
- "\n        self.map.insert(k, ());"
- "\n    }\n\n    #[inline]\n    "
- "\n    #[cfg(feature = \"nightly\")]"
- "\n    "
- fn extend_reserve
- "(&mut self, additional: usize) "
- "{\n        "
- "Extend::<(T, ())>::"
- "::extend_reserve"
- "(&mut self.map, additional);"
- ";\n    }\n}\n\n"
- "impl<'a, T, S, A> Extend<&'a T> "
- " Extend<&'a T> for "
- " for HashSet<T, S, A>\n"
- "where\n    "
- "\n    T: 'a + Eq + Hash + Copy,"
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- fn extend
- "<I: IntoIterator<Item = &'a T>>"
- "(&mut self, iter: I) "
- "{\n        "
- self.extend
- (iter.into_iter().copied());
- ";\n    }\n\n    #[inline]\n    "
- "\n    #[cfg(feature = \"nightly\")]"
- "\n    "
- fn extend_one
- " extend_one(&mut self, k: &'a T)"
- " "
- "{\n        "
- "self.map.insert(*k, ());\n    }"
- "\n    }\n\n    #[inline]\n    "
- "\n    #[cfg(feature = \"nightly\")]"
- "\n    "
- fn extend_reserve
- "(&mut self, additional: usize) "
- "{\n        "
- "Extend::<(T, ())>::"
- "::extend_reserve"
- "(&mut self.map, additional);"
- ";\n    }\n}\n\n"
- "impl<T, S, A> Default for "
- " Default for HashSet<T, S, A>\n"
- "where\n    S: Default,\n    "
- ",\n    A: Default + Allocator,\n"
- "{\n    "
- ///
- " Creates an empty `HashSet<T, S>"
- " `HashSet<T, S>` with the `"
- ", S>` with the `Default` value "
- "`Default` value for the hasher.\n"
- "    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn default() -> Self "
- "{\n        "
- "Self "
- "{\n            "
- "map: HashMap::default(),"
- ",\n        }\n    }\n}\n\n"
- "impl<T, S, A> "
- " BitOr<&HashSet<T, S, A>> for "
- " for &HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash + Clone,"
- ",\n    S: BuildHasher + Default,"
- ",\n    A: Allocator,\n"
- "{\n    "
- "type Output = HashSet<T, S>;"
- "\n\n    "
- ///
- " Returns the union of `self` and"
- " of `self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    "
- ///
- " let b: HashSet<_> = vec!["
- "3, 4, 5].into_iter().collect();\n"
- "    ///\n    "
- "///\n    /// let set = &a | &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    "
- ///
- " let expected = [1, 2, 3, 4, 5];"
- "[1, 2, 3, 4, 5];\n    "
- "/// for x in &set {\n    "
- ///
- "     assert!("
- "expected.contains(x));\n    "
- "///     i += 1;\n    /// }\n    "
- ///
- " assert_eq!(i, expected.len());\n"
- "    /// ```\n    "
- fn bitor
- "(self, rhs: &HashSet<T, S, A>) "
- " -> HashSet<T, S> "
- "{\n        "
- self.union(rhs).cloned().collect
- "()\n    }\n}\n\n"
- "impl<T, S, A> "
- " BitAnd<&HashSet<T, S, A>> for "
- " for &HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash + Clone,"
- ",\n    S: BuildHasher + Default,"
- ",\n    A: Allocator,\n"
- "{\n    "
- "type Output = HashSet<T, S>;"
- "\n\n    "
- ///
- " Returns the intersection of `"
- " of `self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    "
- ///
- " let b: HashSet<_> = vec!["
- "2, 3, 4].into_iter().collect();\n"
- "    ///\n    "
- "///\n    /// let set = &a & &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    /// let expected = [2, 3];\n"
- "    /// for x in &set {\n    "
- ///
- "     assert!("
- "expected.contains(x));\n    "
- "///     i += 1;\n    /// }\n    "
- ///
- " assert_eq!(i, expected.len());\n"
- "    /// ```\n    "
- fn bitand
- "(self, rhs: &HashSet<T, S, A>) "
- " -> HashSet<T, S> "
- "{\n        "
- self.intersection(rhs).cloned().
- ".collect()\n    }\n}\n\n"
- "impl<T, S> "
- "<T, S> BitXor<&HashSet<T, S>> "
- " for &HashSet<T, S>\n"
- "where\n    T: Eq + Hash + Clone,"
- ",\n    S: BuildHasher + Default,\n"
- "{\n    "
- "type Output = HashSet<T, S>;"
- "\n\n    "
- ///
- " Returns the symmetric "
- " the symmetric difference of `"
- " difference of `self` and `rhs` "
- "self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    "
- ///
- " let b: HashSet<_> = vec!["
- "3, 4, 5].into_iter().collect();\n"
- "    ///\n    "
- "///\n    /// let set = &a ^ &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    "
- ///
- "/ let expected = [1, 2, 4, 5];\n"
- "    /// for x in &set {\n    "
- ///
- "     assert!("
- "expected.contains(x));\n    "
- "///     i += 1;\n    /// }\n    "
- ///
- " assert_eq!(i, expected.len());\n"
- "    /// ```\n    "
- fn bitxor
- "(self, rhs: &HashSet<T, S>) -> "
- " -> HashSet<T, S> "
- "{\n        "
- self.symmetric_difference(rhs).
- ".cloned().collect()\n    }\n}\n\n"
- "impl<T, S> Sub<&HashSet<T, S>> "
- " for &HashSet<T, S>\n"
- "where\n    T: Eq + Hash + Clone,"
- ",\n    S: BuildHasher + Default,\n"
- "{\n    "
- "type Output = HashSet<T, S>;"
- "\n\n    "
- ///
- " Returns the difference of `self"
- " of `self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    "
- ///
- " let b: HashSet<_> = vec!["
- "3, 4, 5].into_iter().collect();\n"
- "    ///\n    "
- "///\n    /// let set = &a - &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    /// let expected = [1, 2];\n"
- "    /// for x in &set {\n    "
- ///
- "     assert!("
- "expected.contains(x));\n    "
- "///     i += 1;\n    /// }\n    "
- ///
- " assert_eq!(i, expected.len());\n"
- "    /// ```\n    "
- fn sub
- " sub(self, rhs: &HashSet<T, S>) "
- " -> HashSet<T, S> "
- "{\n        "
- self.difference(rhs).cloned().
- ".collect()\n    }\n}\n\n"
- ///
- " An iterator over the items of a"
- " the items of a `HashSet`.\n///\n"
- ///
- " This `struct` is created by the"
- " created by the [`iter`] method "
- "[`iter`] method on [`HashSet`].\n"
- ///
- " See its documentation for more."
- " for more.\n///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`iter`]: struct.HashSet.html#"
- "#method.iter\n"
- "pub struct Iter<'a, K> "
- " {\n    iter: Keys<'a, K, ()>,\n}"
- "\n\n"
- ///
- " An owning iterator over the "
- " over the items of a `HashSet`.\n"
- "///\n"
- ///
- " This `struct` is created by the"
- " created by the [`into_iter`] "
- " [`into_iter`] method on [`"
- "`] method on [`HashSet`]\n"
- ///
- " (provided by the `IntoIterator`"
- " `IntoIterator` trait). "
- "See its documentation for more.\n"
- "///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`into_iter`]: "
- "into_iter`]: struct.HashSet.html"
- "#method.into_iter\n"
- pub struct IntoIter
- "<K, A: Allocator = Global> "
- "{\n    "
- "iter: map::IntoIter<K, (), A>,\n}"
- ",\n}\n\n"
- ///
- " A draining iterator over the "
- " over the items of a `HashSet`.\n"
- "///\n"
- ///
- " This `struct` is created by the"
- " created by the [`drain`] method"
- "[`drain`] method on [`HashSet`]."
- " on [`HashSet`].\n"
- ///
- " See its documentation for more."
- " for more.\n///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`drain`]: struct.HashSet.html#"
- "#method.drain\n"
- pub struct Drain
- "<'a, K, A: Allocator = Global> "
- "{\n    "
- "iter: map::Drain<'a, K, (), A>,\n"
- ",\n}\n\n"
- ///
- " A draining iterator over "
- " iterator over entries of a `"
- " entries of a `HashSet` which "
- "`HashSet` which don't satisfy "
- " don't satisfy the predicate `f`"
- " predicate `f`.\n///\n"
- ///
- " This `struct` is created by the"
- " created by the [`extract_if`] "
- " [`extract_if`] method on [`"
- "`] method on [`HashSet`]. "
- "See its\n"
- "/// documentation for more.\n///\n"
- ///
- " [`extract_if`]: "
- "`]: struct.HashSet.html#"
- "#method.extract_if\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "#["
- "must_use = "
- "\""
- "Iterators are lazy unless "
- "are lazy unless consumed\"]\n"
- pub struct ExtractIf
- "<'a, K, F, A: Allocator = Global"
- ">\n"
- "where\n    F: FnMut(&K) -> bool,\n"
- "{\n    f: F,\n    "
- "inner: "
- ": RawExtractIf<'a, (K, ()), A>,\n"
- ",\n}\n\n"
- ///
- " A lazy iterator producing "
- " producing elements in the "
- "elements in the intersection of "
- "intersection of `HashSet`s.\n///\n"
- ///
- " This `struct` is created by the"
- " created by the [`intersection`]"
- "[`intersection`] method on [`"
- "`] method on [`HashSet`].\n"
- ///
- " See its documentation for more."
- " for more.\n///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`intersection`]: "
- "`]: struct.HashSet.html#"
- "#method.intersection\n"
- pub struct Intersection
- "<'a, T, S, A: Allocator = Global"
- "> "
- "{\n    "
- // iterator of the first set
- "\n    iter: Iter<'a, T>,\n    "
- ",\n    // the second set\n    "
- "\n    other: &'a HashSet<T, S, A>"
- ",\n}\n\n"
- ///
- " A lazy iterator producing "
- " producing elements in the "
- "elements in the difference of `"
- " difference of `HashSet`s.\n///\n"
- ///
- " This `struct` is created by the"
- " created by the [`difference`] "
- " [`difference`] method on [`"
- "`] method on [`HashSet`].\n"
- ///
- " See its documentation for more."
- " for more.\n///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`difference`]: "
- "`]: struct.HashSet.html#"
- "#method.difference\n"
- pub struct Difference
- "<'a, T, S, A: Allocator = Global"
- "> "
- "{\n    "
- // iterator of the first set
- "\n    iter: Iter<'a, T>,\n    "
- ",\n    // the second set\n    "
- "\n    other: &'a HashSet<T, S, A>"
- ",\n}\n\n"
- ///
- " A lazy iterator producing "
- " producing elements in the "
- "elements in the symmetric "
- " the symmetric difference of `"
- " difference of `HashSet`s.\n///\n"
- ///
- " This `struct` is created by the"
- " created by the [`"
- " by the [`symmetric_difference`]"
- "`] method on\n"
- ///
- " [`HashSet`]. "
- "See its documentation for more.\n"
- "///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`symmetric_difference`]: "
- "`]: struct.HashSet.html#"
- "#method.symmetric_difference\n"
- pub struct SymmetricDifference
- "<'a, T, S, A: Allocator = Global"
- "> "
- "{\n    "
- "iter: "
- Chain
- "<Difference<'a, T, S, A>, "
- ", Difference<'a, T, S, A>>,\n}\n\n"
- ///
- " A lazy iterator producing "
- " producing elements in the union"
- " in the union of `HashSet`s.\n"
- "///\n"
- ///
- " This `struct` is created by the"
- " created by the [`union`] method"
- "[`union`] method on [`HashSet`]."
- " on [`HashSet`].\n"
- ///
- " See its documentation for more."
- " for more.\n///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`union`]: struct.HashSet.html#"
- "#method.union\n"
- pub struct Union
- "<'a, T, S, A: Allocator = Global"
- "> "
- "{\n    "
- "iter: "
- Chain
- "<Iter<'a, T>, "
- ", Difference<'a, T, S, A>>,\n}\n\n"
- "impl<'a, T, S, A: Allocator> "
- " IntoIterator for "
- " for &'a HashSet<T, S, A> "
- "{\n    type Item = &'a T;\n    "
- "type IntoIter = Iter<'a, T>;"
- "\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn into_iter(self) -> "
- "(self) -> Iter<'a, T> "
- " {\n        self.iter()\n    }\n}\n\n"
- "impl<T, S, A: Allocator> "
- " IntoIterator for "
- " for HashSet<T, S, A> "
- "{\n    type Item = T;\n    "
- "type IntoIter = IntoIter<T, A>;"
- "\n\n    "
- ///
- " Creates a consuming iterator, "
- " iterator, that is, one that "
- " is, one that moves each value "
- " each value out\n    "
- ///
- " of the set in arbitrary order. "
- "The set cannot be used after "
- " be used after calling\n    "
- "/// this.\n    ///\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- "/ let mut set = HashSet::new();\n"
- "    "
- ///
- "/ set.insert(\"a\".to_string());\n"
- "    "
- ///
- "/ set.insert(\"b\".to_string());\n"
- "    ///\n    "
- ///
- " // Not possible to collect to a"
- " to collect to a Vec<String> "
- " a Vec<String> with a regular `."
- " a regular `.iter()`.\n    "
- ///
- " let v: Vec<String> = "
- ": Vec<String> = set.into_iter()."
- "set.into_iter().collect();\n    "
- "///\n    "
- ///
- " // Will print in an arbitrary "
- "in an arbitrary order.\n    "
- "/// for x in &v {\n    "
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn into_iter(self) -> "
- "(self) -> IntoIter<T, A> "
- "{\n        "
- "IntoIter "
- "{\n            "
- "iter: self.map.into_iter(),"
- ",\n        }\n    }\n}\n\n"
- "impl<K> Clone for Iter<'_, K> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn clone(&self) -> Self "
- "{\n        "
- "Iter "
- "{\n            "
- "iter: self.iter.clone(),"
- ",\n        }\n    }\n}\n"
- "impl<'a, K> Iterator for "
- " Iterator for Iter<'a, K> "
- "{\n    type Item = &'a K;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> "
- "(&mut self) -> Option<&'a K> "
- "{\n        self.iter.next()\n    }"
- "\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        self.iter.size_hint()"
- "\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- " fold<B, F>(self, init: B, f: F)"
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- "\n        self.iter.fold(init, f)"
- "\n    }\n}\n"
- "impl<'a, K> ExactSizeIterator "
- " for Iter<'a, K> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn len(&self) -> usize "
- " {\n        self.iter.len()\n    }"
- "\n}\n"
- "impl<K> FusedIterator for "
- " for Iter<'_, K> {}\n\n"
- "impl<K: fmt::Debug> fmt::Debug "
- " fmt::Debug for Iter<'_, K> "
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- f.debug_list().entries
- "(self.clone()).finish()\n    }\n}"
- "}\n\n"
- "impl<K, A: Allocator> Iterator "
- " Iterator for IntoIter<K, A> "
- "{\n    type Item = K;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> Option<K> "
- "{\n        "
- //
- " Avoid `Option::map` because it "
- "map` because it bloats LLVM IR.\n"
- "        "
- "match self.iter.next() "
- "{\n            "
- "Some((k, _)) => Some(k),"
- "\n            None => None,"
- "None => None,\n        }\n    }"
- "}\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        self.iter.size_hint()"
- "\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- "<B, F>(self, init: B, mut f: F) "
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- self.iter.fold
- "(init, |acc, (k, ())| f(acc, k))"
- "\n    }\n}\n"
- "impl<K, A: Allocator> "
- " ExactSizeIterator for "
- " for IntoIter<K, A> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn len(&self) -> usize "
- " {\n        self.iter.len()\n    }"
- "\n}\n"
- "impl<K, A: Allocator> "
- " FusedIterator for "
- " for IntoIter<K, A> {}\n\n"
- impl
- "<K: fmt::Debug, A: Allocator> "
- " fmt::Debug for IntoIter<K, A> "
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- "let entries_iter = "
- "self.iter.iter().map(|(k, _)| k)"
- ";\n        "
- f.debug_list().entries
- "(entries_iter).finish()\n    }\n}"
- "}\n\n"
- "impl<K, A: Allocator> Iterator "
- " Iterator for Drain<'_, K, A> "
- "{\n    type Item = K;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> Option<K> "
- "{\n        "
- //
- " Avoid `Option::map` because it "
- "map` because it bloats LLVM IR.\n"
- "        "
- "match self.iter.next() "
- "{\n            "
- "Some((k, _)) => Some(k),"
- "\n            None => None,"
- "None => None,\n        }\n    }"
- "}\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        self.iter.size_hint()"
- "\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- "<B, F>(self, init: B, mut f: F) "
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- self.iter.fold
- "(init, |acc, (k, ())| f(acc, k))"
- "\n    }\n}\n"
- "impl<K, A: Allocator> "
- " ExactSizeIterator for "
- " for Drain<'_, K, A> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn len(&self) -> usize "
- " {\n        self.iter.len()\n    }"
- "\n}\n"
- "impl<K, A: Allocator> "
- " FusedIterator for "
- " for Drain<'_, K, A> {}\n\n"
- impl
- "<K: fmt::Debug, A: Allocator> "
- " fmt::Debug for Drain<'_, K, A> "
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- "let entries_iter = "
- "self.iter.iter().map(|(k, _)| k)"
- ";\n        "
- f.debug_list().entries
- "(entries_iter).finish()\n    }\n}"
- "}\n\n"
- "impl<K, F, A: Allocator> "
- " Iterator for "
- " for ExtractIf<'_, K, F, A>\n"
- "\nwhere\n    F: FnMut(&K) -> bool,"
- "\n"
- "{\n    type Item = K;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> "
- " -> Option<Self::Item> "
- "{\n        "
- "self.inner\n            .next"
- "(|&mut (ref k, ())| (self.f)(k))"
- "\n            .map(|(k, ())| k)"
- "(|(k, ())| k)\n    }\n\n    "
- "#[inline]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        "
- "(0, "
- "0, self.inner.iter.size_hint().1"
- ")\n    }\n}\n\n"
- "impl<K, F, A: Allocator> "
- " FusedIterator for "
- " for ExtractIf<'_, K, F, A> "
- " where F: FnMut(&K) -> bool {}\n\n"
- "impl<T, S, A: Allocator> Clone "
- " Clone for "
- " for Intersection<'_, T, S, A> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn clone(&self) -> Self "
- "{\n        "
- "Intersection "
- "{\n            "
- "iter: self.iter.clone(),"
- ",\n            ..*self\n        }"
- "\n        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- " for Intersection<'a, T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    type Item = &'a T;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> "
- "(&mut self) -> Option<&'a T> "
- "{\n        "
- "loop "
- "{\n            "
- let elt = self.iter.next()?;
- "\n            "
- "if self.other.contains(elt) "
- "{\n                "
- "return Some(elt);\n            }"
- "\n            }\n        }\n    }"
- "}\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        "
- "let (_, upper) = "
- " = self.iter.size_hint();"
- ";\n        (0, upper)\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- "<B, F>(self, init: B, mut f: F) "
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- self.iter.fold
- "(init, "
- "|acc, elt| "
- "{\n            "
- "if self.other.contains(elt) "
- "{\n                f(acc, elt)"
- "f(acc, elt)\n            } "
- "else "
- "{\n                acc"
- "acc\n            }\n        })"
- ")\n    }\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " for Intersection<'_, T, S, A>\n"
- "where\n    "
- "\n    T: fmt::Debug + Eq + Hash,"
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- f.debug_list().entries
- "(self.clone()).finish()\n    }\n}"
- "}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for Intersection<'_, T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A: Allocator> Clone "
- " Clone for "
- " for Difference<'_, T, S, A> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn clone(&self) -> Self "
- "{\n        "
- "Difference "
- "{\n            "
- "iter: self.iter.clone(),"
- ",\n            ..*self\n        }"
- "\n        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- " for Difference<'a, T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    type Item = &'a T;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> "
- "(&mut self) -> Option<&'a T> "
- "{\n        "
- "loop "
- "{\n            "
- let elt = self.iter.next()?;
- "\n            "
- "if !self.other.contains(elt) "
- "{\n                "
- "return Some(elt);\n            }"
- "\n            }\n        }\n    }"
- "}\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        "
- "let (_, upper) = "
- " = self.iter.size_hint();"
- ";\n        (0, upper)\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- "<B, F>(self, init: B, mut f: F) "
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- self.iter.fold
- "(init, "
- "|acc, elt| "
- "{\n            "
- "if self.other.contains(elt) "
- "{\n                acc"
- "acc\n            } "
- "else "
- "{\n                f(acc, elt)"
- "f(acc, elt)\n            }"
- "\n            }\n        })\n    }\n"
- "}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for Difference<'_, T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " for Difference<'_, T, S, A>\n"
- "where\n    "
- "\n    T: fmt::Debug + Eq + Hash,"
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- f.debug_list().entries
- "(self.clone()).finish()\n    }\n}"
- "}\n\n"
- "impl<T, S, A: Allocator> Clone "
- " Clone for "
- "SymmetricDifference<'_, T, S, A>"
- " "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn clone(&self) -> Self "
- "{\n        "
- "SymmetricDifference "
- "{\n            "
- "iter: self.iter.clone(),"
- ",\n        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- "SymmetricDifference<'a, T, S, A>"
- "\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    type Item = &'a T;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> "
- "(&mut self) -> Option<&'a T> "
- "{\n        self.iter.next()\n    }"
- "\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        self.iter.size_hint()"
- "\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- " fold<B, F>(self, init: B, f: F)"
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- "\n        self.iter.fold(init, f)"
- "\n    }\n}\n\n"
- "impl<T, S, A> FusedIterator for "
- "SymmetricDifference<'_, T, S, A>"
- "\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- "SymmetricDifference<'_, T, S, A>"
- "\n"
- "where\n    "
- "\n    T: fmt::Debug + Eq + Hash,"
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- f.debug_list().entries
- "(self.clone()).finish()\n    }\n}"
- "}\n\n"
- "impl<T, S, A: Allocator> Clone "
- " Clone for Union<'_, T, S, A> "
- "{\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn clone(&self) -> Self "
- "{\n        "
- "Union "
- "{\n            "
- "iter: self.iter.clone(),"
- ",\n        }\n    }\n}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for Union<'_, T, S, A>\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " for Union<'_, T, S, A>\n"
- "where\n    "
- "\n    T: fmt::Debug + Eq + Hash,"
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- f.debug_list().entries
- "(self.clone()).finish()\n    }\n}"
- "}\n\n"
- "impl<'a, T, S, A> Iterator for "
- " Iterator for Union<'a, T, S, A>"
- "\n"
- "where\n    T: Eq + Hash,\n    "
- ",\n    S: BuildHasher,\n    "
- ",\n    A: Allocator,\n"
- "{\n    type Item = &'a T;\n\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn next(&mut self) -> "
- "(&mut self) -> Option<&'a T> "
- "{\n        self.iter.next()\n    }"
- "\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn size_hint(&self) -> "
- " -> (usize, Option<usize>) "
- "{\n        self.iter.size_hint()"
- "\n    }\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "fn fold<B, F>"
- " fold<B, F>(self, init: B, f: F)"
- " -> B\n    "
- "where\n        Self: Sized,"
- "Self: Sized,\n        "
- "F: FnMut(B, Self::Item) -> B,"
- ",\n    "
- "{\n        "
- "\n        self.iter.fold(init, f)"
- "\n    }\n}\n\n"
- ///
- " A view into a single entry in a"
- " entry in a set, which may "
- " set, which may either be vacant"
- "either be vacant or occupied.\n"
- "///\n"
- ///
- " This `enum` is constructed from"
- "constructed from the [`entry`] "
- " the [`entry`] method on [`"
- "`] method on [`HashSet`].\n///\n"
- ///
- " [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- ///
- " [`entry`]: struct.HashSet.html#"
- "#method.entry\n///\n"
- "///\n/// # Examples\n///\n/// ```\n"
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet, "
- "Entry, HashSet, OccupiedEntry};\n"
- "///\n"
- ///
- "/ let mut set = HashSet::new();\n"
- ///
- "/ set.extend([\"a\", \"b\", \"c\"]);\n"
- "/// assert_eq!(set.len(), 3);\n"
- "///\n"
- "/// // Existing value (insert)\n"
- ///
- " let entry: Entry<_, _> = "
- ": Entry<_, _> = set.entry(\"a\");\n"
- ///
- " let _raw_o: OccupiedEntry<_, _>"
- "<_, _> = entry.insert();\n"
- "/// assert_eq!(set.len(), 3);\n"
- ///
- "/ // Nonexistent value (insert)\n"
- "/// set.entry(\"d\").insert();\n"
- "///\n"
- ///
- "/ // Existing value (or_insert)\n"
- "/// set.entry(\"b\").or_insert();\n"
- ///
- " // Nonexistent value (or_insert"
- "value (or_insert)\n"
- "/// set.entry(\"e\").or_insert();\n"
- "///\n"
- ///
- " println!(\""
- "Our HashSet: {:?}\", set);\n///\n"
- ///
- " let mut vec: Vec<_> = set.iter("
- "<_> = set.iter().copied()."
- "().copied().collect();\n"
- ///
- " // The `Iter` iterator produces"
- " produces items in arbitrary "
- " in arbitrary order, so the\n"
- ///
- " // items must be sorted to test"
- " sorted to test them against a "
- " them against a sorted array.\n"
- "/// vec.sort_unstable();\n"
- ///
- " assert_eq!("
- "vec, [\"a\", \"b\", \"c\", \"d\", \"e\"]);"
- "\"c\", \"d\", \"e\"]);\n/// ```\n"
- pub enum Entry
- "enum Entry<'a, T, S, A = Global>"
- "\nwhere\n    A: Allocator,\n"
- "{\n    /// An occupied entry.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet};\n    "
- ///
- " let mut set: HashSet<_> = [\"a\","
- "<_> = [\"a\", \"b\"].into();\n    "
- "///\n    "
- "    /// match set.entry(\"a\") {\n"
- "    "
- ///
- "     Entry::Vacant(_) => "
- "::Vacant(_) => unreachable!(),\n"
- "    "
- ///
- "/     Entry::Occupied(_) => { }\n"
- "    /// }\n    /// ```\n    "
- Occupied
- "(OccupiedEntry<'a, T, S, A>),"
- ",\n\n    /// A vacant entry.\n    "
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet};\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    ///\n    "
- "    /// match set.entry(\"a\") {\n"
- "    "
- ///
- "     Entry::Occupied(_) => "
- ":Occupied(_) => unreachable!(),\n"
- "    "
- "///     Entry::Vacant(_) => { }\n"
- "    /// }\n    /// ```\n    "
- "Vacant(VacantEntry<'a, T, S, A>)"
- ",\n}\n\n"
- impl
- "<T: fmt::Debug, S, A: Allocator>"
- " fmt::Debug for "
- " for Entry<'_, T, S, A> "
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- "match *self "
- "{\n            "
- "Entry::Vacant(ref v) => "
- "f.debug_tuple(\"Entry\").field(v)."
- ".finish(),\n            "
- "Entry::Occupied(ref o) => "
- "f.debug_tuple(\"Entry\").field(o)."
- ".finish(),\n        }\n    }\n}\n\n"
- ///
- " A view into an occupied entry "
- " occupied entry in a `HashSet`.\n"
- ///
- " It is part of the [`Entry`] "
- " the [`Entry`] enum.\n///\n"
- "/// [`Entry`]: enum.Entry.html\n"
- "///\n/// # Examples\n///\n/// ```\n"
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet, "
- "Entry, HashSet, OccupiedEntry};\n"
- "///\n"
- ///
- "/ let mut set = HashSet::new();\n"
- ///
- "/ set.extend([\"a\", \"b\", \"c\"]);\n"
- "///\n"
- ///
- " let _entry_o: OccupiedEntry<_, "
- "<_, _> = set.entry(\"a\").insert()"
- "(\"a\").insert();\n"
- "/// assert_eq!(set.len(), 3);\n"
- "///\n/// // Existing key\n"
- "/// match set.entry(\"a\") {\n"
- ///
- "     Entry::Vacant(_) => "
- "::Vacant(_) => unreachable!(),\n"
- ///
- "     Entry::Occupied(view) => {\n"
- ///
- "         assert_eq!("
- "view.get(), &\"a\");\n///     }\n"
- "///     }\n/// }\n///\n"
- "/// assert_eq!(set.len(), 3);\n"
- "///\n/// // Existing key (take)\n"
- "/// match set.entry(\"c\") {\n"
- ///
- "     Entry::Vacant(_) => "
- "::Vacant(_) => unreachable!(),\n"
- ///
- "     Entry::Occupied(view) => {\n"
- ///
- "         assert_eq!("
- "view.remove(), \"c\");\n///     }\n"
- "///     }\n/// }\n"
- ///
- " assert_eq!("
- "set.get(&\"c\"), None);\n"
- "/// assert_eq!(set.len(), 2);\n"
- "/// ```\n"
- pub struct OccupiedEntry
- "<'a, T, S, A: Allocator = Global"
- "> "
- "{\n    "
- "inner: "
- "map::OccupiedEntry"
- "<'a, T, (), S, A>,\n}\n\n"
- impl
- "<T: fmt::Debug, S, A: Allocator>"
- " fmt::Debug for "
- " for OccupiedEntry<'_, T, S, A> "
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- "f.debug_struct(\"OccupiedEntry\")"
- "\n            .field"
- "(\"value\", self.get())"
- "\n            .finish()\n    }\n}\n\n"
- ///
- " A view into a vacant entry in a"
- " entry in a `HashSet`.\n"
- ///
- " It is part of the [`Entry`] "
- " the [`Entry`] enum.\n///\n"
- "/// [`Entry`]: enum.Entry.html\n"
- "///\n/// # Examples\n///\n/// ```\n"
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet, "
- "Entry, HashSet, VacantEntry};\n"
- "///\n"
- ///
- " let mut set = HashSet::<&str>::"
- "::<&str>::new();\n///\n"
- ///
- " let entry_v: VacantEntry<_, _> "
- "<_, _> = match set.entry(\"a\") {\n"
- ///
- "     Entry::Vacant(view) => view"
- "(view) => view,\n"
- ///
- "     Entry::Occupied(_) => "
- ":Occupied(_) => unreachable!(),\n"
- "/// };\n/// entry_v.insert();\n"
- ///
- " assert!("
- "set.contains(\"a\") && set.len() ="
- ") && set.len() == 1);\n///\n"
- "/// // Nonexistent key (insert)\n"
- "/// match set.entry(\"b\") {\n"
- ///
- "     Entry::Vacant(view) => { "
- "(view) => { view.insert(); },\n"
- ///
- "     Entry::Occupied(_) => "
- ":Occupied(_) => unreachable!(),\n"
- "/// }\n"
- ///
- " assert!("
- "set.contains(\"b\") && set.len() ="
- ") && set.len() == 2);\n/// ```\n"
- pub struct VacantEntry
- "<'a, T, S, A: Allocator = Global"
- "> "
- "{\n    "
- "inner: "
- "map::VacantEntry"
- "<'a, T, (), S, A>,\n}\n\n"
- impl
- "<T: fmt::Debug, S, A: Allocator>"
- " fmt::Debug for "
- " for VacantEntry<'_, T, S, A> "
- "{\n    "
- fn fmt
- "(&self, "
- ", f: &mut fmt::Formatter<'_>) ->"
- "-> fmt::Result "
- "{\n        "
- "f.debug_tuple(\"VacantEntry\")."
- ".field(self.get()).finish()\n    "
- "}\n}\n\n"
- "impl<'a, T, S, A: Allocator> "
- " Entry<'a, T, S, A> "
- "{\n    "
- ///
- " Sets the value of the entry, "
- " of the entry, and returns an "
- " and returns an OccupiedEntry.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    "
- ///
- " let entry = set.entry(\""
- " = set.entry(\"horseyland\")."
- "(\"horseyland\").insert();\n    "
- "///\n    "
- ///
- " assert_eq!("
- "entry.get(), &\"horseyland\");\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn insert(self) -> "
- " -> OccupiedEntry<'a, T, S, A>"
- "\n    "
- "where\n        T: Hash,\n        "
- ",\n        S: BuildHasher,\n    "
- "{\n        "
- "match self "
- "{\n            "
- "Entry::Occupied(entry) => entry,"
- "\n            "
- "Entry::Vacant(entry) => "
- " => entry.insert(),\n        }"
- "}\n    }\n\n    "
- ///
- " Ensures a value is in the entry"
- " is in the entry by inserting if"
- " by inserting if it was vacant.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    ///\n    "
- "///\n    /// // nonexistent key\n"
- "    "
- ///
- " set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n    "
- ///
- " assert!("
- "set.contains(\"poneyland\"));\n    "
- "///\n    /// // existing key\n    "
- ///
- " set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n    "
- ///
- " assert!("
- "set.contains(\"poneyland\"));\n    "
- "/// assert_eq!(set.len(), 1);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn or_insert(self)\n    "
- "where\n        T: Hash,\n        "
- ",\n        S: BuildHasher,\n    "
- "{\n        "
- "if "
- " let Entry::Vacant(entry) = self"
- " "
- "{\n            entry.insert();"
- "entry.insert();\n        }\n    }"
- "}\n\n    "
- ///
- " Returns a reference to this "
- " to this entry's value.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    "
- ///
- " set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n    "
- "/// // existing key\n    "
- ///
- " assert_eq!("
- "set.entry(\"poneyland\").get(), &\""
- "\").get(), &\"poneyland\");\n    "
- "/// // nonexistent key\n    "
- ///
- " assert_eq!("
- "set.entry(\"horseland\").get(), &\""
- "\").get(), &\"horseland\");\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn get(&self) -> &T "
- "{\n        "
- "match *self "
- "{\n            "
- "Entry::Occupied(ref entry) => "
- " => entry.get(),\n            "
- "Entry::Vacant(ref entry) => "
- " => entry.get(),\n        }\n    }"
- "}\n}\n\n"
- "impl<T, S, A: Allocator> "
- " OccupiedEntry<'_, T, S, A> "
- "{\n    "
- ///
- " Gets a reference to the value "
- " to the value in the entry.\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet};\n    "
- "///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    "
- ///
- " set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n    "
- "///\n    "
- ///
- " match set.entry(\"poneyland\") {\n"
- "    "
- ///
- "     Entry::Vacant(_) => panic!("
- "(_) => panic!(),\n    "
- ///
- "     Entry::Occupied(entry) => "
- (entry) => assert_eq!(
- "entry.get(), &\"poneyland\"),\n    "
- "/// }\n    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn get(&self) -> &T "
- "{\n        self.inner.key()\n    }"
- "\n\n    "
- ///
- " Takes the value out of the "
- " out of the entry, and returns "
- ", and returns it.\n    "
- ///
- " Keeps the allocated memory for "
- " memory for reuse.\n    ///\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_set::Entry;"
- "hash_set::Entry;\n    ///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    /// // The set is empty\n    "
- ///
- " assert!("
- set.is_empty() && set.capacity()
- "& set.capacity() == 0);\n    ///\n"
- "///\n    "
- ///
- " set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n    "
- ///
- " let capacity_before_remove = "
- " = set.capacity();\n    ///\n    "
- ///
- " if let Entry::Occupied(o) = "
- "::Occupied(o) = set.entry(\""
- "o) = set.entry(\"poneyland\") {\n"
- "    "
- ///
- "     assert_eq!("
- "o.remove(), \"poneyland\");\n    "
- "/// }\n    ///\n    "
- ///
- " assert_eq!("
- "set.contains(\"poneyland\"), false"
- "\"), false);\n    "
- ///
- " // Now set hold none elements "
- " none elements but capacity is "
- but capacity is equal to the old
- "equal to the old one\n    "
- ///
- " assert!("
- set.len() == 0 && set.capacity()
- "& set.capacity() == "
- "() == capacity_before_remove);\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn remove(self) -> T "
- "{\n        "
- "self.inner.remove_entry().0\n    "
- "\n    }\n\n    "
- ///
- " Replaces the entry, returning "
- ", returning the old value. "
- "The new value in the hash map "
- "in the hash map will be\n    "
- ///
- " the value used to create this "
- " to create this entry.\n    ///\n"
- "///\n    /// # Panics\n    ///\n"
- "    ///\n    "
- ///
- " Will panic if this "
- " panic if this OccupiedEntry was"
- " was created through [`Entry::"
- " [`Entry::insert`].\n    ///\n    "
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- ///
- "  use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet};\n"
- "    ///  use std::rc::Rc;\n    "
- "    ///\n    "
- ///
- "  let mut set: HashSet<Rc<String"
- "<Rc<String>> = HashSet::new();\n"
- "    "
- ///
- "  let key_one = Rc::new(\""
- " = Rc::new(\"Stringthing\"."
- "(\"Stringthing\".to_string());\n"
- "    "
- ///
- "  let key_two = Rc::new(\""
- " = Rc::new(\"Stringthing\"."
- "(\"Stringthing\".to_string());\n"
- "    ///\n    "
- ///
- "/  set.insert(key_one.clone());\n"
- "    "
- ///
- "  assert!("
- "Rc::strong_count(&key_one) == 2 "
- "(&key_one) == 2 && Rc::"
- ") == 2 && Rc::strong_count(&"
- "::strong_count(&key_two) == 1);\n"
- "    ///\n    "
- ///
- "  match set.entry(key_two.clone("
- "(key_two.clone()) {\n    "
- ///
- "      Entry::Occupied(entry) => "
- "(entry) => {\n    "
- ///
- "          let old_key: Rc<String"
- ": Rc<String> = entry.replace();\n"
- "    "
- ///
- "          assert!("
- "Rc::ptr_eq(&key_one, &old_key));"
- ", &old_key));\n    ///      }\n"
- "///      }\n    "
- ///
- "      Entry::Vacant(_) => panic!"
- "(_) => panic!(),\n    ///  }\n    "
- "///  }\n    ///\n    "
- ///
- "  assert!("
- "Rc::strong_count(&key_one) == 1 "
- "(&key_one) == 1 && Rc::"
- ") == 1 && Rc::strong_count(&"
- "::strong_count(&key_two) == 2);\n"
- "    "
- ///
- "  assert!("
- "set.contains(&\"Stringthing\"."
- "(&\"Stringthing\".to_owned()));\n"
- "    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn replace(self) -> T "
- "{\n        "
- "self.inner.replace_key()\n    }\n}"
- "}\n\n"
- "impl<'a, T, S, A: Allocator> "
- " VacantEntry<'a, T, S, A> "
- "{\n    "
- ///
- " Gets a reference to the value "
- " to the value that would be used"
- " would be used when inserting\n"
- "    "
- "/// through the `VacantEntry`.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    ///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    "
- ///
- " assert_eq!("
- "set.entry(\"poneyland\").get(), &\""
- "\").get(), &\"poneyland\");\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn get(&self) -> &T "
- "{\n        self.inner.key()\n    }"
- "\n\n    "
- ///
- "/ Take ownership of the value.\n"
- "    ///\n    /// # Examples\n    "
- "    ///\n    /// ```\n    "
- ///
- " use hashbrown::hash_set::{Entry"
- "hash_set::{Entry, HashSet};\n    "
- "///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    ///\n    "
- ///
- " match set.entry(\"poneyland\") {\n"
- "    "
- ///
- "     Entry::Occupied(_) => panic"
- "(_) => panic!(),\n    "
- ///
- "     Entry::Vacant(v) => "
- "::Vacant(v) => assert_eq!("
- "v.into_value(), \"poneyland\"),\n"
- "    /// }\n    /// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn into_value(self) -> T "
- "{\n        self.inner.into_key()"
- "\n    }\n\n    "
- ///
- " Sets the value of the entry "
- " of the entry with the "
- " entry with the VacantEntry's "
- " VacantEntry's value.\n    ///\n"
- "///\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n    "
- "    /// use hashbrown::HashSet;\n"
- "    "
- ///
- " use hashbrown::hash_set::Entry;"
- "hash_set::Entry;\n    ///\n    "
- ///
- " let mut set: HashSet<&str> = "
- "HashSet<&str> = HashSet::new();\n"
- "    ///\n    "
- ///
- " if let Entry::Vacant(o) = "
- "::Vacant(o) = set.entry(\""
- "o) = set.entry(\"poneyland\") {\n"
- "    ///     o.insert();\n    "
- "    /// }\n    "
- ///
- " assert!("
- "set.contains(\"poneyland\"));\n    "
- "/// ```\n    "
- "#["
- cfg_attr
- "(feature = \"inline-more\", inline"
- ", inline)]\n    "
- "pub fn insert(self) -> "
- " -> OccupiedEntry<'a, T, S, A>"
- "\n    "
- "where\n        T: Hash,\n        "
- ",\n        S: BuildHasher,\n    "
- "{\n        "
- "OccupiedEntry "
- "{\n            "
- "inner: "
- ": self.inner.insert_entry(()),"
- ",\n        }\n    }\n}\n\n"
- "#[allow(dead_code)]\n"
- "fn assert_covariance() "
- "{\n    "
- "fn set<'new>"
- "<'new>(v: HashSet<&'static str>)"
- " -> HashSet<&'new str> "
- " {\n        v\n    }\n    "
- "fn iter<'a, 'new>"
- "(v: Iter<'a, &'static str>) -> "
- " -> Iter<'a, &'new str> "
- " {\n        v\n    }\n    "
- "fn into_iter<'new, A: Allocator>"
- "(v: IntoIter<&'static str, A>) "
- " -> IntoIter<&'new str, A> "
- " {\n        v\n    }\n    "
- fn difference
- "<'a, 'new, A: Allocator>"
- "(\n        "
- "v: "
- Difference
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n    ) -> "
- Difference
- "<'a, &'new str, "
- ", &'new str, DefaultHashBuilder,"
- ", A> {\n        v\n    }\n    "
- fn symmetric_difference
- "<'a, 'new, A: Allocator>"
- "(\n        "
- "v: "
- SymmetricDifference
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n    ) -> "
- SymmetricDifference
- "<'a, &'new str, "
- ", &'new str, DefaultHashBuilder,"
- ", A> {\n        v\n    }\n    "
- fn intersection
- "<'a, 'new, A: Allocator>"
- "(\n        "
- "v: "
- Intersection
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n    ) -> "
- Intersection
- "<'a, &'new str, "
- ", &'new str, DefaultHashBuilder,"
- ", A> {\n        v\n    }\n    "
- "fn union<'a, 'new, A: Allocator>"
- "(\n        "
- "v: "
- Union
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n    ) -> "
- Union
- "<'a, &'new str, "
- ", &'new str, DefaultHashBuilder,"
- ", A> {\n        v\n    }\n    "
- "fn drain<'new, A: Allocator>"
- (
- "d: "
- " Drain<'static, &'static str, A>"
- ") -> Drain<'new, &'new str, A> "
- " {\n        d\n    }\n}\n\n"
- "#[cfg(test)]\n"
- "mod test_set "
- "{\n    "
- "use "
- "super::super::map::"
- "::DefaultHashBuilder;\n    "
- "use super::HashSet;\n    "
- "\n    use std::vec::Vec;\n\n    "
- "\n\n    #[test]\n    "
- "fn test_zero_capacities() "
- "{\n        "
- "\n        type HS = HashSet<i32>;"
- "\n\n        let s = HS::new();"
- "\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n\n        let s = HS::default();"
- "\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n\n        "
- "let s = "
- "HS::with_hasher"
- "(DefaultHashBuilder::default());"
- ";\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n\n        "
- "let s = HS::with_capacity(0);"
- "\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n\n        "
- "let s = "
- "HS::with_capacity_and_hasher"
- "(0, "
- "0, DefaultHashBuilder::default()"
- ");\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n\n        let mut s = HS::new();"
- "\n        s.insert(1);\n        "
- "\n        s.insert(2);\n        "
- "\n        s.remove(&1);\n        "
- "\n        s.remove(&2);\n        "
- "\n        s.shrink_to_fit();"
- "\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n\n        let mut s = HS::new();"
- "\n        s.reserve(0);\n        "
- "assert_eq!(s.capacity(), 0);"
- "\n    }\n\n    #[test]\n    "
- "fn test_disjoint() "
- "{\n        "
- "let mut xs = HashSet::new();"
- "\n        "
- "let mut ys = HashSet::new();"
- "\n        "
- assert!(xs.is_disjoint(&ys));
- "\n        "
- assert!(ys.is_disjoint(&xs));
- "\n        assert!(xs.insert(5));"
- "\n        assert!(ys.insert(11));"
- "\n        "
- assert!(xs.is_disjoint(&ys));
- "\n        "
- assert!(ys.is_disjoint(&xs));
- "\n        assert!(xs.insert(7));"
- "\n        assert!(xs.insert(19));"
- "\n        assert!(xs.insert(4));"
- "\n        assert!(ys.insert(2));"
- "\n        "
- assert!(ys.insert(-11));
- "\n        "
- assert!(xs.is_disjoint(&ys));
- "\n        "
- assert!(ys.is_disjoint(&xs));
- "\n        assert!(ys.insert(7));"
- "\n        "
- assert!(!xs.is_disjoint(&ys));
- "\n        "
- assert!(!ys.is_disjoint(&xs));
- "\n    }\n\n    #[test]\n    "
- "fn test_subset_and_superset() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        assert!(a.insert(0));"
- "\n        assert!(a.insert(5));"
- "\n        assert!(a.insert(11));"
- "\n        assert!(a.insert(7));"
- "\n\n        "
- "let mut b = HashSet::new();"
- "\n        assert!(b.insert(0));"
- "\n        assert!(b.insert(7));"
- "\n        assert!(b.insert(19));"
- "\n        assert!(b.insert(250));"
- "\n        assert!(b.insert(11));"
- "\n        assert!(b.insert(200));"
- "\n\n        "
- assert!(!a.is_subset(&b));
- "\n        "
- assert!(!a.is_superset(&b));
- "\n        "
- assert!(!b.is_subset(&a));
- "\n        "
- assert!(!b.is_superset(&a));
- "\n\n        assert!(b.insert(5));"
- "\n\n        "
- assert!(a.is_subset(&b));
- "\n        "
- assert!(!a.is_superset(&b));
- "\n        "
- assert!(!b.is_subset(&a));
- "\n        "
- "assert!(b.is_superset(&a));\n    "
- "\n    }\n\n    #[test]\n    "
- "fn test_iterate() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        "
- "for i in 0..32 "
- "{\n            "
- "assert!(a.insert(i));\n        }"
- "\n        }\n        "
- "let mut observed: u32 = 0;"
- "\n        "
- "for k in &a "
- "{\n            "
- "observed |= 1 << *k;\n        }"
- "\n        }\n        "
- assert_eq!
- "!(observed, 0xFFFF_FFFF);\n    }"
- "}\n\n    #[test]\n    "
- "fn test_intersection() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        "
- "let mut b = HashSet::new();"
- "\n\n        assert!(a.insert(11));"
- "\n        assert!(a.insert(1));"
- "\n        assert!(a.insert(3));"
- "\n        assert!(a.insert(77));"
- "\n        assert!(a.insert(103));"
- "\n        assert!(a.insert(5));"
- "\n        assert!(a.insert(-5));"
- "\n\n        assert!(b.insert(2));"
- "\n        assert!(b.insert(11));"
- "\n        assert!(b.insert(77));"
- "\n        assert!(b.insert(-9));"
- "\n        assert!(b.insert(-42));"
- "\n        assert!(b.insert(5));"
- "\n        assert!(b.insert(3));"
- "\n\n        let mut i = 0;"
- "let mut i = 0;\n        "
- "let expected = [3, 5, 11, 77];"
- "\n        "
- "for x in a.intersection(&b) "
- "{\n            "
- assert!(expected.contains(x));
- "\n            i += 1;\n        }"
- "\n        }\n        "
- "assert_eq!(i, expected.len());"
- "\n    }\n\n    #[test]\n    "
- "fn test_difference() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        "
- "let mut b = HashSet::new();"
- "\n\n        assert!(a.insert(1));"
- "\n        assert!(a.insert(3));"
- "\n        assert!(a.insert(5));"
- "\n        assert!(a.insert(9));"
- "\n        assert!(a.insert(11));"
- "\n\n        assert!(b.insert(3));"
- "\n        assert!(b.insert(9));"
- "\n\n        let mut i = 0;"
- "let mut i = 0;\n        "
- "let expected = [1, 5, 11];"
- "\n        "
- "for x in a.difference(&b) "
- "{\n            "
- assert!(expected.contains(x));
- "\n            i += 1;\n        }"
- "\n        }\n        "
- "assert_eq!(i, expected.len());"
- "\n    }\n\n    #[test]\n    "
- "fn test_symmetric_difference() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        "
- "let mut b = HashSet::new();"
- "\n\n        assert!(a.insert(1));"
- "\n        assert!(a.insert(3));"
- "\n        assert!(a.insert(5));"
- "\n        assert!(a.insert(9));"
- "\n        assert!(a.insert(11));"
- "\n\n        assert!(b.insert(-2));"
- "\n        assert!(b.insert(3));"
- "\n        assert!(b.insert(9));"
- "\n        assert!(b.insert(14));"
- "\n        assert!(b.insert(22));"
- "\n\n        let mut i = 0;"
- "let mut i = 0;\n        "
- "let expected = "
- " = [-2, 1, 5, 11, 14, 22];"
- ";\n        "
- "for x in "
- " x in a.symmetric_difference(&b)"
- " "
- "{\n            "
- assert!(expected.contains(x));
- "\n            i += 1;\n        }"
- "\n        }\n        "
- "assert_eq!(i, expected.len());"
- "\n    }\n\n    #[test]\n    "
- "fn test_union() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        "
- "let mut b = HashSet::new();"
- "\n\n        assert!(a.insert(1));"
- "\n        assert!(a.insert(3));"
- "\n        assert!(a.insert(5));"
- "\n        assert!(a.insert(9));"
- "\n        assert!(a.insert(11));"
- "\n        assert!(a.insert(16));"
- "\n        assert!(a.insert(19));"
- "\n        assert!(a.insert(24));"
- "\n\n        assert!(b.insert(-2));"
- "\n        assert!(b.insert(1));"
- "\n        assert!(b.insert(5));"
- "\n        assert!(b.insert(9));"
- "\n        assert!(b.insert(13));"
- "\n        assert!(b.insert(19));"
- "\n\n        let mut i = 0;"
- "let mut i = 0;\n        "
- "let expected = "
- "[-2, 1, 3, 5, 9, 11, 13, 16, 19,"
- " 11, 13, 16, 19, 24];\n        "
- "for x in a.union(&b) "
- "{\n            "
- assert!(expected.contains(x));
- "\n            i += 1;\n        }"
- "\n        }\n        "
- "assert_eq!(i, expected.len());"
- "\n    }\n\n    #[test]\n    "
- "fn test_from_map() "
- "{\n        "
- "let mut a = "
- " mut a = crate::HashMap::new();"
- ";\n        a.insert(1, ());"
- "a.insert(1, ());\n        "
- "\n        a.insert(2, ());"
- "a.insert(2, ());\n        "
- "\n        a.insert(3, ());"
- "a.insert(3, ());\n        "
- "\n        a.insert(4, ());"
- "a.insert(4, ());\n\n        "
- "let a: HashSet<_> = a.into();"
- "\n\n        "
- "assert_eq!(a.len(), 4);\n        "
- assert!(a.contains(&1));
- "\n        "
- assert!(a.contains(&2));
- "\n        "
- assert!(a.contains(&3));
- "\n        "
- "assert!(a.contains(&4));\n    }"
- "\n    }\n\n    #[test]\n    "
- "fn test_from_iter() "
- "{\n        "
- "let xs = "
- "= [1, 2, 2, 3, 4, 5, 6, 7, 8, 9]"
- ";\n\n        "
- "let set: HashSet<_> = "
- " = xs.iter().copied().collect();"
- ";\n\n        "
- "for x in &xs "
- "{\n            "
- assert!(set.contains(x));
- "\n        }\n\n        "
- assert_eq!
- "(set.iter().len(), xs.len() - 1)"
- ";\n    }\n\n    #[test]\n    "
- "fn test_move_iter() "
- "{\n        "
- "let hs = "
- "{\n            "
- "let mut hs = HashSet::new();"
- "\n\n            hs.insert('a');"
- "hs.insert('a');\n            "
- "\n            hs.insert('b');"
- "hs.insert('b');\n\n            hs"
- "\n\n            hs\n        };"
- ";\n\n        "
- "let v = "
- "hs.into_iter().collect::"
- "::<Vec<char>>();\n        "
- assert!
- "(v == ['a', 'b'] || v == "
- " || v == ['b', 'a']);\n    }"
- "}\n\n    #[test]\n    "
- "fn test_eq() "
- "{\n        "
- //
- " These constants once happened "
- " once happened to expose a bug "
- "to expose a bug in insert().\n"
- "        "
- //
- " I'm keeping them around to "
- " them around to prevent a "
- " to prevent a regression.\n"
- "        "
- "let mut s1 = HashSet::new();"
- "\n\n        s1.insert(1);\n        "
- "\n        s1.insert(2);\n        "
- "\n        s1.insert(3);\n\n        "
- "let mut s2 = HashSet::new();"
- "\n\n        s2.insert(1);\n        "
- "\n        s2.insert(2);\n\n        "
- "\n\n        assert!(s1 != s2);"
- "\n\n        s2.insert(3);"
- "s2.insert(3);\n\n        "
- "\n\n        assert_eq!(s1, s2);"
- "\n    }\n\n    #[test]\n    "
- "fn test_show() "
- "{\n        "
- "let mut set = HashSet::new();"
- "\n        "
- "let empty = "
- " empty = HashSet::<i32>::new();"
- ";\n\n        set.insert(1);"
- "set.insert(1);\n        "
- "\n        set.insert(2);"
- "set.insert(2);\n\n        "
- "let set_str = format!(\"{set:?}\")"
- ";\n\n        "
- assert!
- "(set_str == \"{1, 2}\" || set_str "
- " || set_str == \"{2, 1}\");"
- ";\n        "
- assert_eq!
- "!(format!(\"{empty:?}\"), \"{}\");"
- ";\n    }\n\n    #[test]\n    "
- "fn test_trivial_drain() "
- "{\n        "
- "let mut s = "
- " mut s = HashSet::<i32>::new();"
- ";\n        for _ in s.drain() {}"
- "\n        assert!(s.is_empty());"
- "\n        drop(s);\n\n        "
- "let mut s = "
- " mut s = HashSet::<i32>::new();"
- ";\n        drop(s.drain());"
- "drop(s.drain());\n        "
- "\n        assert!(s.is_empty());"
- "\n    }\n\n    #[test]\n    "
- "fn test_drain() "
- "{\n        "
- "let mut s: HashSet<_> = "
- " HashSet<_> = (1..100).collect()"
- ";\n\n        "
- //
- " try this a bunch of times to "
- " of times to make sure we don't "
- " sure we don't screw up internal"
- " up internal state.\n        "
- "for _ in 0..20 "
- "{\n            "
- "assert_eq!(s.len(), 99);"
- "\n\n            "
- "{\n                "
- let mut last_i = 0;
- "\n                "
- let mut d = s.drain();
- "\n                "
- "for (i, x) in "
- " d.by_ref().take(50).enumerate()"
- " "
- "{\n                    "
- "last_i = i;\n                    "
- assert!(x != 0);
- "\n                }"
- "}\n                "
- "assert_eq!(last_i, 49);"
- "\n            }\n\n            "
- "if !s.is_empty() "
- "{\n                "
- "panic!(\"s should be empty!\");"
- "\n            }\n\n            "
- // reset to try again.
- "\n            s.extend(1..100);"
- "\n        }\n    }\n\n    #[test]"
- "#[test]\n    "
- "fn test_replace() "
- "{\n        use core::hash;"
- "use core::hash;\n\n        "
- "\n\n        #[derive(Debug)]"
- "#[derive(Debug)]\n        "
- "\n        #[allow(dead_code)]"
- "\n        "
- "struct Foo(&'static str, i32);"
- "\n\n        "
- "impl PartialEq for Foo "
- "{\n            "
- "fn eq(&self, other: &Self) -> "
- " -> bool "
- "{\n                "
- "self.0 == other.0\n            }"
- "\n            }\n        }"
- "}\n\n        impl Eq for Foo {}"
- "\n\n        "
- "impl hash::Hash for Foo "
- "{\n            "
- "fn hash<H: hash::Hasher>"
- "(&self, h: &mut H) "
- "{\n                "
- "self.0.hash(h);\n            }"
- "\n            }\n        }"
- "}\n\n        "
- "let mut s = HashSet::new();"
- "\n        "
- assert_eq!
- "!(s.replace(Foo(\"a\", 1)), None);"
- ";\n        "
- "assert_eq!(s.len(), 1);\n        "
- assert_eq!
- "(s.replace(Foo(\"a\", 2)), Some"
- ", Some(Foo(\"a\", 1)));\n        "
- "assert_eq!(s.len(), 1);"
- "\n\n        let mut it = s.iter();"
- "\n        "
- assert_eq!
- "!(it.next(), Some(&Foo(\"a\", 2)))"
- ";\n        "
- "assert_eq!(it.next(), None);"
- "\n    }\n\n    #[test]\n    "
- "#[allow(clippy::needless_borrow)"
- "]\n    "
- "fn test_extend_ref() "
- "{\n        "
- "let mut a = HashSet::new();"
- "\n        a.insert(1);\n\n        "
- "\n\n        a.extend([2, 3, 4]);"
- "\n\n        "
- "assert_eq!(a.len(), 4);\n        "
- assert!(a.contains(&1));
- "\n        "
- assert!(a.contains(&2));
- "\n        "
- assert!(a.contains(&3));
- "\n        "
- assert!(a.contains(&4));
- "\n\n        "
- "let mut b = HashSet::new();"
- "\n        b.insert(5);\n        "
- "\n        b.insert(6);\n\n        "
- "\n\n        a.extend(&b);"
- "a.extend(&b);\n\n        "
- "assert_eq!(a.len(), 6);\n        "
- assert!(a.contains(&1));
- "\n        "
- assert!(a.contains(&2));
- "\n        "
- assert!(a.contains(&3));
- "\n        "
- assert!(a.contains(&4));
- "\n        "
- assert!(a.contains(&5));
- "\n        "
- "assert!(a.contains(&6));\n    }"
- "\n    }\n\n    #[test]\n    "
- "fn test_retain() "
- "{\n        "
- "let xs = [1, 2, 3, 4, 5, 6];"
- "\n        "
- "let mut set: HashSet<i32> = "
- " = xs.iter().copied().collect();"
- ";\n        "
- set.retain(|&k| k % 2 == 0);
- "\n        "
- "assert_eq!(set.len(), 3);"
- "\n        "
- assert!(set.contains(&2));
- "\n        "
- assert!(set.contains(&4));
- "\n        "
- "assert!(set.contains(&6));\n    }"
- "\n    }\n\n    #[test]\n    "
- "fn test_extract_if() "
- "{\n        "
- "{\n            "
- "let mut set: HashSet<i32> = "
- " HashSet<i32> = (0..8).collect()"
- "(0..8).collect();\n            "
- "let drained = "
- " set.extract_if(|&k| k % 2 == 0)"
- ";\n            "
- "let mut out = "
- " = drained.collect::<Vec<_>>();"
- ";\n            "
- out.sort_unstable();
- "\n            "
- assert_eq!
- "!(vec![0, 2, 4, 6], out);"
- ";\n            "
- "assert_eq!(set.len(), 4);"
- "\n        }\n        "
- "{\n            "
- "let mut set: HashSet<i32> = "
- " HashSet<i32> = (0..8).collect()"
- "(0..8).collect();\n            "
- set.extract_if(|&k| k % 2 == 0).
- ".for_each(drop);\n            "
- assert_eq!
- "(set.len(), 4, "
- "\""
- "Removes non-matching items on "
- " items on drop\");\n        }\n    "
- "}\n\n    #[test]\n    "
- "fn test_const_with_hasher() "
- "{\n        "
- "use core::hash::BuildHasher;"
- "\n        "
- "use "
- "std::collections::hash_map::"
- "::DefaultHasher;\n\n        "
- "#[derive(Clone)]\n        "
- "\n        struct MyHasher;"
- "struct MyHasher;\n        "
- "impl BuildHasher for MyHasher "
- "{\n            "
- type Hasher = DefaultHasher;
- "\n\n            "
- "fn build_hasher(&self) -> "
- "(&self) -> DefaultHasher "
- "{\n                "
- "DefaultHasher::new()"
- "\n            }\n        }"
- "}\n\n        "
- "const EMPTY_SET: "
- ": HashSet<u32, MyHasher> = "
- "= HashSet::with_hasher(MyHasher)"
- ";\n\n        "
- let mut set = EMPTY_SET;
- "\n        set.insert(19);"
- "set.insert(19);\n        "
- "assert!(set.contains(&19));\n    "
- "\n    }\n\n    #[test]\n    "
- "fn rehash_in_place() "
- "{\n        "
- "let mut set = HashSet::new();"
- "\n\n        "
- "for i in 0..224 "
- "{\n            set.insert(i);"
- "set.insert(i);\n        }"
- "\n        }\n\n        "
- assert_eq!
- "(\n            set.capacity(),"
- "set.capacity(),\n            224,"
- "224,\n            "
- "\""
- "The set must be at or close to "
- " at or close to capacity to "
- " to capacity to trigger a re "
- "to trigger a re hashing\""
- "\"\n        );\n\n        "
- "for i in 100..1400 "
- "{\n            "
- set.remove(&(i - 100));
- "\n            set.insert(i);"
- "set.insert(i);\n        }\n    }"
- "}\n\n    #[test]\n    "
- "fn collect() "
- "{\n        "
- //
- " At the time of writing, this "
- " writing, this hits the ZST case"
- " the ZST case in from_base_index"
- " from_base_index\n        "
- //
- " (and without the `map`, it does"
- " `map`, it does not).\n        "
- "let mut _set: HashSet<_> = "
- " = (0..3).map(|_| ()).collect();"
- ";\n    }\n}\n"
