---
source: tests/snapshots.rs
expression: chunks
---
- //
- " https://github.com/rust-lang/"
- /rust-lang/hashbrown/blob/
- 1167d19935f79320d666bf8549f05322
- d666bf8549f053229567d778/src/
- "/src/rustc_entry.rs\n"
- "#[cfg(feature = \"raw\")]"
- "\nuse crate::raw::RawTable;\n"
- "use crate::{Equivalent, "
- "::{Equivalent, TryReserveError};"
- "};\nuse alloc::borrow::ToOwned;\n"
- "use core::fmt;\n"
- "use core::hash::{BuildHasher, "
- "::{BuildHasher, Hash};\n"
- "use core::iter::{Chain, "
- "::iter::{Chain, FusedIterator};\n"
- "use core::ops::{BitAnd, BitOr, "
- "{BitAnd, BitOr, BitXor, Sub};\n\n"
- "use super::map::{self, "
- "::map::{self, DefaultHashBuilder"
- ", HashMap, Keys};\n"
- "use crate::raw::{Allocator, "
- "::{Allocator, Global, "
- ", Global, RawExtractIf};\n\n"
- "// Future Optimization (FIXME!)\n"
- // =============================
- "================\n//\n"
- "// Iteration over zero sized "
- over zero sized values is a noop
- "values is a noop. "
- "There is no need\n"
- "// for `bucket.val` in the case "
- "` in the case of HashSet. "
- "I suppose we would need HKT\n"
- "// to get rid of it properly.\n\n"
- "/// A hash set implemented as a "
- " as a `HashMap` where the value "
- "where the value is `()`.\n///\n"
- "/// As with the [`HashMap`] type"
- "[`HashMap`] type, a `HashSet` "
- ", a `HashSet` requires that the "
- " that the elements\n"
- "/// implement the [`Eq`] and [`"
- " [`Eq`] and [`Hash`] traits. "
- "This can frequently be achieved "
- " be achieved by\n"
- "/// using `#[derive(PartialEq, "
- "(PartialEq, Eq, Hash)]`. "
- "If you implement these yourself,"
- " these yourself,\n"
- "/// it is important that the "
- " that the following property "
- " property holds:\n///\n"
- "///\n/// ```text\n"
- /// k1 == k2 -> hash(k1) == hash
- "hash(k1) == hash(k2)\n/// ```\n"
- "/// ```\n///\n"
- "/// In other words, if two keys "
- ", if two keys are equal, their "
- " equal, their hashes must be "
- " hashes must be equal.\n///\n///\n"
- "/// It is a logic error for an "
- " error for an item to be "
- " an item to be modified in such "
- " in such a way that the\n"
- "/// item's hash, as determined "
- ", as determined by the [`Hash`] "
- "by the [`Hash`] trait, or its "
- "] trait, or its equality, as\n"
- "/// determined by the [`Eq`] "
- " by the [`Eq`] trait, changes "
- " trait, changes while it is in "
- " while it is in the set. "
- "This is\n"
- "/// normally only possible "
- " only possible through [`Cell`],"
- " [`Cell`], [`RefCell`], global "
- "`], global state, I/O, or\n"
- "/// unsafe code.\n///\n"
- /// It is also a logic error for
- " logic error for the [`Hash`] "
- " the [`Hash`] implementation of "
- " of a key to panic.\n"
- "/// This is generally only "
- " generally only possible if the "
- "possible if the trait is "
- "if the trait is implemented "
- " is implemented manually. If a\n"
- "/// panic does occur then the "
- " occur then the contents of the "
- "contents of the `HashSet` may "
- " `HashSet` may become corrupted "
- " corrupted and\n"
- "/// some items may be dropped "
- " may be dropped from the table.\n"
- "///\n/// # Examples\n///\n/// ```\n"
- "/// use hashbrown::HashSet;\n"
- "/// // Type inference lets us "
- " lets us omit an explicit type "
- " explicit type signature (which\n"
- "/// // would be `HashSet<String>"
- "`HashSet<String>` in this "
- ">` in this example).\n"
- "/// let mut books = HashSet::new"
- " = HashSet::new();\n///\n"
- "///\n/// // Add some books.\n"
- "/// books.insert(\"A Dance With "
- "(\"A Dance With Dragons\"."
- " With Dragons\".to_string());\n"
- "/// books.insert(\"To Kill a "
- "(\"To Kill a Mockingbird\"."
- " a Mockingbird\".to_string());\n"
- "/// books.insert(\"The Odyssey\"."
- "(\"The Odyssey\".to_string());\n"
- "/// books.insert(\"The Great "
- "(\"The Great Gatsby\".to_string())"
- "\".to_string());\n///\n"
- /// // Check for a specific one.
- " a specific one.\n/// if !"
- "books.contains(\"The Winds of "
- "(\"The Winds of Winter\") {\n"
- "///     println!(\""
- "We have {} books, but The Winds "
- ", but The Winds of Winter ain't "
- "of Winter ain't one.\",\n"
- "///              books.len());\n"
- "/// }\n///\n/// // Remove a book.\n"
- "/// books.remove(\"The Odyssey\");"
- "(\"The Odyssey\");\n///\n"
- "/// // Iterate over everything.\n"
- "/// for book in &books {\n"
- "///     println!(\"{}\", book);\n"
- "/// }\n/// ```\n///\n"
- "/// The easiest way to use `"
- " way to use `HashSet` with a "
- "HashSet` with a custom type is "
- " custom type is to derive\n"
- "/// [`Eq`] and [`Hash`]. "
- "We must also derive [`PartialEq`"
- " [`PartialEq`]. "
- "This will in the\n"
- "/// future be implied by [`Eq`]."
- " by [`Eq`].\n///\n/// ```\n"
- "/// use hashbrown::HashSet;\n"
- "/// #[derive(Hash, Eq, PartialEq"
- ", Eq, PartialEq, Debug)]\n"
- "/// struct Viking {\n"
- "///     name: String,\n"
- "///     power: usize,\n/// }\n///\n"
- "/// let mut vikings = HashSet::"
- " = HashSet::new();\n///\n"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Einar\"."
- "{ name: \"Einar\".to_string(), "
- "\".to_string(), power: 9 });\n"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Einar\"."
- "{ name: \"Einar\".to_string(), "
- "\".to_string(), power: 9 });\n"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Olaf\".to_string"
- "\"Olaf\".to_string(), power: 4 });"
- "(), power: 4 });\n"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Harald\"."
- " name: \"Harald\".to_string(), "
- "\".to_string(), power: 8 });\n///\n"
- "/// // Use derived "
- " // Use derived implementation "
- " implementation to print the "
- " to print the vikings.\n"
- "/// for x in &vikings {\n"
- "///     println!(\"{:?}\", x);\n"
- "/// }\n/// ```\n///\n"
- "/// A `HashSet` with fixed list "
- "with fixed list of elements can "
- "of elements can be initialized "
- " be initialized from an array:\n"
- "///\n/// ```\n"
- "/// use hashbrown::HashSet;\n///\n"
- "/// let viking_names: HashSet<&'"
- ": HashSet<&'static str> =\n"
- "///     [ \"Einar\", \"Olaf\", \""
- "\", \"Olaf\", \"Harald\" ].into_iter("
- "\" ].into_iter().collect();\n"
- "/// // use the values stored in "
- " stored in the set\n/// ```\n///\n"
- "/// [`Cell`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cell/"
- "/std/cell/struct.Cell.html\n"
- "/// [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- "/std/cmp/trait.Eq.html\n"
- "/// [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n"
- "/// [`HashMap`]: "
- "[`HashMap`]: struct.HashMap.html"
- "\n"
- "/// [`PartialEq`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/cmp/"
- "/std/cmp/trait.PartialEq.html\n"
- "/// [`RefCell`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/cell/"
- "/std/cell/struct.RefCell.html\n"
- "pub struct HashSet<T, S = "
- "<T, S = DefaultHashBuilder, A: "
- ", A: Allocator = Global> {\n"
- "    pub(crate) map: HashMap<T, ("
- ": HashMap<T, (), S, A>,\n}\n\n"
- "impl<T: Clone, S: Clone, A: "
- ", S: Clone, A: Allocator + Clone"
- " + Clone> Clone for HashSet<T, S"
- "for HashSet<T, S, A> {\n"
- "    fn clone(&self) -> Self {\n"
- "        HashSet {\n"
- "            map: self.map.clone("
- " self.map.clone(),\n        }\n"
- "        }\n    }\n\n"
- "    fn clone_from(&mut self, "
- "(&mut self, source: &Self) {\n"
- "        self.map.clone_from(&"
- "(&source.map);\n    }\n}\n\n"
- "}\n\n#[cfg(feature = \"ahash\")]\n"
- "impl<T> HashSet<T, "
- "T> HashSet<T, DefaultHashBuilder"
- "> {\n"
- "    /// Creates an empty `"
- " an empty `HashSet`.\n    ///\n"
- "    /// The hash set is "
- "The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not "
- " so it will not allocate until "
- " allocate until it\n"
- "    /// is first inserted into.\n"
- "    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    /// [`with_hasher`](HashSet:"
- "`](HashSet::with_hasher) method."
- ") method.\n    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = "
- " HashSet<i32> = HashSet::new();\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn new() -> Self {\n"
- "        Self {\n"
- "            map: HashMap::new(),"
- " HashMap::new(),\n        }\n"
- "        }\n    }\n\n"
- "    /// Creates an empty `"
- " an empty `HashSet` with the "
- "` with the specified capacity.\n"
- "    ///\n"
- "    /// The hash set will be "
- " set will be able to hold at "
- "able to hold at least `capacity`"
- "least `capacity` elements "
- "` elements without\n"
- "    /// reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    /// [`"
- "/// [`with_capacity_and_hasher`]"
- "`](HashSet::"
- "::with_capacity_and_hasher) "
- ") method.\n    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = "
- " HashSet<i32> = HashSet::"
- "i32> = HashSet::with_capacity(10"
- "with_capacity(10);\n"
- "    /// assert!("
- "set.capacity() >= 10);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn with_capacity("
- " with_capacity(capacity: usize) "
- ": usize) -> Self {\n"
- "        Self {\n"
- "            map: HashMap::"
- "map: HashMap::with_capacity("
- "::with_capacity(capacity),\n"
- "        }\n    }\n}\n\n"
- "}\n\n#[cfg(feature = \"ahash\")]\n"
- "impl<T: Hash + Eq, A: Allocator>"
- ", A: Allocator> HashSet<T, "
- "> HashSet<T, DefaultHashBuilder,"
- ", A> {\n"
- "    /// Creates an empty `"
- " an empty `HashSet`.\n    ///\n"
- "    /// The hash set is "
- "The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not "
- " so it will not allocate until "
- " allocate until it\n"
- "    /// is first inserted into.\n"
- "    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    /// [`with_hasher_in`]("
- "`](HashSet::with_hasher_in) "
- "with_hasher_in) method.\n    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = "
- " HashSet<i32> = HashSet::new();\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn new_in(alloc: A) -> "
- "(alloc: A) -> Self {\n"
- "        Self {\n"
- "            map: HashMap::new_in"
- " HashMap::new_in(alloc),\n"
- "        }\n    }\n\n"
- "    /// Creates an empty `"
- " an empty `HashSet` with the "
- "` with the specified capacity.\n"
- "    ///\n"
- "    /// The hash set will be "
- " set will be able to hold at "
- "able to hold at least `capacity`"
- "least `capacity` elements "
- "` elements without\n"
- "    /// reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`], for "
- "`HashSet`], for example with\n"
- "    /// [`"
- "// [`with_capacity_and_hasher_in"
- "`](HashSet::"
- "::with_capacity_and_hasher_in) "
- ") method.\n    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = "
- " HashSet<i32> = HashSet::"
- "i32> = HashSet::with_capacity(10"
- "with_capacity(10);\n"
- "    /// assert!("
- "set.capacity() >= 10);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn with_capacity_in("
- "(capacity: usize, alloc: A) -> "
- ", alloc: A) -> Self {\n"
- "        Self {\n"
- "            map: HashMap::"
- "map: HashMap::with_capacity_in("
- "(capacity, alloc),\n        }\n"
- "        }\n    }\n}\n\n"
- "impl<T, S, A: Allocator> HashSet"
- "> HashSet<T, S, A> {\n"
- "    /// Returns the number of "
- " the number of elements the set "
- " the set can hold without "
- " hold without reallocating.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let set: HashSet<i32> = "
- " HashSet<i32> = HashSet::"
- "i32> = HashSet::with_capacity("
- "::with_capacity(100);\n"
- "    /// assert!("
- "set.capacity() >= 100);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn capacity(&self) -> "
- "(&self) -> usize {\n"
- "        self.map.capacity()\n"
- "    }\n\n"
- "    /// An iterator visiting all"
- " visiting all elements in "
- all elements in arbitrary order.
- "arbitrary order.\n"
- "    /// The iterator element "
- " element type is `&'a T`.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n"
- "    /// set.insert(\"a\");\n"
- "    /// set.insert(\"b\");\n"
- "    ///\n"
- "    /// // Will print in an "
- " print in an arbitrary order.\n"
- "    /// for x in set.iter() {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn iter(&self) -> Iter<'"
- "&self) -> Iter<'_, T> {\n"
- "        Iter {\n"
- "            iter: self.map.keys("
- ": self.map.keys(),\n        }\n"
- "        }\n    }\n\n"
- "    /// Returns the number of "
- " the number of elements in the "
- "elements in the set.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut v = HashSet::new"
- "v = HashSet::new();\n"
- "    /// assert_eq!(v.len(), 0);\n"
- "    /// v.insert(1);\n"
- "    /// assert_eq!(v.len(), 1);\n"
- "v.len(), 1);\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn len(&self) -> usize {"
- "self) -> usize {\n"
- "        self.map.len()\n    }\n\n"
- "    /// Returns `true` if the "
- " `true` if the set contains no "
- "set contains no elements.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut v = HashSet::new"
- "v = HashSet::new();\n"
- "    /// assert!(v.is_empty());\n"
- "    /// v.insert(1);\n"
- "    /// assert!(!v.is_empty());\n"
- "v.is_empty());\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn is_empty(&self) -> "
- "(&self) -> bool {\n"
- "        self.map.is_empty()\n"
- "    }\n\n"
- "    /// Clears the set, "
- "Clears the set, returning all "
- ", returning all elements in an "
- " elements in an iterator.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<_> "
- "set: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// assert!(!"
- "set.is_empty());\n    ///\n"
- "    /// // print 1, 2, 3 in an "
- " 1, 2, 3 in an arbitrary order\n"
- "    /// for i in set.drain() {\n"
- "    ///     println!(\"{}\", i);\n"
- "    /// }\n    ///\n"
- "    ///\n    /// assert!("
- "set.is_empty());\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn drain(&mut self) -> "
- "(&mut self) -> Drain<'_, T, A> {"
- "<'_, T, A> {\n        Drain {\n"
- "            iter: self.map.drain"
- ": self.map.drain(),\n        }\n"
- "        }\n    }\n\n"
- "    /// Retains only the "
- " only the elements specified by "
- " specified by the predicate.\n"
- "    ///\n"
- "    /// In other words, remove "
- " words, remove all elements `e` "
- " elements `e` such that `f(&e)` "
- " that `f(&e)` returns `false`.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let xs = [1,2,3,4,5,6];\n"
- "    /// let mut set: HashSet<i32"
- "set: HashSet<i32> = xs.into_iter"
- "> = xs.into_iter().collect();\n"
- "    /// set.retain(|&k| k % 2 =="
- "(|&k| k % 2 == 0);\n"
- "    /// assert_eq!("
- "set.len(), 3);\n    /// ```\n"
- "    pub fn retain<F>(&mut self, "
- "<F>(&mut self, mut f: F)\n"
- "    where\n"
- "        F: FnMut(&T) -> bool,\n"
- "    {\n"
- "        self.map.retain(|k, _| f"
- "(|k, _| f(k));\n    }\n\n"
- "    /// Drains elements which "
- " elements which are true under "
- " are true under the given "
- "under the given predicate,\n"
- "    /// and returns an iterator "
- " an iterator over the removed "
- " the removed items.\n    ///\n"
- "    /// In other words, move all"
- " words, move all elements `e` "
- " elements `e` such that `f(&e)` "
- " that `f(&e)` returns `true` out"
- " `true` out\n"
- "    /// into another iterator.\n"
- "    ///\n"
- "    /// If the returned `"
- " the returned `ExtractIf` is not"
- "` is not exhausted, e.g. because"
- ", e.g. because it is dropped "
- " it is dropped without iterating"
- " iterating\n"
- "    /// or the iteration short-"
- "iteration short-circuits, then "
- "-circuits, then the remaining "
- " the remaining elements will be "
- " will be retained.\n"
- "    /// Use [`retain()`] with a "
- "()`] with a negated predicate if"
- " predicate if you do not need "
- "you do not need the returned "
- " the returned iterator.\n    ///\n"
- "    /// [`retain()`]: HashSet::"
- "()`]: HashSet::retain\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<i32"
- "set: HashSet<i32> = (0..8)."
- "<i32> = (0..8).collect();\n"
- "    /// let drained: HashSet<i32"
- ": HashSet<i32> = set.extract_if("
- " set.extract_if(|v| v % 2 == 0)."
- "|v| v % 2 == 0).collect();\n"
- "    ///\n"
- "    /// let mut evens = "
- " mut evens = drained.into_iter()"
- "().collect::<Vec<_>>();\n"
- "    /// let mut odds = "
- " let mut odds = set.into_iter()."
- "set.into_iter().collect::<Vec<_>"
- "collect::<Vec<_>>();\n"
- "    /// evens.sort();\n"
- "    /// odds.sort();\n    ///\n"
- "    ///\n    /// assert_eq!("
- "evens, vec![0, 2, 4, 6]);\n"
- "    /// assert_eq!(odds, vec!["
- "odds, vec![1, 3, 5, 7]);\n"
- "1, 3, 5, 7]);\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn extract_if<F>(&mut "
- "<F>(&mut self, f: F) -> "
- " self, f: F) -> ExtractIf<'_, T,"
- "ExtractIf<'_, T, F, A>\n"
- "    where\n"
- "        F: FnMut(&T) -> bool,\n"
- "    {\n        ExtractIf {\n"
- "            f,\n"
- "            inner: RawExtractIf "
- ": RawExtractIf {\n"
- "                iter: unsafe { "
- ": unsafe { self.map.table.iter()"
- "() },\n"
- "                table: &mut "
- "table: &mut self.map.table,\n"
- "            },\n        }\n    }\n\n"
- "    /// Clears the set, removing"
- " set, removing all values.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut v = HashSet::new"
- "v = HashSet::new();\n"
- "    /// v.insert(1);\n"
- "    /// v.clear();\n"
- "    /// assert!(v.is_empty());\n"
- "v.is_empty());\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn clear(&mut self) {\n"
- "        self.map.clear();\n    }\n"
- "    }\n}\n\n"
- "impl<T, S> HashSet<T, S, Global>"
- "<T, S, Global> {\n"
- "    /// Creates a new empty hash"
- "a new empty hash set which will "
- " set which will use the given "
- " use the given hasher to hash\n"
- "    /// keys.\n    ///\n"
- "    /// The hash set is "
- "The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not\n"
- "    /// allocate until it is "
- " until it is first inserted into"
- " inserted into.\n    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`].\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` passed should "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n"
- "    /// the HashSet to be useful"
- " to be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n"
- "    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n"
- "    /// [`BuildHasher`]: https:/"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_map:"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n"
- "    /// let s = "
- "/// let s = DefaultHashBuilder::"
- "::default();\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::with_hasher(s);\n"
- "    /// set.insert(2);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub const fn with_hasher("
- " fn with_hasher(hasher: S) -> "
- "(hasher: S) -> Self {\n"
- "        Self {\n"
- "            map: HashMap::"
- "map: HashMap::with_hasher(hasher"
- "(hasher),\n        }\n    }\n\n"
- "    /// Creates an empty `"
- " an empty `HashSet` with the "
- "` with the specified capacity, "
- " capacity, using\n"
- "    /// `hasher` to hash the "
- "` to hash the keys.\n    ///\n"
- "    /// The hash set will be "
- " set will be able to hold at "
- "able to hold at least `capacity`"
- "least `capacity` elements "
- "` elements without\n"
- "    /// reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`].\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` passed should "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n"
- "    /// the HashSet to be useful"
- " to be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n"
- "    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n"
- "    /// [`BuildHasher`]: https:/"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_map:"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n"
- "    /// let s = "
- "/// let s = DefaultHashBuilder::"
- "::default();\n"
- "    /// let mut set = HashSet::"
- "::with_capacity_and_hasher(10, s"
- "(10, s);\n    /// set.insert(1);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn "
- pub fn with_capacity_and_hasher(
- "(capacity: usize, hasher: S) -> "
- ", hasher: S) -> Self {\n"
- "        Self {\n"
- "            map: HashMap::"
- "::with_capacity_and_hasher("
- "(capacity, hasher),\n        }\n"
- "        }\n    }\n}\n\n"
- "\nimpl<T, S, A> HashSet<T, S, A>\n"
- "where\n    A: Allocator,\n{\n"
- "    /// Returns a reference to "
- " a reference to the underlying "
- " the underlying allocator.\n"
- "    #[inline]\n"
- "    pub fn allocator(&self) -> &"
- "(&self) -> &A {\n"
- "        self.map.allocator()\n"
- "    }\n\n"
- "    /// Creates a new empty hash"
- "a new empty hash set which will "
- " set which will use the given "
- " use the given hasher to hash\n"
- "    /// keys.\n    ///\n"
- "    /// The hash set is "
- "The hash set is initially "
- " is initially created with a "
- " created with a capacity of 0, "
- " capacity of 0, so it will not\n"
- "    /// allocate until it is "
- " until it is first inserted into"
- " inserted into.\n    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`].\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` passed should "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n"
- "    /// the HashSet to be useful"
- " to be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n"
- "    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n"
- "    /// [`BuildHasher`]: https:/"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_map:"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n"
- "    /// let s = "
- "/// let s = DefaultHashBuilder::"
- "::default();\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::with_hasher(s);\n"
- "    /// set.insert(2);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub const fn with_hasher_in("
- " with_hasher_in(hasher: S, alloc"
- "hasher: S, alloc: A) -> Self {\n"
- "        Self {\n"
- "            map: HashMap::"
- "map: HashMap::with_hasher_in("
- ":with_hasher_in(hasher, alloc),\n"
- "        }\n    }\n\n"
- "    /// Creates an empty `"
- " an empty `HashSet` with the "
- "` with the specified capacity, "
- " capacity, using\n"
- "    /// `hasher` to hash the "
- "` to hash the keys.\n    ///\n"
- "    /// The hash set will be "
- " set will be able to hold at "
- "able to hold at least `capacity`"
- "least `capacity` elements "
- "` elements without\n"
- "    /// reallocating. "
- "If `capacity` is 0, the hash set"
- " 0, the hash set will not "
- " set will not allocate.\n    ///\n"
- "    /// # HashDoS resistance\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` normally use a "
- " normally use a fixed key by "
- " a fixed key by default and that"
- "default and that does\n"
- "    /// not allow the `HashSet` "
- " the `HashSet` to be protected "
- "to be protected against attacks "
- "against attacks such as [`"
- " such as [`HashDoS`].\n"
- "    /// Users who require "
- " who require HashDoS resistance "
- " resistance should explicitly "
- " explicitly use\n"
- "    /// [`ahash::RandomState`] "
- "::RandomState`] or [`std::"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]\n"
- "    /// as the hasher when "
- "the hasher when creating a [`"
- " creating a [`HashSet`].\n"
- "    ///\n"
- "    /// The `hash_builder` "
- " `hash_builder` passed should "
- "` passed should implement the [`"
- "implement the [`BuildHasher`] "
- "[`BuildHasher`] trait for\n"
- "    /// the HashSet to be useful"
- " to be useful, see its "
- "useful, see its documentation "
- " documentation for details.\n"
- "    ///\n"
- "    /// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- "/wiki/Collision_attack\n"
- "    /// [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "\n"
- "    /// [`BuildHasher`]: https:/"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_map:"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n"
- "    /// let s = "
- "/// let s = DefaultHashBuilder::"
- "::default();\n"
- "    /// let mut set = HashSet::"
- "::with_capacity_and_hasher(10, s"
- "(10, s);\n    /// set.insert(1);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn "
- " fn with_capacity_and_hasher_in("
- "(capacity: usize, hasher: S, "
- ", hasher: S, alloc: A) -> Self {"
- ": A) -> Self {\n        Self {\n"
- "            map: HashMap::"
- "::with_capacity_and_hasher_in("
- "(capacity, hasher, alloc),\n"
- "        }\n    }\n\n"
- "    /// Returns a reference to "
- " a reference to the set's [`"
- " to the set's [`BuildHasher`].\n"
- "    ///\n"
- "    /// [`BuildHasher`]: https:/"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_map:"
- "::hash_map::DefaultHashBuilder;\n"
- "    ///\n"
- "    /// let hasher = "
- " let hasher = DefaultHashBuilder"
- "::default();\n"
- "    /// let set: HashSet<i32> = "
- " HashSet<i32> = HashSet::"
- "i32> = HashSet::with_hasher("
- "::with_hasher(hasher);\n"
- "    /// let hasher: &"
- " let hasher: &DefaultHashBuilder"
- " = set.hasher();\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn hasher(&self) -> &S {"
- "(&self) -> &S {\n"
- "        self.map.hasher()\n    }\n"
- "    }\n}\n\n"
- "\nimpl<T, S, A> HashSet<T, S, A>\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    /// Reserves capacity for at"
- " capacity for at least `"
- " for at least `additional` more "
- "` more elements to be inserted\n"
- "    /// in the `HashSet`. "
- "The collection may reserve more "
- " reserve more space to avoid\n"
- "    /// frequent reallocations.\n"
- "    ///\n    /// # Panics\n"
- "    ///\n"
- "    /// Panics if the new "
- " if the new capacity exceeds [`"
- " exceeds [`isize::MAX`] bytes "
- "::MAX`] bytes and [`abort`] the "
- " [`abort`] the program\n"
- "    /// in case of allocation "
- " of allocation error. "
- "Use [`try_reserve`](HashSet::"
- "`](HashSet::try_reserve) instead"
- ") instead\n"
- "    /// if you want to handle "
- " want to handle memory "
- " handle memory allocation "
- " allocation failure.\n    ///\n"
- "    /// [`isize::MAX`]: https://"
- ":MAX`]: https://doc.rust-"
- "://doc.rust-lang.org/std/"
- "/std/primitive.isize.html\n"
- "    /// [`abort`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/alloc/alloc/"
- alloc/fn.handle_alloc_error.html
- "\n    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let mut set: HashSet<i32"
- "set: HashSet<i32> = HashSet::new"
- "> = HashSet::new();\n"
- "    /// set.reserve(10);\n"
- "    /// assert!("
- "set.capacity() >= 10);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn reserve(&mut self, "
- "(&mut self, additional: usize) {"
- ": usize) {\n"
- "        self.map.reserve("
- "(additional);\n    }\n\n"
- "    /// Tries to reserve "
- " to reserve capacity for at "
- "capacity for at least `"
- " for at least `additional` more "
- "` more elements to be inserted\n"
- "    /// in the given `HashSet<K,"
- " `HashSet<K,V>`. "
- "The collection may reserve more "
- " reserve more space to avoid\n"
- "    /// frequent reallocations.\n"
- "    ///\n    /// # Errors\n"
- "    ///\n"
- "    /// If the capacity "
- "If the capacity overflows, or "
- " overflows, or the allocator "
- " the allocator reports a failure"
- " a failure, then an error\n"
- "    /// is returned.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let mut set: HashSet<i32"
- "set: HashSet<i32> = HashSet::new"
- "> = HashSet::new();\n"
- "    /// set.try_reserve(10)."
- "(10).expect(\"why is the test "
- "why is the test harness OOMing "
- " harness OOMing on 10 bytes?\");\n"
- ";\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn try_reserve(&mut self"
- "(&mut self, additional: usize) -"
- ": usize) -> Result<(), "
- ") -> Result<(), TryReserveError>"
- "TryReserveError> {\n"
- "        self.map.try_reserve("
- "(additional)\n    }\n\n"
- "    /// Shrinks the capacity of "
- "the capacity of the set as much "
- "the set as much as possible. "
- "It will drop\n"
- "    /// down as much as possible"
- "much as possible while "
- " possible while maintaining the "
- "maintaining the internal rules\n"
- "    /// and possibly leaving "
- " leaving some space in "
- " some space in accordance with "
- "accordance with the resize "
- "with the resize policy.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::with_capacity("
- "::with_capacity(100);\n"
- "    /// set.insert(1);\n"
- "    /// set.insert(2);\n"
- "    /// assert!("
- "set.capacity() >= 100);\n"
- "    /// set.shrink_to_fit();\n"
- "    /// assert!("
- "set.capacity() >= 2);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn shrink_to_fit(&mut "
- "(&mut self) {\n"
- "        self.map.shrink_to_fit()"
- "();\n    }\n\n"
- "    /// Shrinks the capacity of "
- "the capacity of the set with a "
- " the set with a lower limit. "
- "It will drop\n"
- "    /// down no lower than the "
- " lower than the supplied limit "
- " supplied limit while "
- " limit while maintaining the "
- "maintaining the internal rules\n"
- "    /// and possibly leaving "
- " leaving some space in "
- " some space in accordance with "
- "accordance with the resize "
- "with the resize policy.\n    ///\n"
- "    /// Panics if the current "
- " if the current capacity is "
- " capacity is smaller than the "
- " than the supplied\n"
- "    /// minimum capacity.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::with_capacity("
- "::with_capacity(100);\n"
- "    /// set.insert(1);\n"
- "    /// set.insert(2);\n"
- "    /// assert!("
- "set.capacity() >= 100);\n"
- "    /// set.shrink_to(10);\n"
- "    /// assert!("
- "set.capacity() >= 10);\n"
- "    /// set.shrink_to(0);\n"
- "    /// assert!("
- "set.capacity() >= 2);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn shrink_to(&mut self, "
- "(&mut self, min_capacity: usize)"
- ": usize) {\n"
- "        self.map.shrink_to("
- "(min_capacity);\n    }\n\n"
- "    /// Visits the values "
- " the values representing the "
- " the difference,\n"
- "    /// i.e., the values that "
- "the values that are in `self` "
- " are in `self` but not in `other"
- " not in `other`.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let a: HashSet<_> = [1, "
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = [4, "
- "<_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n"
- "    ///\n"
- "    /// // Can be seen as `a - b"
- " seen as `a - b`.\n"
- "    /// for x in a.difference(&b"
- " a.difference(&b) {\n"
- "    ///     println!(\"{}\", x); /"
- "!(\"{}\", x); // Print 1\n"
- "    /// }\n    ///\n"
- "    /// let diff: HashSet<_> = "
- ": HashSet<_> = a.difference(&b)."
- "(&b).collect();\n"
- "    /// assert_eq!("
- "diff, [1].iter().collect());\n"
- "    ///\n"
- "    /// // Note that difference "
- that difference is not symmetric
- "is not symmetric,\n"
- "    /// // and `b - a` means "
- " `b - a` means something else:\n"
- "    /// let diff: HashSet<_> = "
- ": HashSet<_> = b.difference(&a)."
- "(&a).collect();\n"
- "    /// assert_eq!("
- "diff, [4].iter().collect());\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn difference<'a>(&'a "
- "<'a>(&'a self, other: &'a Self) "
- ": &'a Self) -> Difference<'a, T,"
- "<'a, T, S, A> {\n"
- "        Difference {\n"
- "            iter: self.iter(),\n"
- "            other,\n        }\n"
- "        }\n    }\n\n"
- "    /// Visits the values "
- " the values representing the "
- " the symmetric difference,\n"
- "    /// i.e., the values that "
- "the values that are in `self` or"
- "are in `self` or in `other` but "
- " in `other` but not in both.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let a: HashSet<_> = [1, "
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = [4, "
- "<_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n"
- "    ///\n"
- "    /// // Print 1, 4 in "
- "/ Print 1, 4 in arbitrary order."
- "arbitrary order.\n"
- "    /// for x in "
- " for x in a.symmetric_difference"
- "(&b) {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    ///\n"
- "    /// let diff1: HashSet<_> = "
- "<_> = a.symmetric_difference(&b)"
- "(&b).collect();\n"
- "    /// let diff2: HashSet<_> = "
- "<_> = b.symmetric_difference(&a)"
- "(&a).collect();\n    ///\n"
- "    ///\n    /// assert_eq!("
- "diff1, diff2);\n"
- "    /// assert_eq!("
- "diff1, [1, 4].iter().collect());"
- "().collect());\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn symmetric_difference<"
- "<'a>(&'a self, other: &'a Self) "
- ": &'a Self) -> "
- "&'a Self) -> SymmetricDifference"
- "<'a, T, S, A> {\n"
- "        SymmetricDifference {\n"
- "            iter: "
- "iter: self.difference(other)."
- (other).chain(other.difference(
- "(self)),\n        }\n    }\n\n"
- "    /// Visits the values "
- " the values representing the "
- " the intersection,\n"
- "    /// i.e., the values that "
- "the values that are both in `"
- " are both in `self` and `other`."
- "` and `other`.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let a: HashSet<_> = [1, "
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = [4, "
- "<_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n"
- "    ///\n"
- "    /// // Print 2, 3 in "
- "/ Print 2, 3 in arbitrary order."
- "arbitrary order.\n"
- "    /// for x in a.intersection("
- " a.intersection(&b) {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    ///\n"
- "    /// let intersection: "
- " intersection: HashSet<_> = "
- ": HashSet<_> = a.intersection(&b"
- "(&b).collect();\n"
- "    /// assert_eq!("
- "intersection, [2, 3].iter()."
- ", [2, 3].iter().collect());\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn intersection<'a>(&'a "
- "<'a>(&'a self, other: &'a Self) "
- ": &'a Self) -> Intersection<'a, "
- "<'a, T, S, A> {\n"
- "        let (smaller, larger) = "
- ", larger) = if self.len() <= "
- " self.len() <= other.len() {\n"
- "            (self, other)\n"
- "        } else {\n"
- "            (other, self)\n"
- "        };\n"
- "        Intersection {\n"
- "            iter: smaller.iter()"
- ": smaller.iter(),\n"
- "            other: larger,\n"
- "        }\n    }\n\n"
- "    /// Visits the values "
- " the values representing the "
- " the union,\n"
- "    /// i.e., all the values in "
- " the values in `self` or `other`"
- "self` or `other`, without "
- "other`, without duplicates.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let a: HashSet<_> = [1, "
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = [4, "
- "<_> = [4, 2, 3, 4].into_iter()."
- " 4].into_iter().collect();\n"
- "    ///\n"
- "    /// // Print 1, 2, 3, 4 in "
- " 1, 2, 3, 4 in arbitrary order.\n"
- "    /// for x in a.union(&b) {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    ///\n"
- "    /// let union: HashSet<_> = "
- ": HashSet<_> = a.union(&b)."
- "> = a.union(&b).collect();\n"
- "    /// assert_eq!("
- "union, [1, 2, 3, 4].iter()."
- "2, 3, 4].iter().collect());\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn union<'a>(&'a self, "
- "<'a>(&'a self, other: &'a Self) "
- ": &'a Self) -> Union<'a, T, S, A"
- "<'a, T, S, A> {\n"
- "        // We'll iterate one set"
- " iterate one set in full, and "
- " in full, and only the remaining"
- " the remaining difference from "
- "difference from the other.\n"
- "        // Use the smaller set "
- "the smaller set for the "
- " set for the difference in order"
- " in order to reduce hash lookups"
- " hash lookups.\n"
- "        let (smaller, larger) = "
- ", larger) = if self.len() <= "
- " self.len() <= other.len() {\n"
- "            (self, other)\n"
- "        } else {\n"
- "            (other, self)\n"
- "        };\n        Union {\n"
- "            iter: larger.iter()."
- ": larger.iter().chain("
- ().chain(smaller.difference(
- "(larger)),\n        }\n    }\n\n"
- "    /// Returns `true` if the "
- " `true` if the set contains a "
- " set contains a value.\n    ///\n"
- "    /// The value may be any "
- " may be any borrowed form of the"
- " form of the set's value type, "
- " value type, but\n"
- "    /// [`Hash`] and [`Eq`] on "
- "] and [`Eq`] on the borrowed "
- "on the borrowed form *must* "
- " form *must* match those for\n"
- "    /// the value type.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let set: HashSet<_> = [1"
- " HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// assert_eq!("
- "set.contains(&1), true);\n"
- "    /// assert_eq!("
- "set.contains(&4), false);\n"
- "    /// ```\n    ///\n"
- "    /// [`Eq`]: https://doc.rust"
- "https://doc.rust-lang.org/std/"
- "-lang.org/std/cmp/trait.Eq.html\n"
- "    /// [`Hash`]: https://"
- "Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn contains<Q: ?"
- "Sized>(&self, value: &Q) -> bool"
- ": &Q) -> bool\n    where\n"
- "        Q: Hash + Equivalent<T>,"
- "+ Equivalent<T>,\n    {\n"
- "        self.map.contains_key("
- "(value)\n    }\n\n"
- "    /// Returns a reference to "
- " a reference to the value in the"
- "the value in the set, if any, "
- " set, if any, that is equal to "
- " is equal to the given value.\n"
- "    ///\n"
- "    /// The value may be any "
- " may be any borrowed form of the"
- " form of the set's value type, "
- " value type, but\n"
- "    /// [`Hash`] and [`Eq`] on "
- "] and [`Eq`] on the borrowed "
- "on the borrowed form *must* "
- " form *must* match those for\n"
- "    /// the value type.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let set: HashSet<_> = [1"
- " HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// assert_eq!("
- "set.get(&2), Some(&2));\n"
- "    /// assert_eq!("
- "set.get(&4), None);\n    /// ```\n"
- "    /// ```\n    ///\n"
- "    /// [`Eq`]: https://doc.rust"
- "https://doc.rust-lang.org/std/"
- "-lang.org/std/cmp/trait.Eq.html\n"
- "    /// [`Hash`]: https://"
- "Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn get<Q: ?"
- "Sized>(&self, value: &Q) -> "
- ", value: &Q) -> Option<&T>\n"
- "    where\n"
- "        Q: Hash + Equivalent<T>,"
- "+ Equivalent<T>,\n    {\n"
- "        // Avoid `Option::map` "
- " `Option::map` because it bloats"
- " it bloats LLVM IR.\n"
- "        match "
- match self.map.get_key_value(
- "(value) {\n"
- "            Some((k, _)) => Some"
- "((k, _)) => Some(k),\n"
- "            None => None,\n"
- "        }\n    }\n\n"
- "    /// Inserts the given `value"
- "the given `value` into the set "
- "` into the set if it is not "
- " if it is not present, then\n"
- "    /// returns a reference to "
- " a reference to the value in the"
- "the value in the set.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<_> "
- "set: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// assert_eq!("
- "set.len(), 3);\n"
- "    /// assert_eq!("
- "set.get_or_insert(2), &2);\n"
- "    /// assert_eq!("
- "set.get_or_insert(100), &100);\n"
- "    /// assert_eq!("
- "set.len(), 4); // 100 was "
- " 4); // 100 was inserted\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn get_or_insert(&mut "
- "(&mut self, value: T) -> &T {\n"
- "        // Although the raw "
- " the raw entry gives us `&mut T`"
- " us `&mut T`, we only return `&T"
- " only return `&T` to be "
- " `&T` to be consistent with\n"
- "        // `get`. "
- "Key mutation is \"raw\" because "
- " \"raw\" because you're not "
- " you're not supposed to affect `"
- " to affect `Eq` or `Hash`.\n"
- "        self.map\n"
- "            .raw_entry_mut()\n"
- "            .from_key(&value)\n"
- "            .or_insert(value, ()"
- "(value, ())\n            .0\n"
- "            .0\n    }\n\n"
- "    /// Inserts an owned copy of"
- "an owned copy of the given `"
- " of the given `value` into the "
- "value` into the set if it is not"
- "set if it is not\n"
- "    /// present, then returns a "
- " then returns a reference to the"
- "reference to the value in the "
- " value in the set.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<"
- " set: HashSet<String> = [\"cat\", "
- "> = [\"cat\", \"dog\", \"horse\"]\n"
- "    ///     .iter().map(|&pet| "
- ().map(|&pet| pet.to_owned()).
- "pet.to_owned()).collect();\n"
- "    ///\n    /// assert_eq!("
- "set.len(), 3);\n"
- "    /// for &pet in &[\"cat\", \""
- " in &[\"cat\", \"dog\", \"fish\"] {\n"
- "    ///     let value = "
- " value = set.get_or_insert_owned"
- "(pet);\n    ///     assert_eq!("
- "value, pet);\n    /// }\n"
- "    /// }\n    /// assert_eq!("
- "set.len(), 4); // a new \"fish\" "
- "// a new \"fish\" was inserted\n"
- "    /// ```\n    #[inline]\n"
- "    pub fn get_or_insert_owned<Q"
- "<Q: ?"
- "Sized>(&mut self, value: &Q) -> "
- ", value: &Q) -> &T\n    where\n"
- "        Q: Hash + Equivalent<T> "
- "+ Equivalent<T> + ToOwned<Owned "
- "+ ToOwned<Owned = T>,\n    {\n"
- "        // Although the raw "
- " the raw entry gives us `&mut T`"
- " us `&mut T`, we only return `&T"
- " only return `&T` to be "
- " `&T` to be consistent with\n"
- "        // `get`. "
- "Key mutation is \"raw\" because "
- " \"raw\" because you're not "
- " you're not supposed to affect `"
- " to affect `Eq` or `Hash`.\n"
- "        self.map\n"
- "            .raw_entry_mut()\n"
- "            .from_key(value)\n"
- "            .or_insert_with(|| ("
- "(|| (value.to_owned(), ()))\n"
- "            .0\n    }\n\n"
- "    /// Inserts a value computed"
- "a value computed from `f` into "
- " from `f` into the set if the "
- " the set if the given `value` is"
- "given `value` is\n"
- "    /// not present, then "
- " present, then returns a "
- " then returns a reference to the"
- "reference to the value in the "
- " value in the set.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<"
- " set: HashSet<String> = [\"cat\", "
- "> = [\"cat\", \"dog\", \"horse\"]\n"
- "    ///     .iter().map(|&pet| "
- ().map(|&pet| pet.to_owned()).
- "pet.to_owned()).collect();\n"
- "    ///\n    /// assert_eq!("
- "set.len(), 3);\n"
- "    /// for &pet in &[\"cat\", \""
- " in &[\"cat\", \"dog\", \"fish\"] {\n"
- "    ///     let value = "
- " value = set.get_or_insert_with("
- "(pet, str::to_owned);\n"
- "    ///     assert_eq!("
- "value, pet);\n    /// }\n"
- "    /// }\n    /// assert_eq!("
- "set.len(), 4); // a new \"fish\" "
- "// a new \"fish\" was inserted\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn get_or_insert_with<Q:"
- "<Q: ?"
- "Sized, F>(&mut self, value: &Q, "
- ", value: &Q, f: F) -> &T\n"
- "    where\n"
- "        Q: Hash + Equivalent<T>,"
- "+ Equivalent<T>,\n"
- "        F: FnOnce(&Q) -> T,\n"
- "    {\n"
- "        // Although the raw "
- " the raw entry gives us `&mut T`"
- " us `&mut T`, we only return `&T"
- " only return `&T` to be "
- " `&T` to be consistent with\n"
- "        // `get`. "
- "Key mutation is \"raw\" because "
- " \"raw\" because you're not "
- " you're not supposed to affect `"
- " to affect `Eq` or `Hash`.\n"
- "        self.map\n"
- "            .raw_entry_mut()\n"
- "            .from_key(value)\n"
- "            .or_insert_with(|| ("
- "(|| (f(value), ()))\n"
- "            .0\n    }\n\n"
- "    /// Gets the given value's "
- " given value's corresponding "
- " corresponding entry in the set "
- " in the set for in-place "
- " for in-place manipulation.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::Entry::*;\n    ///\n"
- "    /// let mut singles = "
- " mut singles = HashSet::new();\n"
- "    /// let mut dupes = HashSet:"
- "dupes = HashSet::new();\n    ///\n"
- "    /// for ch in \"a short "
- " ch in \"a short treatise on "
- " treatise on fungi\".chars() {\n"
- "    ///     if let Vacant("
- "if let Vacant(dupe_entry) = "
- "(dupe_entry) = dupes.entry(ch) {"
- "(ch) {\n"
- "    ///         // We haven't "
- "// We haven't already seen a "
- " already seen a duplicate, so\n"
- "    ///         // check if "
- "// check if we've at least seen "
- " at least seen it once.\n"
- "    ///         match "
- /         match singles.entry(ch
- "singles.entry(ch) {\n"
- "    ///             Vacant("
- "Vacant(single_entry) => {\n"
- "    ///                 // We "
- "// We found a new character for "
- " character for the first time.\n"
- "    ///                 "
- "single_entry.insert();\n"
- "    ///             }\n"
- "    ///             Occupied("
- "Occupied(single_entry) => {\n"
- "    ///                 // We've"
- "// We've already seen this once,"
- " seen this once, \"move\" it to "
- ", \"move\" it to dupes.\n"
- "    ///                 "
- "single_entry.remove();\n"
- "    ///                 "
- "dupe_entry.insert();\n"
- "    ///             }\n"
- "    ///         }\n    ///     }\n"
- "    ///     }\n    /// }\n    ///\n"
- "    ///\n    /// assert!(!"
- "singles.contains(&'t') && "
- "(&'t') && dupes.contains(&'t'));"
- "(&'t'));\n    /// assert!("
- "singles.contains(&'u') && !"
- "dupes.contains(&'u'));\n"
- "    /// assert!(!"
- "singles.contains(&'v') && !"
- "dupes.contains(&'v'));\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn entry(&mut self, "
- "(&mut self, value: T) -> Entry<'"
- ": T) -> Entry<'_, T, S, A> {\n"
- "        match self.map.entry("
- " self.map.entry(value) {\n"
- "            map::Entry::Occupied"
- ":Entry::Occupied(entry) => Entry"
- "(entry) => Entry::Occupied("
- "Entry::Occupied(OccupiedEntry { "
- "OccupiedEntry { inner: entry }),"
- "inner: entry }),\n"
- "            map::Entry::Vacant("
- "::Entry::Vacant(entry) => Entry:"
- "entry) => Entry::Vacant("
- "> Entry::Vacant(VacantEntry { "
- "(VacantEntry { inner: entry }),\n"
- "        }\n    }\n\n"
- "    /// Returns `true` if `self`"
- "`true` if `self` has no elements"
- " has no elements in common with "
- " in common with `other`.\n"
- "    /// This is equivalent to "
- " equivalent to checking for an "
- "checking for an empty "
- " for an empty intersection.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let a: HashSet<_> = [1, "
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// let mut b = HashSet::new"
- "b = HashSet::new();\n    ///\n"
- "    ///\n    /// assert_eq!("
- "a.is_disjoint(&b), true);\n"
- "    /// b.insert(4);\n"
- "    /// assert_eq!("
- "a.is_disjoint(&b), true);\n"
- "    /// b.insert(1);\n"
- "    /// assert_eq!("
- "a.is_disjoint(&b), false);\n"
- "    /// ```\n"
- "    pub fn is_disjoint(&self, "
- "(&self, other: &Self) -> bool {\n"
- "        self.iter().all(|v| !"
- "other.contains(v))\n    }\n\n"
- "    /// Returns `true` if the "
- " `true` if the set is a subset "
- "set is a subset of another,\n"
- "    /// i.e., `other` contains "
- "other` contains at least all the"
- "at least all the values in `self"
- " values in `self`.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let sup: HashSet<_> = [1"
- " HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n    ///\n"
- "    ///\n    /// assert_eq!("
- "set.is_subset(&sup), true);\n"
- "    /// set.insert(2);\n"
- "    /// assert_eq!("
- "set.is_subset(&sup), true);\n"
- "    /// set.insert(4);\n"
- "    /// assert_eq!("
- "set.is_subset(&sup), false);\n"
- "    /// ```\n"
- "    pub fn is_subset(&self, "
- "(&self, other: &Self) -> bool {\n"
- "        self.len() <= other.len("
- () <= other.len() && self.iter()
- ") && self.iter().all(|v| "
- "().all(|v| other.contains(v))\n"
- "    }\n\n"
- "    /// Returns `true` if the "
- " `true` if the set is a superset"
- " is a superset of another,\n"
- "    /// i.e., `self` contains at"
- "` contains at least all the "
- " least all the values in `other`"
- " in `other`.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let sub: HashSet<_> = [1"
- " HashSet<_> = [1, 2].into_iter()"
- ", 2].into_iter().collect();\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n    ///\n"
- "    ///\n    /// assert_eq!("
- "set.is_superset(&sub), false);\n"
- "    ///\n    /// set.insert(0);\n"
- "    /// set.insert(1);\n"
- "    /// assert_eq!("
- "set.is_superset(&sub), false);\n"
- "    ///\n    /// set.insert(2);\n"
- "    /// assert_eq!("
- "set.is_superset(&sub), true);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn is_superset(&self, "
- "(&self, other: &Self) -> bool {\n"
- "        other.is_subset(self)\n"
- "    }\n\n"
- "    /// Adds a value to the set."
- " to the set.\n    ///\n"
- "    /// If the set did not have "
- " did not have this value present"
- " value present, `true` is "
- ", `true` is returned.\n    ///\n"
- "    /// If the set did have this"
- " did have this value present, `"
- "value present, `false` is "
- ", `false` is returned.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n    ///\n"
- "    ///\n    /// assert_eq!("
- "set.insert(2), true);\n"
- "    /// assert_eq!("
- "set.insert(2), false);\n"
- "    /// assert_eq!("
- "set.len(), 1);\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn insert(&mut self, "
- "(&mut self, value: T) -> bool {\n"
- "        self.map.insert(value, ("
- "(value, ()).is_none()\n    }\n\n"
- "    /// Insert a value the set "
- a value the set without checking
- "without checking if the value "
- " if the value already exists in "
- " exists in the set.\n    ///\n"
- "    /// Returns a reference to "
- " a reference to the value just "
- " the value just inserted.\n"
- "    ///\n"
- "    /// This operation is safe "
- " is safe if a value does not "
- " value does not exist in the set"
- "exist in the set.\n    ///\n"
- "    /// However, if a value "
- ", if a value exists in the set "
- " in the set already, the "
- " already, the behavior is "
- "the behavior is unspecified:\n"
- "    /// this operation may panic"
- " may panic, loop forever, or any"
- " forever, or any following "
- " any following operation with "
- " operation with the set\n"
- "    /// may panic, loop forever "
- ", loop forever or return "
- " or return arbitrary result.\n"
- "    ///\n"
- "    /// That said, this "
- "That said, this operation (and "
- " operation (and following "
- " (and following operations) are "
- "operations) are guaranteed to\n"
- "    /// not violate memory "
- " violate memory safety.\n    ///\n"
- "    /// This operation is faster"
- " is faster than regular insert, "
- "regular insert, because it does "
- "because it does not perform\n"
- "    /// lookup before insertion."
- " insertion.\n    ///\n"
- "    /// This operation is useful"
- " is useful during initial "
- " during initial population of "
- " population of the set.\n"
- "    /// For example, when "
- " example, when constructing a "
- " constructing a set from another"
- "set from another set, we know\n"
- "    /// that values are unique.\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn "
- pub fn insert_unique_unchecked(&
- "(&mut self, value: T) -> &T {\n"
- "        "
- self.map.insert_unique_unchecked
- "(value, ()).0\n    }\n\n"
- "    /// Adds a value to the set,"
- " to the set, replacing the "
- ", replacing the existing value, "
- "existing value, if any, that is "
- "if any, that is equal to the "
- "is equal to the given\n"
- "    /// one. "
- "Returns the replaced value.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n"
- "    /// set.insert(Vec::<i32>::"
- "(Vec::<i32>::new());\n    ///\n"
- "    ///\n    /// assert_eq!("
- "set.get(&[][..]).unwrap()."
- "][..]).unwrap().capacity(), 0);\n"
- "    /// set.replace(Vec::"
- "(Vec::with_capacity(10));\n"
- "    /// assert_eq!("
- "set.get(&[][..]).unwrap()."
- "][..]).unwrap().capacity(), 10);"
- "capacity(), 10);\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn replace(&mut self, "
- "(&mut self, value: T) -> Option<"
- ": T) -> Option<T> {\n"
- "        match self.map.entry("
- " self.map.entry(value) {\n"
- "            map::Entry::Occupied"
- ":Entry::Occupied(occupied) => "
- (occupied) => Some(
- ) => Some(occupied.replace_key()
- "()),\n"
- "            map::Entry::Vacant("
- "::Entry::Vacant(vacant) => {\n"
- "                vacant.insert(()"
- "vacant.insert(());\n"
- "                None\n"
- "            }\n        }\n    }\n\n"
- "    /// Removes a value from the"
- "a value from the set. "
- "Returns whether the value was\n"
- "    /// present in the set.\n"
- "    ///\n"
- "    /// The value may be any "
- " may be any borrowed form of the"
- " form of the set's value type, "
- " value type, but\n"
- "    /// [`Hash`] and [`Eq`] on "
- "] and [`Eq`] on the borrowed "
- "on the borrowed form *must* "
- " form *must* match those for\n"
- "    /// the value type.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n    ///\n"
- "    ///\n    /// set.insert(2);\n"
- "    /// assert_eq!("
- "set.remove(&2), true);\n"
- "    /// assert_eq!("
- "set.remove(&2), false);\n"
- "    /// ```\n    ///\n"
- "    /// [`Eq`]: https://doc.rust"
- "https://doc.rust-lang.org/std/"
- "-lang.org/std/cmp/trait.Eq.html\n"
- "    /// [`Hash`]: https://"
- "Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn remove<Q: ?"
- "Sized>(&mut self, value: &Q) -> "
- ", value: &Q) -> bool\n    where\n"
- "        Q: Hash + Equivalent<T>,"
- "+ Equivalent<T>,\n    {\n"
- "        self.map.remove(value)."
- "(value).is_some()\n    }\n\n"
- "    /// Removes and returns the "
- and returns the value in the set
- "value in the set, if any, that "
- ", if any, that is equal to the "
- "is equal to the given one.\n"
- "    ///\n"
- "    /// The value may be any "
- " may be any borrowed form of the"
- " form of the set's value type, "
- " value type, but\n"
- "    /// [`Hash`] and [`Eq`] on "
- "] and [`Eq`] on the borrowed "
- "on the borrowed form *must* "
- " form *must* match those for\n"
- "    /// the value type.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<_> "
- "set: HashSet<_> = [1, 2, 3]."
- "<_> = [1, 2, 3].into_iter()."
- " 3].into_iter().collect();\n"
- "    /// assert_eq!("
- "set.take(&2), Some(2));\n"
- "    /// assert_eq!("
- "set.take(&2), None);\n"
- "    /// ```\n    ///\n"
- "    /// [`Eq`]: https://doc.rust"
- "https://doc.rust-lang.org/std/"
- "-lang.org/std/cmp/trait.Eq.html\n"
- "    /// [`Hash`]: https://"
- "Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- "/std/hash/trait.Hash.html\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn take<Q: ?"
- "Sized>(&mut self, value: &Q) -> "
- ", value: &Q) -> Option<T>\n"
- "    where\n"
- "        Q: Hash + Equivalent<T>,"
- "+ Equivalent<T>,\n    {\n"
- "        // Avoid `Option::map` "
- " `Option::map` because it bloats"
- " it bloats LLVM IR.\n"
- "        match "
- match self.map.remove_entry(
- "(value) {\n"
- "            Some((k, _)) => Some"
- "((k, _)) => Some(k),\n"
- "            None => None,\n"
- "        }\n    }\n}\n\n"
- "impl<T, S, A: Allocator> HashSet"
- "> HashSet<T, S, A> {\n"
- "    /// Returns a reference to "
- " a reference to the [`RawTable`]"
- "the [`RawTable`] used underneath"
- " used underneath [`HashSet`].\n"
- "    /// This function is only "
- " is only available if the `raw` "
- " if the `raw` feature of the "
- " feature of the crate is enabled"
- "crate is enabled.\n    ///\n"
- "    ///\n    /// # Note\n    ///\n"
- "    /// Calling this function is"
- "this function is safe, but using"
- " safe, but using the raw hash "
- " the raw hash table API may "
- " table API may require\n"
- "    /// unsafe functions or "
- " functions or blocks.\n    ///\n"
- "    /// `RawTable` API gives the"
- "` API gives the lowest level of "
- "lowest level of control under "
- " control under the set that can "
- " set that can be useful\n"
- "    /// for extending the "
- " extending the HashSet's API, "
- " HashSet's API, but may lead to "
- "but may lead to *[undefined "
- " to *[undefined behavior]*.\n"
- "    ///\n"
- "    /// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "    /// [`RawTable`]: crate::raw"
- "`]: crate::raw::RawTable\n"
- "    /// [undefined behavior]: "
- " behavior]: https://doc.rust-"
- "://doc.rust-lang.org/reference/"
- /reference/behavior-considered-
- "-considered-undefined.html\n"
- "    #[cfg(feature = \"raw\")]\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn raw_table(&self) -> &"
- "(&self) -> &RawTable<(T, ()), A>"
- "<(T, ()), A> {\n"
- "        self.map.raw_table()\n"
- "    }\n\n"
- "    /// Returns a mutable "
- " a mutable reference to the [`"
- " to the [`RawTable`] used "
- "RawTable`] used underneath [`"
- " underneath [`HashSet`].\n"
- "    /// This function is only "
- " is only available if the `raw` "
- " if the `raw` feature of the "
- " feature of the crate is enabled"
- "crate is enabled.\n    ///\n"
- "    ///\n    /// # Note\n    ///\n"
- "    /// Calling this function is"
- "this function is safe, but using"
- " safe, but using the raw hash "
- " the raw hash table API may "
- " table API may require\n"
- "    /// unsafe functions or "
- " functions or blocks.\n    ///\n"
- "    /// `RawTable` API gives the"
- "` API gives the lowest level of "
- "lowest level of control under "
- " control under the set that can "
- " set that can be useful\n"
- "    /// for extending the "
- " extending the HashSet's API, "
- " HashSet's API, but may lead to "
- "but may lead to *[undefined "
- " to *[undefined behavior]*.\n"
- "    ///\n"
- "    /// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "    /// [`RawTable`]: crate::raw"
- "`]: crate::raw::RawTable\n"
- "    /// [undefined behavior]: "
- " behavior]: https://doc.rust-"
- "://doc.rust-lang.org/reference/"
- /reference/behavior-considered-
- "-considered-undefined.html\n"
- "    #[cfg(feature = \"raw\")]\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn raw_table_mut(&mut "
- "(&mut self) -> &mut RawTable<(T,"
- "mut RawTable<(T, ()), A> {\n"
- "        self.map.raw_table_mut()"
- "()\n    }\n}\n\n"
- "impl<T, S, A> PartialEq for "
- "> PartialEq for HashSet<T, S, A>"
- "HashSet<T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    fn eq(&self, other: &Self) -"
- " other: &Self) -> bool {\n"
- "        if self.len() !"
- "= other.len() {\n"
- "            return false;\n"
- "        }\n\n"
- "        self.iter().all(|key| "
- ().all(|key| other.contains(key)
- "(key))\n    }\n}\n\n"
- "impl<T, S, A> Eq for HashSet<T, "
- " for HashSet<T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " fmt::Debug for HashSet<T, S, A>"
- "HashSet<T, S, A>\nwhere\n"
- "where\n    T: fmt::Debug,\n"
- "    A: Allocator,\n{\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_set().entries("
- ().entries(self.iter()).finish()
- "()).finish()\n    }\n}\n\n"
- "impl<T, S, A> From<HashMap<T, ()"
- "<HashMap<T, (), S, A>> for "
- " (), S, A>> for HashSet<T, S, A>"
- "HashSet<T, S, A>\nwhere\n"
- "where\n    A: Allocator,\n{\n"
- "    fn from(map: HashMap<T, (), "
- " HashMap<T, (), S, A>) -> Self {"
- "S, A>) -> Self {\n"
- "        Self { map }\n    }\n}\n\n"
- "impl<T, S, A> FromIterator<T> "
- "FromIterator<T> for HashSet<T, S"
- "for HashSet<T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher + Default,\n"
- "    A: Default + Allocator,\n{\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn from_iter<I: IntoIterator"
- "<I: IntoIterator<Item = T>>(iter"
- "<Item = T>>(iter: I) -> Self {\n"
- "        let mut set = Self::"
- "mut set = Self::with_hasher_in("
- ":with_hasher_in(Default::default"
- "Default::default(), Default::"
- "(), Default::default());\n"
- "        set.extend(iter);\n"
- "        set\n    }\n}\n\n"
- // The default hasher is used to
- " is used to match the std "
- " match the std implementation "
- " implementation signature\n"
- "#[cfg(feature = \"ahash\")]\n"
- "impl<T, A, const N: usize> From<"
- " N: usize> From<[T; N]> for "
- "<[T; N]> for HashSet<T, "
- " HashSet<T, DefaultHashBuilder, "
- ", A>\nwhere\n    T: Eq + Hash,\n"
- "    A: Default + Allocator,\n{\n"
- "{\n    /// # Examples\n    ///\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let set1 = HashSet::from"
- " = HashSet::from([1, 2, 3, 4]);\n"
- "    /// let set2: HashSet<_> = ["
- ": HashSet<_> = [1, 2, 3, 4].into"
- "1, 2, 3, 4].into();\n"
- "    /// assert_eq!(set1, set2);\n"
- "set1, set2);\n    /// ```\n"
- "    fn from(arr: [T; N]) -> Self"
- " [T; N]) -> Self {\n"
- "        arr.into_iter().collect("
- "().collect()\n    }\n}\n\n"
- "impl<T, S, A> Extend<T> for "
- "> Extend<T> for HashSet<T, S, A>"
- "HashSet<T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn extend<I: IntoIterator<"
- "I: IntoIterator<Item = T>>(&mut "
- "Item = T>>(&mut self, iter: I) {"
- "self, iter: I) {\n"
- "        self.map.extend("
- self.map.extend(iter.into_iter()
- "iter.into_iter().map(|k| (k, ())"
- ".map(|k| (k, ())));\n    }\n\n"
- "    }\n\n    #[inline]\n"
- "    #[cfg(feature = \"nightly\")]\n"
- "    fn extend_one(&mut self, k: "
- "(&mut self, k: T) {\n"
- "        self.map.insert(k, ());\n"
- "    }\n\n    #[inline]\n"
- "    #[cfg(feature = \"nightly\")]\n"
- "    fn extend_reserve(&mut self,"
- "(&mut self, additional: usize) {"
- ": usize) {\n"
- "        Extend::<(T, ())>::"
- "::<(T, ())>::extend_reserve(&mut"
- "(&mut self.map, additional);\n"
- "    }\n}\n\n"
- "impl<'a, T, S, A> Extend<&'a T> "
- "> Extend<&'a T> for HashSet<T, S"
- "for HashSet<T, S, A>\nwhere\n"
- "    T: 'a + Eq + Hash + Copy,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn extend<I: IntoIterator<"
- "I: IntoIterator<Item = &'a T>>(&"
- "Item = &'a T>>(&mut self, iter: "
- "mut self, iter: I) {\n"
- "        self.extend("
- self.extend(iter.into_iter().
- "().copied());\n    }\n\n"
- "    }\n\n    #[inline]\n"
- "    #[cfg(feature = \"nightly\")]\n"
- "    fn extend_one(&mut self, k: "
- "(&mut self, k: &'a T) {\n"
- "        self.map.insert(*k, ());"
- "(*k, ());\n    }\n\n    #[inline]\n"
- "    #[cfg(feature = \"nightly\")]\n"
- "    fn extend_reserve(&mut self,"
- "(&mut self, additional: usize) {"
- ": usize) {\n"
- "        Extend::<(T, ())>::"
- "::<(T, ())>::extend_reserve(&mut"
- "(&mut self.map, additional);\n"
- "    }\n}\n\n"
- "impl<T, S, A> Default for "
- " A> Default for HashSet<T, S, A>"
- "HashSet<T, S, A>\nwhere\n"
- "where\n    S: Default,\n"
- "    A: Default + Allocator,\n{\n"
- "    /// Creates an empty `"
- " an empty `HashSet<T, S>` with "
- "<T, S>` with the `Default` value"
- " `Default` value for the hasher."
- " for the hasher.\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn default() -> Self {\n"
- "        Self {\n"
- "            map: HashMap::"
- "map: HashMap::default(),\n"
- "        }\n    }\n}\n\n"
- "impl<T, S, A> BitOr<&HashSet<T, "
- "<&HashSet<T, S, A>> for &HashSet"
- "A>> for &HashSet<T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash + Clone,\n"
- "    S: BuildHasher + Default,\n"
- "    A: Allocator,\n{\n"
- "    type Output = HashSet<T, S>;"
- "= HashSet<T, S>;\n\n"
- "    /// Returns the union of `"
- " the union of `self` and `rhs` "
- "self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let a: HashSet<_> = vec!"
- "<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = vec!"
- "<_> = vec!["
- "3, 4, 5].into_iter().collect();\n"
- "    ///\n"
- "    /// let set = &a | &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    /// let expected = [1, 2, 3,"
- " = [1, 2, 3, 4, 5];\n"
- "    /// for x in &set {\n"
- "    ///     assert!("
- "expected.contains(x));\n"
- "    ///     i += 1;\n    /// }\n"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```\n"
- "    fn bitor(self, rhs: &HashSet"
- ", rhs: &HashSet<T, S, A>) -> "
- "<T, S, A>) -> HashSet<T, S> {\n"
- "        self.union(rhs).cloned()"
- "(rhs).cloned().collect()\n    }\n"
- "    }\n}\n\n"
- "impl<T, S, A> BitAnd<&HashSet<T,"
- "<&HashSet<T, S, A>> for &HashSet"
- "A>> for &HashSet<T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash + Clone,\n"
- "    S: BuildHasher + Default,\n"
- "    A: Allocator,\n{\n"
- "    type Output = HashSet<T, S>;"
- "= HashSet<T, S>;\n\n"
- "    /// Returns the intersection"
- "the intersection of `self` and `"
- " of `self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let a: HashSet<_> = vec!"
- "<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = vec!"
- "<_> = vec!["
- "2, 3, 4].into_iter().collect();\n"
- "    ///\n"
- "    /// let set = &a & &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    /// let expected = [2, 3];\n"
- "    /// for x in &set {\n"
- "    ///     assert!("
- "expected.contains(x));\n"
- "    ///     i += 1;\n    /// }\n"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```\n"
- "    fn bitand(self, rhs: &"
- "(self, rhs: &HashSet<T, S, A>) -"
- "<T, S, A>) -> HashSet<T, S> {\n"
- "        self.intersection(rhs)."
- "(rhs).cloned().collect()\n    }\n"
- "    }\n}\n\n"
- "impl<T, S> BitXor<&HashSet<T, S>"
- "<&HashSet<T, S>> for &HashSet<T,"
- " for &HashSet<T, S>\nwhere\n"
- "where\n    T: Eq + Hash + Clone,\n"
- "    S: BuildHasher + Default,\n{\n"
- "    type Output = HashSet<T, S>;"
- "= HashSet<T, S>;\n\n"
- "    /// Returns the symmetric "
- " the symmetric difference of `"
- " difference of `self` and `rhs` "
- "self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let a: HashSet<_> = vec!"
- "<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = vec!"
- "<_> = vec!["
- "3, 4, 5].into_iter().collect();\n"
- "    ///\n"
- "    /// let set = &a ^ &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    /// let expected = [1, 2, 4,"
- " = [1, 2, 4, 5];\n"
- "    /// for x in &set {\n"
- "    ///     assert!("
- "expected.contains(x));\n"
- "    ///     i += 1;\n    /// }\n"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```\n"
- "    fn bitxor(self, rhs: &"
- "(self, rhs: &HashSet<T, S>) -> "
- "<T, S>) -> HashSet<T, S> {\n"
- "        "
- self.symmetric_difference(rhs).
- "(rhs).cloned().collect()\n    }\n"
- "    }\n}\n\n"
- "impl<T, S> Sub<&HashSet<T, S>> "
- "&HashSet<T, S>> for &HashSet<T, "
- "for &HashSet<T, S>\nwhere\n"
- "where\n    T: Eq + Hash + Clone,\n"
- "    S: BuildHasher + Default,\n{\n"
- "    type Output = HashSet<T, S>;"
- "= HashSet<T, S>;\n\n"
- "    /// Returns the difference "
- " the difference of `self` and `"
- " of `self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let a: HashSet<_> = vec!"
- "<_> = vec!["
- "1, 2, 3].into_iter().collect();\n"
- "    /// let b: HashSet<_> = vec!"
- "<_> = vec!["
- "3, 4, 5].into_iter().collect();\n"
- "    ///\n"
- "    /// let set = &a - &b;\n"
- "    ///\n    /// let mut i = 0;\n"
- "    /// let expected = [1, 2];\n"
- "    /// for x in &set {\n"
- "    ///     assert!("
- "expected.contains(x));\n"
- "    ///     i += 1;\n    /// }\n"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```\n"
- "    fn sub(self, rhs: &HashSet<T"
- " rhs: &HashSet<T, S>) -> HashSet"
- ", S>) -> HashSet<T, S> {\n"
- "        self.difference(rhs)."
- "(rhs).cloned().collect()\n    }\n"
- "    }\n}\n\n"
- "/// An iterator over the items "
- " over the items of a `HashSet`.\n"
- "///\n"
- "/// This `struct` is created by "
- "` is created by the [`iter`] "
- "by the [`iter`] method on [`"
- "`] method on [`HashSet`].\n"
- "/// See its documentation for "
- " for more.\n///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`iter`]: "
- "// [`iter`]: struct.HashSet.html"
- "#method.iter\n"
- "pub struct Iter<'a, K> {\n"
- "    iter: Keys<'a, K, ()>,\n}\n\n"
- "/// An owning iterator over the "
- " over the items of a `HashSet`.\n"
- "///\n"
- "/// This `struct` is created by "
- "` is created by the [`into_iter`"
- "the [`into_iter`] method on [`"
- "`] method on [`HashSet`]\n"
- "/// (provided by the `"
- " by the `IntoIterator` trait). "
- "See its documentation for more.\n"
- "///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`into_iter`]: "
- "into_iter`]: struct.HashSet.html"
- "#method.into_iter\n"
- "pub struct IntoIter<K, A: "
- " IntoIter<K, A: Allocator = "
- " A: Allocator = Global> {\n"
- "    iter: map::IntoIter<K, (), A"
- "<K, (), A>,\n}\n\n"
- /// A draining iterator over the
- " over the items of a `HashSet`.\n"
- "///\n"
- "/// This `struct` is created by "
- "` is created by the [`drain`] "
- " the [`drain`] method on [`"
- "`] method on [`HashSet`].\n"
- "/// See its documentation for "
- " for more.\n///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`drain`]: "
- "/ [`drain`]: struct.HashSet.html"
- "#method.drain\n"
- "pub struct Drain<'a, K, A: "
- "Drain<'a, K, A: Allocator = "
- " A: Allocator = Global> {\n"
- "    iter: map::Drain<'a, K, (), "
- "<'a, K, (), A>,\n}\n\n"
- "/// A draining iterator over "
- " iterator over entries of a `"
- " entries of a `HashSet` which "
- "`HashSet` which don't satisfy "
- " don't satisfy the predicate `f`"
- " predicate `f`.\n///\n"
- "/// This `struct` is created by "
- "` is created by the [`extract_if"
- "the [`extract_if`] method on [`"
- "`] method on [`HashSet`]. "
- "See its\n"
- "/// documentation for more.\n///\n"
- "/// [`extract_if`]: "
- "`]: struct.HashSet.html#"
- "#method.extract_if\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "#[must_use = \"Iterators are lazy"
- " are lazy unless consumed\"]\n"
- "pub struct ExtractIf<'a, K, F, A"
- "<'a, K, F, A: Allocator = Global"
- " = Global>\nwhere\n"
- "where\n    F: FnMut(&K) -> bool,\n"
- "{\n    f: F,\n"
- "    inner: RawExtractIf<'a, (K, "
- "<'a, (K, ()), A>,\n}\n\n"
- "/// A lazy iterator producing "
- " producing elements in the "
- "elements in the intersection of "
- "intersection of `HashSet`s.\n///\n"
- "/// This `struct` is created by "
- "` is created by the [`"
- " by the [`intersection`] method "
- "`] method on [`HashSet`].\n"
- "/// See its documentation for "
- " for more.\n///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`intersection`]: "
- "`]: struct.HashSet.html#"
- "#method.intersection\n"
- "pub struct Intersection<'a, T, S"
- "<'a, T, S, A: Allocator = Global"
- " = Global> {\n"
- "    // iterator of the first set"
- "of the first set\n"
- "    iter: Iter<'a, T>,\n"
- "    // the second set\n"
- "    other: &'a HashSet<T, S, A>,"
- "<T, S, A>,\n}\n\n"
- "/// A lazy iterator producing "
- " producing elements in the "
- "elements in the difference of `"
- " difference of `HashSet`s.\n///\n"
- "/// This `struct` is created by "
- "` is created by the [`difference"
- "the [`difference`] method on [`"
- "`] method on [`HashSet`].\n"
- "/// See its documentation for "
- " for more.\n///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`difference`]: "
- "`]: struct.HashSet.html#"
- "#method.difference\n"
- "pub struct Difference<'a, T, S, "
- "<'a, T, S, A: Allocator = Global"
- " = Global> {\n"
- "    // iterator of the first set"
- "of the first set\n"
- "    iter: Iter<'a, T>,\n"
- "    // the second set\n"
- "    other: &'a HashSet<T, S, A>,"
- "<T, S, A>,\n}\n\n"
- "/// A lazy iterator producing "
- " producing elements in the "
- "elements in the symmetric "
- " the symmetric difference of `"
- " difference of `HashSet`s.\n///\n"
- "/// This `struct` is created by "
- "` is created by the [`"
- " by the [`symmetric_difference`]"
- "`] method on\n/// [`HashSet`]. "
- "See its documentation for more.\n"
- "///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`symmetric_difference`]: "
- "`]: struct.HashSet.html#"
- "#method.symmetric_difference\n"
- "pub struct SymmetricDifference<'"
- "<'a, T, S, A: Allocator = Global"
- " = Global> {\n"
- "    iter: Chain<Difference<'a, T"
- "Difference<'a, T, S, A>, "
- "<'a, T, S, A>, Difference<'a, T,"
- "<'a, T, S, A>>,\n}\n\n"
- "/// A lazy iterator producing "
- " producing elements in the union"
- " in the union of `HashSet`s.\n"
- "///\n"
- "/// This `struct` is created by "
- "` is created by the [`union`] "
- " the [`union`] method on [`"
- "`] method on [`HashSet`].\n"
- "/// See its documentation for "
- " for more.\n///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`union`]: "
- "/ [`union`]: struct.HashSet.html"
- "#method.union\n"
- "pub struct Union<'a, T, S, A: "
- "<'a, T, S, A: Allocator = Global"
- " = Global> {\n"
- "    iter: Chain<Iter<'a, T>, "
- "<Iter<'a, T>, Difference<'a, T, "
- "<'a, T, S, A>>,\n}\n\n"
- "impl<'a, T, S, A: Allocator> "
- ", A: Allocator> IntoIterator for"
- "IntoIterator for &'a HashSet<T, "
- " &'a HashSet<T, S, A> {\n"
- "    type Item = &'a T;\n"
- "    type IntoIter = Iter<'a, T>;"
- " = Iter<'a, T>;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn into_iter(self) -> Iter<'"
- "(self) -> Iter<'a, T> {\n"
- "        self.iter()\n    }\n}\n\n"
- "impl<T, S, A: Allocator> "
- ", A: Allocator> IntoIterator for"
- "IntoIterator for HashSet<T, S, A"
- " HashSet<T, S, A> {\n"
- "    type Item = T;\n"
- "    type IntoIter = IntoIter<T, "
- " = IntoIter<T, A>;\n\n"
- "    /// Creates a consuming "
- " a consuming iterator, that is, "
- ", that is, one that moves each "
- "that moves each value out\n"
- "    /// of the set in arbitrary "
- " in arbitrary order. "
- "The set cannot be used after "
- " be used after calling\n"
- "    /// this.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// let mut set = HashSet::"
- " set = HashSet::new();\n"
- "    /// set.insert(\"a\".to_string"
- "(\"a\".to_string());\n"
- "    /// set.insert(\"b\".to_string"
- "(\"b\".to_string());\n    ///\n"
- "    /// // Not possible to "
- Not possible to collect to a Vec
- "collect to a Vec<String> with a "
- "<String> with a regular `.iter()"
- "regular `.iter()`.\n"
- "    /// let v: Vec<String> = "
- ": Vec<String> = set.into_iter()."
- "set.into_iter().collect();\n"
- "    ///\n"
- "    /// // Will print in an "
- " print in an arbitrary order.\n"
- "    /// for x in &v {\n"
- "    ///     println!(\"{}\", x);\n"
- "    /// }\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn into_iter(self) -> "
- "(self) -> IntoIter<T, A> {\n"
- "        IntoIter {\n"
- "            iter: "
- "iter: self.map.into_iter(),\n"
- "        }\n    }\n}\n\n"
- "impl<K> Clone for Iter<'_, K> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn clone(&self) -> Self {\n"
- "        Iter {\n"
- "            iter: "
- "iter: self.iter.clone(),\n"
- "        }\n    }\n}\n"
- "impl<'a, K> Iterator for Iter<'a"
- " for Iter<'a, K> {\n"
- "    type Item = &'a K;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<&'a K> {\n"
- "        self.iter.next()\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        self.iter.size_hint()\n"
- "    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, f)\n"
- "    }\n}\n"
- "impl<'a, K> ExactSizeIterator "
- " for Iter<'a, K> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn len(&self) -> usize {\n"
- "        self.iter.len()\n    }\n}\n"
- "impl<K> FusedIterator for Iter<'"
- " for Iter<'_, K> {}\n\n"
- "impl<K: fmt::Debug> fmt::Debug "
- "> fmt::Debug for Iter<'_, K> {\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_list().entries("
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}\n\n"
- "impl<K, A: Allocator> Iterator "
- "> Iterator for IntoIter<K, A> {\n"
- "    type Item = K;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<K> {\n"
- "        // Avoid `Option::map` "
- " `Option::map` because it bloats"
- " it bloats LLVM IR.\n"
- "        match self.iter.next() {"
- "() {\n"
- "            Some((k, _)) => Some"
- "((k, _)) => Some(k),\n"
- "            None => None,\n"
- "        }\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        self.iter.size_hint()\n"
- "    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, mut f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, |"
- "(init, |acc, (k, ())| f(acc, k))"
- " ())| f(acc, k))\n    }\n}\n"
- "impl<K, A: Allocator> "
- " A: Allocator> ExactSizeIterator"
- " for IntoIter<K, A> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn len(&self) -> usize {\n"
- "        self.iter.len()\n    }\n}\n"
- "impl<K, A: Allocator> "
- ", A: Allocator> FusedIterator "
- "> FusedIterator for IntoIter<K, "
- "for IntoIter<K, A> {}\n\n"
- "impl<K: fmt::Debug, A: Allocator"
- ", A: Allocator> fmt::Debug for "
- " fmt::Debug for IntoIter<K, A> {"
- "IntoIter<K, A> {\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        let entries_iter = "
- " entries_iter = self.iter.iter()"
- "self.iter.iter().map(|(k, _)| k)"
- ".map(|(k, _)| k);\n"
- "        f.debug_list().entries("
- ().entries(entries_iter).finish(
- ").finish()\n    }\n}\n\n"
- "impl<K, A: Allocator> Iterator "
- "> Iterator for Drain<'_, K, A> {"
- "<'_, K, A> {\n    type Item = K;\n"
- "\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<K> {\n"
- "        // Avoid `Option::map` "
- " `Option::map` because it bloats"
- " it bloats LLVM IR.\n"
- "        match self.iter.next() {"
- "() {\n"
- "            Some((k, _)) => Some"
- "((k, _)) => Some(k),\n"
- "            None => None,\n"
- "        }\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        self.iter.size_hint()\n"
- "    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, mut f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, |"
- "(init, |acc, (k, ())| f(acc, k))"
- " ())| f(acc, k))\n    }\n}\n"
- "impl<K, A: Allocator> "
- " A: Allocator> ExactSizeIterator"
- " for Drain<'_, K, A> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn len(&self) -> usize {\n"
- "        self.iter.len()\n    }\n}\n"
- "impl<K, A: Allocator> "
- ", A: Allocator> FusedIterator "
- "> FusedIterator for Drain<'_, K,"
- "for Drain<'_, K, A> {}\n\n"
- "impl<K: fmt::Debug, A: Allocator"
- ", A: Allocator> fmt::Debug for "
- " fmt::Debug for Drain<'_, K, A> "
- "Drain<'_, K, A> {\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        let entries_iter = "
- " entries_iter = self.iter.iter()"
- "self.iter.iter().map(|(k, _)| k)"
- ".map(|(k, _)| k);\n"
- "        f.debug_list().entries("
- ().entries(entries_iter).finish(
- ").finish()\n    }\n}\n\n"
- "impl<K, F, A: Allocator> "
- ", A: Allocator> Iterator for "
- "> Iterator for ExtractIf<'_, K, "
- "<'_, K, F, A>\nwhere\n"
- "where\n    F: FnMut(&K) -> bool,\n"
- "{\n    type Item = K;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<Self::Item> {\n"
- "        self.inner\n"
- "            .next(|&mut (ref k, "
- "(|&mut (ref k, ())| (self.f)(k))"
- "))| (self.f)(k))\n"
- "            .map(|(k, ())| k)\n"
- "    }\n\n    #[inline]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        (0, "
- "(0, self.inner.iter.size_hint()."
- "().1)\n    }\n}\n\n"
- "impl<K, F, A: Allocator> "
- ", A: Allocator> FusedIterator "
- "> FusedIterator for ExtractIf<'_"
- "for ExtractIf<'_, K, F, A> where"
- ", K, F, A> where F: FnMut(&K) ->"
- " F: FnMut(&K) -> bool {}\n\n"
- "impl<T, S, A: Allocator> Clone "
- "> Clone for Intersection<'_, T, "
- "<'_, T, S, A> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn clone(&self) -> Self {\n"
- "        Intersection {\n"
- "            iter: "
- "iter: self.iter.clone(),\n"
- "            ..*self\n        }\n"
- "        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- "A> Iterator for Intersection<'a,"
- "Intersection<'a, T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "{\n    type Item = &'a T;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<&'a T> {\n"
- "        loop {\n"
- "            let elt = "
- "let elt = self.iter.next()?;\n"
- "            if "
- "if self.other.contains(elt) {\n"
- "                return Some(elt)"
- "return Some(elt);\n            }\n"
- "            }\n        }\n    }\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        let (_, upper) = "
- "(_, upper) = self.iter.size_hint"
- "();\n        (0, upper)\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, mut f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, |"
- "(init, |acc, elt| {\n"
- "            if "
- "if self.other.contains(elt) {\n"
- "                f(acc, elt)\n"
- "            } else {\n"
- "                acc\n"
- "            }\n        })\n    }\n"
- "    }\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " fmt::Debug for Intersection<'_,"
- "Intersection<'_, T, S, A>\nwhere\n"
- "    T: fmt::Debug + Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_list().entries("
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for Intersection<'_, T, S, A>\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A: Allocator> Clone "
- "> Clone for Difference<'_, T, S,"
- "<'_, T, S, A> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn clone(&self) -> Self {\n"
- "        Difference {\n"
- "            iter: "
- "iter: self.iter.clone(),\n"
- "            ..*self\n        }\n"
- "        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- "A> Iterator for Difference<'a, T"
- "Difference<'a, T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "{\n    type Item = &'a T;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<&'a T> {\n"
- "        loop {\n"
- "            let elt = "
- "let elt = self.iter.next()?;\n"
- ";\n            if !"
- "self.other.contains(elt) {\n"
- "                return Some(elt)"
- "return Some(elt);\n            }\n"
- "            }\n        }\n    }\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        let (_, upper) = "
- "(_, upper) = self.iter.size_hint"
- "();\n        (0, upper)\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, mut f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, |"
- "(init, |acc, elt| {\n"
- "            if "
- "if self.other.contains(elt) {\n"
- "                acc\n"
- "            } else {\n"
- "                f(acc, elt)\n"
- "            }\n        })\n    }\n"
- "    }\n}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for Difference<'_, T, S, A>\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " fmt::Debug for Difference<'_, T"
- "Difference<'_, T, S, A>\nwhere\n"
- "    T: fmt::Debug + Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_list().entries("
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}\n\n"
- "impl<T, S, A: Allocator> Clone "
- "> Clone for SymmetricDifference<"
- "<'_, T, S, A> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn clone(&self) -> Self {\n"
- "        SymmetricDifference {\n"
- "            iter: "
- "iter: self.iter.clone(),\n"
- "        }\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- Iterator for SymmetricDifference
- "<'a, T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "{\n    type Item = &'a T;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<&'a T> {\n"
- "        self.iter.next()\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        self.iter.size_hint()\n"
- "    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, f)\n"
- "    }\n}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for SymmetricDifference<'_, T, "
- "<'_, T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- "::Debug for SymmetricDifference<"
- "<'_, T, S, A>\nwhere\n"
- "    T: fmt::Debug + Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_list().entries("
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}\n\n"
- "impl<T, S, A: Allocator> Clone "
- "> Clone for Union<'_, T, S, A> {"
- "<'_, T, S, A> {\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn clone(&self) -> Self {\n"
- "        Union {\n"
- "            iter: "
- "iter: self.iter.clone(),\n"
- "        }\n    }\n}\n\n"
- "impl<T, S, A> FusedIterator for "
- " for Union<'_, T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n}\n\n"
- "impl<T, S, A> fmt::Debug for "
- " fmt::Debug for Union<'_, T, S, "
- "Union<'_, T, S, A>\nwhere\n"
- "    T: fmt::Debug + Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_list().entries("
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}\n\n"
- "impl<'a, T, S, A> Iterator for "
- "A> Iterator for Union<'a, T, S, "
- "Union<'a, T, S, A>\nwhere\n"
- "where\n    T: Eq + Hash,\n"
- "    S: BuildHasher,\n"
- "    A: Allocator,\n{\n"
- "{\n    type Item = &'a T;\n\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn next(&mut self) -> Option"
- " self) -> Option<&'a T> {\n"
- "        self.iter.next()\n    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn size_hint(&self) -> ("
- "(&self) -> (usize, Option<usize>"
- ", Option<usize>) {\n"
- "        self.iter.size_hint()\n"
- "    }\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    fn fold<B, F>(self, init: B,"
- ">(self, init: B, f: F) -> B\n"
- "    where\n        Self: Sized,\n"
- "        F: FnMut(B, Self::Item) "
- "(B, Self::Item) -> B,\n    {\n"
- "        self.iter.fold(init, f)\n"
- "    }\n}\n\n"
- "/// A view into a single entry "
- " a single entry in a set, which "
- "in a set, which may either be "
- " may either be vacant or "
- " be vacant or occupied.\n///\n"
- "/// This `enum` is constructed "
- " is constructed from the [`entry"
- "from the [`entry`] method on [`"
- "`] method on [`HashSet`].\n///\n"
- "/// [`HashSet`]: "
- "[`HashSet`]: struct.HashSet.html"
- "\n"
- "/// [`entry`]: "
- "/ [`entry`]: struct.HashSet.html"
- "#method.entry\n///\n"
- "///\n/// # Examples\n///\n/// ```\n"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet, "
- "Entry, HashSet, OccupiedEntry};\n"
- "///\n"
- "/// let mut set = HashSet::new()"
- "= HashSet::new();\n"
- "/// set.extend([\"a\", \"b\", \"c\"]);"
- "\"a\", \"b\", \"c\"]);\n/// assert_eq!("
- "/// assert_eq!(set.len(), 3);\n"
- "set.len(), 3);\n///\n"
- "/// // Existing value (insert)\n"
- "/// let entry: Entry<_, _> = "
- ": Entry<_, _> = set.entry(\"a\");\n"
- "/// let _raw_o: OccupiedEntry<_,"
- "OccupiedEntry<_, _> = "
- "<_, _> = entry.insert();\n"
- "/// assert_eq!(set.len(), 3);\n"
- /// // Nonexistent value (insert
- " value (insert)\n"
- "/// set.entry(\"d\").insert();\n"
- "///\n"
- /// // Existing value (or_insert
- "value (or_insert)\n"
- "/// set.entry(\"b\").or_insert();\n"
- /// // Nonexistent value (
- " value (or_insert)\n"
- "/// set.entry(\"e\").or_insert();\n"
- "///\n/// println!(\""
- "Our HashSet: {:?}\", set);\n///\n"
- "/// let mut vec: Vec<_> = "
- " vec: Vec<_> = set.iter().copied"
- "().copied().collect();\n"
- "/// // The `Iter` iterator "
- "`Iter` iterator produces items "
- " produces items in arbitrary "
- " in arbitrary order, so the\n"
- "/// // items must be sorted to "
- " be sorted to test them against "
- " them against a sorted array.\n"
- "/// vec.sort_unstable();\n"
- /// assert_eq!(
- "vec, [\"a\", \"b\", \"c\", \"d\", \"e\"]);"
- "\"c\", \"d\", \"e\"]);\n/// ```\n"
- "pub enum Entry<'a, T, S, A = "
- "<'a, T, S, A = Global>\nwhere\n"
- "where\n    A: Allocator,\n{\n"
- "{\n    /// An occupied entry.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::{Entry, HashSet};\n"
- "    /// let mut set: HashSet<_> "
- "set: HashSet<_> = [\"a\", \"b\"]."
- "_> = [\"a\", \"b\"].into();\n    ///\n"
- "    /// match set.entry(\"a\") {\n"
- "    ///     Entry::Vacant(_) => "
- "::Vacant(_) => unreachable!(),\n"
- "    ///     Entry::Occupied(_) ="
- "::Occupied(_) => { }\n    /// }\n"
- "    /// }\n    /// ```\n"
- "    Occupied(OccupiedEntry<'a, T"
- "<'a, T, S, A>),\n\n"
- "\n    /// A vacant entry.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::{Entry, HashSet};\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n    ///\n"
- "    /// match set.entry(\"a\") {\n"
- "    ///     Entry::Occupied(_) ="
- "::Occupied(_) => unreachable!(),"
- " unreachable!(),\n"
- "    ///     Entry::Vacant(_) => "
- "::Vacant(_) => { }\n    /// }\n"
- "    /// }\n    /// ```\n"
- "    Vacant(VacantEntry<'a, T, S,"
- "<'a, T, S, A>),\n}\n\n"
- "impl<T: fmt::Debug, S, A: "
- "::Debug, S, A: Allocator> fmt::"
- "Allocator> fmt::Debug for Entry<"
- "Debug for Entry<'_, T, S, A> {\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        match *self {\n"
- "            Entry::Vacant(ref v)"
- "::Vacant(ref v) => f.debug_tuple"
- "=> f.debug_tuple(\"Entry\").field("
- "(\"Entry\").field(v).finish(),\n"
- "            Entry::Occupied(ref "
- "::Occupied(ref o) => "
- "(ref o) => f.debug_tuple(\"Entry\""
- "(\"Entry\").field(o).finish(),\n"
- "        }\n    }\n}\n\n"
- "/// A view into an occupied "
- " an occupied entry in a `HashSet"
- " in a `HashSet`.\n"
- "/// It is part of the [`Entry`] "
- " the [`Entry`] enum.\n///\n"
- "/// [`Entry`]: enum.Entry.html\n"
- "///\n/// # Examples\n///\n/// ```\n"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet, "
- "Entry, HashSet, OccupiedEntry};\n"
- "///\n"
- "/// let mut set = HashSet::new()"
- "= HashSet::new();\n"
- "/// set.extend([\"a\", \"b\", \"c\"]);"
- "\"a\", \"b\", \"c\"]);\n///\n"
- "/// let _entry_o: OccupiedEntry<"
- ": OccupiedEntry<_, _> = "
- "<_, _> = set.entry(\"a\").insert()"
- "(\"a\").insert();\n/// assert_eq!("
- "/// assert_eq!(set.len(), 3);\n"
- "set.len(), 3);\n///\n"
- "///\n/// // Existing key\n"
- "/// match set.entry(\"a\") {\n"
- "///     Entry::Vacant(_) => "
- "::Vacant(_) => unreachable!(),\n"
- "///     Entry::Occupied(view) =>"
- "(view) => {\n"
- ///         assert_eq!(
- "view.get(), &\"a\");\n///     }\n"
- "///     }\n/// }\n///\n"
- "/// }\n///\n/// assert_eq!("
- "/// assert_eq!(set.len(), 3);\n"
- "set.len(), 3);\n///\n"
- "///\n/// // Existing key (take)\n"
- "/// match set.entry(\"c\") {\n"
- "///     Entry::Vacant(_) => "
- "::Vacant(_) => unreachable!(),\n"
- "///     Entry::Occupied(view) =>"
- "(view) => {\n"
- ///         assert_eq!(
- "view.remove(), \"c\");\n///     }\n"
- "///     }\n/// }\n/// assert_eq!("
- "set.get(&\"c\"), None);\n"
- "/// assert_eq!(set.len(), 2);\n"
- "set.len(), 2);\n/// ```\n"
- "pub struct OccupiedEntry<'a, T, "
- "<'a, T, S, A: Allocator = Global"
- " = Global> {\n"
- "    inner: map::OccupiedEntry<'a"
- "OccupiedEntry<'a, T, (), S, A>,\n"
- "}\n\n"
- "impl<T: fmt::Debug, S, A: "
- "::Debug, S, A: Allocator> fmt::"
- "Allocator> fmt::Debug for "
- " fmt::Debug for OccupiedEntry<'_"
- "OccupiedEntry<'_, T, S, A> {\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_struct(\""
- "f.debug_struct(\"OccupiedEntry\")\n"
- "            .field(\"value\", "
- ".field(\"value\", self.get())\n"
- "            .finish()\n    }\n}\n\n"
- "/// A view into a vacant entry "
- " a vacant entry in a `HashSet`.\n"
- "/// It is part of the [`Entry`] "
- " the [`Entry`] enum.\n///\n"
- "/// [`Entry`]: enum.Entry.html\n"
- "///\n/// # Examples\n///\n/// ```\n"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet, "
- "Entry, HashSet, VacantEntry};\n"
- "///\n"
- "/// let mut set = HashSet::<&str"
- "= HashSet::<&str>::new();\n///\n"
- "/// let entry_v: VacantEntry<_, "
- " VacantEntry<_, _> = match "
- "<_, _> = match set.entry(\"a\") {\n"
- "///     Entry::Vacant(view) => "
- "Vacant(view) => view,\n"
- "///     Entry::Occupied(_) => "
- ":Occupied(_) => unreachable!(),\n"
- "/// };\n/// entry_v.insert();\n"
- /// assert!(
- "set.contains(\"a\") && set.len() ="
- ") && set.len() == 1);\n///\n"
- "/// // Nonexistent key (insert)\n"
- "/// match set.entry(\"b\") {\n"
- "///     Entry::Vacant(view) => {"
- "(view) => { view.insert(); },\n"
- "///     Entry::Occupied(_) => "
- ":Occupied(_) => unreachable!(),\n"
- "/// }\n/// assert!("
- "set.contains(\"b\") && set.len() ="
- ") && set.len() == 2);\n/// ```\n"
- "pub struct VacantEntry<'a, T, S,"
- "<'a, T, S, A: Allocator = Global"
- " = Global> {\n"
- "    inner: map::VacantEntry<'a, "
- "VacantEntry<'a, T, (), S, A>,\n}\n"
- "}\n\n"
- "impl<T: fmt::Debug, S, A: "
- "::Debug, S, A: Allocator> fmt::"
- "Allocator> fmt::Debug for "
- " fmt::Debug for VacantEntry<'_, "
- "VacantEntry<'_, T, S, A> {\n"
- "    fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {\n"
- "        f.debug_tuple(\""
- "f.debug_tuple(\"VacantEntry\")."
- "(\"VacantEntry\").field(self.get()"
- "field(self.get()).finish()\n"
- "    }\n}\n\n"
- "impl<'a, T, S, A: Allocator> "
- ", A: Allocator> Entry<'a, T, S, "
- "Entry<'a, T, S, A> {\n"
- "    /// Sets the value of the "
- " value of the entry, and returns"
- ", and returns an OccupiedEntry.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n"
- "    /// let entry = set.entry(\""
- " = set.entry(\"horseyland\")."
- "(\"horseyland\").insert();\n"
- "    ///\n    /// assert_eq!("
- "entry.get(), &\"horseyland\");\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn insert(self) -> "
- "insert(self) -> OccupiedEntry<'a"
- "OccupiedEntry<'a, T, S, A>\n"
- "    where\n        T: Hash,\n"
- "        S: BuildHasher,\n    {\n"
- "    {\n        match self {\n"
- "            Entry::Occupied("
- "Entry::Occupied(entry) => entry,"
- "entry) => entry,\n"
- "            Entry::Vacant(entry)"
- "::Vacant(entry) => entry.insert("
- "=> entry.insert(),\n        }\n"
- "        }\n    }\n\n"
- "    /// Ensures a value is in "
- " a value is in the entry by "
- "in the entry by inserting if it "
- "inserting if it was vacant.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n    ///\n"
- "    /// // nonexistent key\n"
- "    /// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n"
- "    /// assert!("
- "set.contains(\"poneyland\"));\n"
- "    ///\n    /// // existing key\n"
- "    /// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n"
- "    /// assert!("
- "set.contains(\"poneyland\"));\n"
- "    /// assert_eq!("
- "set.len(), 1);\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn or_insert(self)\n"
- "    where\n        T: Hash,\n"
- "        S: BuildHasher,\n    {\n"
- "        if let Entry::Vacant("
- " Entry::Vacant(entry) = self {\n"
- "            entry.insert();\n"
- "        }\n    }\n\n"
- "    /// Returns a reference to "
- " a reference to this entry's "
- "to this entry's value.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n"
- "    /// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n"
- "    /// // existing key\n"
- "    /// assert_eq!("
- "set.entry(\"poneyland\").get(), &\""
- "\").get(), &\"poneyland\");\n"
- "    /// // nonexistent key\n"
- "    /// assert_eq!("
- "set.entry(\"horseland\").get(), &\""
- "\").get(), &\"horseland\");\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn get(&self) -> &T {\n"
- "        match *self {\n"
- "            Entry::Occupied(ref "
- "::Occupied(ref entry) => "
- "(ref entry) => entry.get(),\n"
- "            Entry::Vacant(ref "
- "::Vacant(ref entry) => entry.get"
- ") => entry.get(),\n        }\n"
- "        }\n    }\n}\n\n"
- "impl<T, S, A: Allocator> "
- ", A: Allocator> OccupiedEntry<'_"
- "OccupiedEntry<'_, T, S, A> {\n"
- "    /// Gets a reference to the "
- " to the value in the entry.\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::{Entry, HashSet};\n"
- "    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n"
- "    /// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n"
- "    ///\n"
- "    /// match set.entry(\""
- " set.entry(\"poneyland\") {\n"
- "    ///     Entry::Vacant(_) => "
- "::Vacant(_) => panic!(),\n"
- "    ///     Entry::Occupied("
- "Entry::Occupied(entry) => "
- (entry) => assert_eq!(
- "entry.get(), &\"poneyland\"),\n"
- "    /// }\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn get(&self) -> &T {\n"
- "        self.inner.key()\n    }\n\n"
- "    /// Takes the value out of "
- " value out of the entry, and "
- " the entry, and returns it.\n"
- "    /// Keeps the allocated "
- " the allocated memory for reuse."
- " for reuse.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::Entry;\n    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n"
- "    /// // The set is empty\n"
- "    /// assert!("
- set.is_empty() && set.capacity()
- "& set.capacity() == 0);\n    ///\n"
- "    /// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();\n"
- "    /// let "
- /// let capacity_before_remove =
- " = set.capacity();\n    ///\n"
- "    /// if let Entry::Occupied(o"
- "::Occupied(o) = set.entry(\""
- "o) = set.entry(\"poneyland\") {\n"
- "    ///     assert_eq!("
- "o.remove(), \"poneyland\");\n"
- "    /// }\n    ///\n"
- "    ///\n    /// assert_eq!("
- "set.contains(\"poneyland\"), false"
- "\"), false);\n"
- "    /// // Now set hold none "
- " set hold none elements but "
- " elements but capacity is equal "
- " is equal to the old one\n"
- "    /// assert!("
- set.len() == 0 && set.capacity()
- "& set.capacity() == "
- "() == capacity_before_remove);\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn remove(self) -> T {\n"
- "        self.inner.remove_entry("
- "().0\n    }\n\n"
- "    /// Replaces the entry, "
- " the entry, returning the old "
- " the old value. "
- "The new value in the hash map "
- "in the hash map will be\n"
- "    /// the value used to create"
- " used to create this entry.\n"
- "    ///\n    /// # Panics\n"
- "    ///\n"
- "    /// Will panic if this "
- " panic if this OccupiedEntry was"
- " was created through [`Entry::"
- " [`Entry::insert`].\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    ///  use hashbrown::hash_set"
- "::hash_set::{Entry, HashSet};\n"
- "    ///  use std::rc::Rc;\n"
- "    ///\n"
- "    ///  let mut set: HashSet<Rc"
- " set: HashSet<Rc<String>> = "
- "<Rc<String>> = HashSet::new();\n"
- "    ///  let key_one = Rc::new(\""
- " = Rc::new(\"Stringthing\"."
- "(\"Stringthing\".to_string());\n"
- "    ///  let key_two = Rc::new(\""
- " = Rc::new(\"Stringthing\"."
- "(\"Stringthing\".to_string());\n"
- "    ///\n"
- "    ///  set.insert("
- ///  set.insert(key_one.clone())
- "key_one.clone());\n"
- "    ///  assert!("
- "Rc::strong_count(&key_one) == 2 "
- "(&key_one) == 2 && Rc::"
- ") == 2 && Rc::strong_count(&"
- "::strong_count(&key_two) == 1);\n"
- "    ///\n"
- "    ///  match set.entry("
- match set.entry(key_two.clone())
- "key_two.clone()) {\n"
- "    ///      Entry::Occupied("
- "Entry::Occupied(entry) => {\n"
- "    ///          let old_key: Rc"
- "let old_key: Rc<String> = "
- ": Rc<String> = entry.replace();\n"
- "    ///          assert!("
- "Rc::ptr_eq(&key_one, &old_key));"
- ", &old_key));\n    ///      }\n"
- "    ///      Entry::Vacant(_) =>"
- "::Vacant(_) => panic!(),\n"
- "    ///  }\n    ///\n"
- "    ///\n    ///  assert!("
- "Rc::strong_count(&key_one) == 1 "
- "(&key_one) == 1 && Rc::"
- ") == 1 && Rc::strong_count(&"
- "::strong_count(&key_two) == 2);\n"
- "    ///  assert!("
- "set.contains(&\"Stringthing\"."
- "(&\"Stringthing\".to_owned()));\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn replace(self) -> T {\n"
- "        self.inner.replace_key()"
- "()\n    }\n}\n\n"
- "impl<'a, T, S, A: Allocator> "
- ", A: Allocator> VacantEntry<'a, "
- "VacantEntry<'a, T, S, A> {\n"
- "    /// Gets a reference to the "
- " to the value that would be used"
- " would be used when inserting\n"
- "    /// through the `VacantEntry"
- "the `VacantEntry`.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n"
- "    /// assert_eq!("
- "set.entry(\"poneyland\").get(), &\""
- "\").get(), &\"poneyland\");\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn get(&self) -> &T {\n"
- "        self.inner.key()\n    }\n\n"
- "    /// Take ownership of the "
- " of the value.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::{Entry, HashSet};\n"
- "    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n    ///\n"
- "    /// match set.entry(\""
- " set.entry(\"poneyland\") {\n"
- "    ///     Entry::Occupied(_) ="
- "::Occupied(_) => panic!(),\n"
- "    ///     Entry::Vacant(v) => "
- "::Vacant(v) => assert_eq!("
- "v.into_value(), \"poneyland\"),\n"
- "    /// }\n    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn into_value(self) -> T"
- "(self) -> T {\n"
- "        self.inner.into_key()\n"
- "    }\n\n"
- "    /// Sets the value of the "
- " value of the entry with the "
- " entry with the VacantEntry's "
- " VacantEntry's value.\n    ///\n"
- "    ///\n    /// # Examples\n"
- "    ///\n    /// ```\n"
- "    /// use hashbrown::HashSet;\n"
- "    /// use hashbrown::hash_set:"
- "::hash_set::Entry;\n    ///\n"
- "    /// let mut set: HashSet<&"
- " set: HashSet<&str> = HashSet::"
- "str> = HashSet::new();\n    ///\n"
- "    /// if let Entry::Vacant(o) "
- "::Vacant(o) = set.entry(\""
- "o) = set.entry(\"poneyland\") {\n"
- "    ///     o.insert();\n"
- "    /// }\n    /// assert!("
- "set.contains(\"poneyland\"));\n"
- "    /// ```\n"
- "    #[cfg_attr(feature = \"inline"
- " = \"inline-more\", inline)]\n"
- "    pub fn insert(self) -> "
- "insert(self) -> OccupiedEntry<'a"
- "OccupiedEntry<'a, T, S, A>\n"
- "    where\n        T: Hash,\n"
- "        S: BuildHasher,\n    {\n"
- "    {\n        OccupiedEntry {\n"
- "            inner: "
- "inner: self.inner.insert_entry(("
- "(()),\n        }\n    }\n}\n\n"
- "    }\n}\n\n#[allow(dead_code)]\n"
- "fn assert_covariance() {\n"
- "    fn set<'new>(v: HashSet<&'"
- ">(v: HashSet<&'static str>) -> "
- "static str>) -> HashSet<&'new "
- "> HashSet<&'new str> {\n"
- "        v\n    }\n"
- "    fn iter<'a, 'new>(v: Iter<'a"
- "'new>(v: Iter<'a, &'static str>)"
- ", &'static str>) -> Iter<'a, &'"
- ") -> Iter<'a, &'new str> {\n"
- "        v\n    }\n"
- "    fn into_iter<'new, A: "
- "<'new, A: Allocator>(v: IntoIter"
- ">(v: IntoIter<&'static str, A>) "
- "static str, A>) -> IntoIter<&'"
- ") -> IntoIter<&'new str, A> {\n"
- "        v\n    }\n"
- "    fn difference<'a, 'new, A: "
- "<'a, 'new, A: Allocator>(\n"
- "        v: Difference<'a, &'"
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n"
- "    ) -> Difference<'a, &'new "
- "<'a, &'new str, "
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }\n"
- "    fn symmetric_difference<'a, "
- "<'a, 'new, A: Allocator>(\n"
- "        v: SymmetricDifference<'"
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n"
- "    ) -> SymmetricDifference<'a,"
- "<'a, &'new str, "
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }\n"
- "    fn intersection<'a, 'new, A:"
- "<'a, 'new, A: Allocator>(\n"
- "        v: Intersection<'a, &'"
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n"
- "    ) -> Intersection<'a, &'new "
- "<'a, &'new str, "
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }\n"
- "    fn union<'a, 'new, A: "
- "<'a, 'new, A: Allocator>(\n"
- "        v: Union<'a, &'static "
- "<'a, &'static str, "
- "&'static str, DefaultHashBuilder"
- ", A>,\n"
- "    ) -> Union<'a, &'new str, "
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }\n"
- "    fn drain<'new, A: Allocator>"
- ", A: Allocator>(d: Drain<'static"
- "d: Drain<'static, &'static str, "
- ", &'static str, A>) -> Drain<'"
- ", A>) -> Drain<'new, &'new str, "
- "new, &'new str, A> {\n        d\n"
- "        d\n    }\n}\n\n#[cfg(test)]\n"
- "}\n\n#[cfg(test)]\nmod test_set {\n"
- "    use super::super::map::"
- "::super::map::DefaultHashBuilder"
- ";\n    use super::HashSet;\n"
- "    use std::vec::Vec;\n\n"
- "\n    #[test]\n"
- "    fn test_zero_capacities() {\n"
- "        type HS = HashSet<i32>;\n"
- "\n        let s = HS::new();\n"
- "        assert_eq!("
- "s.capacity(), 0);\n\n"
- "\n        let s = HS::default();\n"
- "        assert_eq!("
- "s.capacity(), 0);\n\n"
- "        let s = HS::with_hasher("
- "::with_hasher(DefaultHashBuilder"
- "::default());\n"
- "        assert_eq!("
- "s.capacity(), 0);\n\n"
- "        let s = HS::"
- "let s = HS::with_capacity(0);\n"
- "        assert_eq!("
- "s.capacity(), 0);\n\n"
- "        let s = HS::"
- "s = HS::with_capacity_and_hasher"
- "(0, DefaultHashBuilder::default("
- "::default());\n"
- "        assert_eq!("
- "s.capacity(), 0);\n\n"
- "\n        let mut s = HS::new();\n"
- "        s.insert(1);\n"
- "        s.insert(2);\n"
- "        s.remove(&1);\n"
- "        s.remove(&2);\n"
- "        s.shrink_to_fit();\n"
- "        assert_eq!("
- "s.capacity(), 0);\n\n"
- "\n        let mut s = HS::new();\n"
- "        s.reserve(0);\n"
- "        assert_eq!("
- "s.capacity(), 0);\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_disjoint() {\n"
- "        let mut xs = HashSet::"
- " xs = HashSet::new();\n"
- "        let mut ys = HashSet::"
- " ys = HashSet::new();\n"
- "        assert!("
- "xs.is_disjoint(&ys));\n"
- "        assert!("
- "ys.is_disjoint(&xs));\n"
- "        assert!(xs.insert(5));\n"
- "xs.insert(5));\n        assert!("
- "        assert!(ys.insert(11));\n"
- "ys.insert(11));\n        assert!("
- "xs.is_disjoint(&ys));\n"
- "        assert!("
- "ys.is_disjoint(&xs));\n"
- "        assert!(xs.insert(7));\n"
- "xs.insert(7));\n        assert!("
- "        assert!(xs.insert(19));\n"
- "xs.insert(19));\n        assert!("
- "        assert!(xs.insert(4));\n"
- "xs.insert(4));\n        assert!("
- "        assert!(ys.insert(2));\n"
- "ys.insert(2));\n        assert!("
- "ys.insert(-11));\n"
- "        assert!("
- "xs.is_disjoint(&ys));\n"
- "        assert!("
- "ys.is_disjoint(&xs));\n"
- "        assert!(ys.insert(7));\n"
- "ys.insert(7));\n        assert!(!"
- "xs.is_disjoint(&ys));\n"
- "        assert!(!"
- "ys.is_disjoint(&xs));\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_subset_and_superset("
- "() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        assert!(a.insert(0));\n"
- "a.insert(0));\n        assert!("
- "        assert!(a.insert(5));\n"
- "a.insert(5));\n        assert!("
- "        assert!(a.insert(11));\n"
- "a.insert(11));\n        assert!("
- "        assert!(a.insert(7));\n\n"
- "        let mut b = HashSet::new"
- "b = HashSet::new();\n"
- "        assert!(b.insert(0));\n"
- "b.insert(0));\n        assert!("
- "        assert!(b.insert(7));\n"
- "b.insert(7));\n        assert!("
- "        assert!(b.insert(19));\n"
- "b.insert(19));\n        assert!("
- "        assert!(b.insert(250));\n"
- "b.insert(250));\n        assert!("
- "        assert!(b.insert(11));\n"
- "b.insert(11));\n        assert!("
- "        assert!(b.insert(200));\n"
- "b.insert(200));\n\n"
- "\n        assert!(!"
- "a.is_subset(&b));\n"
- "        assert!(!"
- "a.is_superset(&b));\n"
- "        assert!(!"
- "b.is_subset(&a));\n"
- "        assert!(!"
- "b.is_superset(&a));\n\n"
- "\n        assert!(b.insert(5));\n\n"
- "b.insert(5));\n\n        assert!("
- "a.is_subset(&b));\n"
- "        assert!(!"
- "a.is_superset(&b));\n"
- "        assert!(!"
- "b.is_subset(&a));\n"
- "        assert!("
- "b.is_superset(&a));\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_iterate() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        for i in 0..32 {\n"
- "            assert!("
- "a.insert(i));\n        }\n"
- "        let mut observed: u32 = "
- "observed: u32 = 0;\n"
- "        for k in &a {\n"
- "            observed |= 1 << *k;"
- " |= 1 << *k;\n        }\n"
- "        }\n        assert_eq!("
- "observed, 0xFFFF_FFFF);\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_intersection() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        let mut b = HashSet::new"
- "b = HashSet::new();\n\n"
- "\n        assert!(a.insert(11));\n"
- "a.insert(11));\n        assert!("
- "        assert!(a.insert(1));\n"
- "a.insert(1));\n        assert!("
- "        assert!(a.insert(3));\n"
- "a.insert(3));\n        assert!("
- "        assert!(a.insert(77));\n"
- "a.insert(77));\n        assert!("
- "        assert!(a.insert(103));\n"
- "a.insert(103));\n        assert!("
- "        assert!(a.insert(5));\n"
- "a.insert(5));\n        assert!("
- "        assert!(a.insert(-5));\n\n"
- "a.insert(-5));\n\n        assert!("
- "        assert!(b.insert(2));\n"
- "b.insert(2));\n        assert!("
- "        assert!(b.insert(11));\n"
- "b.insert(11));\n        assert!("
- "        assert!(b.insert(77));\n"
- "b.insert(77));\n        assert!("
- "        assert!(b.insert(-9));\n"
- "b.insert(-9));\n        assert!("
- "        assert!(b.insert(-42));\n"
- "b.insert(-42));\n        assert!("
- "        assert!(b.insert(5));\n"
- "b.insert(5));\n        assert!("
- "        assert!(b.insert(3));\n\n"
- "\n        let mut i = 0;\n"
- "        let expected = [3, 5, 11"
- " = [3, 5, 11, 77];\n"
- "        for x in a.intersection("
- " a.intersection(&b) {\n"
- "            assert!("
- "expected.contains(x));\n"
- "            i += 1;\n        }\n"
- "        }\n        assert_eq!("
- "i, expected.len());\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_difference() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        let mut b = HashSet::new"
- "b = HashSet::new();\n\n"
- "\n        assert!(a.insert(1));\n"
- "a.insert(1));\n        assert!("
- "        assert!(a.insert(3));\n"
- "a.insert(3));\n        assert!("
- "        assert!(a.insert(5));\n"
- "a.insert(5));\n        assert!("
- "        assert!(a.insert(9));\n"
- "a.insert(9));\n        assert!("
- "        assert!(a.insert(11));\n\n"
- "a.insert(11));\n\n        assert!("
- "        assert!(b.insert(3));\n"
- "b.insert(3));\n        assert!("
- "        assert!(b.insert(9));\n\n"
- "\n        let mut i = 0;\n"
- "        let expected = [1, 5, 11"
- " = [1, 5, 11];\n"
- "        for x in a.difference(&b"
- " a.difference(&b) {\n"
- "            assert!("
- "expected.contains(x));\n"
- "            i += 1;\n        }\n"
- "        }\n        assert_eq!("
- "i, expected.len());\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_symmetric_difference"
- "() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        let mut b = HashSet::new"
- "b = HashSet::new();\n\n"
- "\n        assert!(a.insert(1));\n"
- "a.insert(1));\n        assert!("
- "        assert!(a.insert(3));\n"
- "a.insert(3));\n        assert!("
- "        assert!(a.insert(5));\n"
- "a.insert(5));\n        assert!("
- "        assert!(a.insert(9));\n"
- "a.insert(9));\n        assert!("
- "        assert!(a.insert(11));\n\n"
- "a.insert(11));\n\n        assert!("
- "        assert!(b.insert(-2));\n"
- "b.insert(-2));\n        assert!("
- "        assert!(b.insert(3));\n"
- "b.insert(3));\n        assert!("
- "        assert!(b.insert(9));\n"
- "b.insert(9));\n        assert!("
- "        assert!(b.insert(14));\n"
- "b.insert(14));\n        assert!("
- "        assert!(b.insert(22));\n\n"
- "\n        let mut i = 0;\n"
- "        let expected = [-2, 1, 5"
- " = [-2, 1, 5, 11, 14, 22];\n"
- "        for x in "
- for x in a.symmetric_difference(
- "(&b) {\n            assert!("
- "expected.contains(x));\n"
- "            i += 1;\n        }\n"
- "        }\n        assert_eq!("
- "i, expected.len());\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_union() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        let mut b = HashSet::new"
- "b = HashSet::new();\n\n"
- "\n        assert!(a.insert(1));\n"
- "a.insert(1));\n        assert!("
- "        assert!(a.insert(3));\n"
- "a.insert(3));\n        assert!("
- "        assert!(a.insert(5));\n"
- "a.insert(5));\n        assert!("
- "        assert!(a.insert(9));\n"
- "a.insert(9));\n        assert!("
- "        assert!(a.insert(11));\n"
- "a.insert(11));\n        assert!("
- "        assert!(a.insert(16));\n"
- "a.insert(16));\n        assert!("
- "        assert!(a.insert(19));\n"
- "a.insert(19));\n        assert!("
- "        assert!(a.insert(24));\n\n"
- "a.insert(24));\n\n        assert!("
- "        assert!(b.insert(-2));\n"
- "b.insert(-2));\n        assert!("
- "        assert!(b.insert(1));\n"
- "b.insert(1));\n        assert!("
- "        assert!(b.insert(5));\n"
- "b.insert(5));\n        assert!("
- "        assert!(b.insert(9));\n"
- "b.insert(9));\n        assert!("
- "        assert!(b.insert(13));\n"
- "b.insert(13));\n        assert!("
- "        assert!(b.insert(19));\n\n"
- "\n        let mut i = 0;\n"
- "        let expected = [-2, 1, 3"
- " = [-2, 1, 3, 5, 9, 11, 13, 16, "
- " 9, 11, 13, 16, 19, 24];\n"
- "        for x in a.union(&b) {\n"
- "            assert!("
- "expected.contains(x));\n"
- "            i += 1;\n        }\n"
- "        }\n        assert_eq!("
- "i, expected.len());\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_from_map() {\n"
- "        let mut a = crate::"
- " mut a = crate::HashMap::new();\n"
- "        a.insert(1, ());\n"
- "        a.insert(2, ());\n"
- "        a.insert(3, ());\n"
- "        a.insert(4, ());\n\n"
- "        let a: HashSet<_> = "
- "a: HashSet<_> = a.into();\n\n"
- "\n        assert_eq!("
- "a.len(), 4);\n        assert!("
- "a.contains(&1));\n"
- "        assert!("
- "a.contains(&2));\n"
- "        assert!("
- "a.contains(&3));\n"
- "        assert!("
- "a.contains(&4));\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_from_iter() {\n"
- "        let xs = [1, 2, 2, 3, 4,"
- " [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];"
- " 5, 6, 7, 8, 9];\n\n"
- "        let set: HashSet<_> = "
- ": HashSet<_> = xs.iter().copied("
- "().copied().collect();\n\n"
- "\n        for x in &xs {\n"
- "            assert!("
- "set.contains(x));\n        }\n\n"
- "        }\n\n        assert_eq!("
- "set.iter().len(), xs.len() - 1);"
- ", xs.len() - 1);\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_move_iter() {\n"
- "        let hs = {\n"
- "            let mut hs = HashSet"
- "mut hs = HashSet::new();\n\n"
- "\n            hs.insert('a');\n"
- "            hs.insert('b');\n\n"
- "\n            hs\n        };\n\n"
- "        let v = hs.into_iter()."
- " hs.into_iter().collect::<Vec<"
- ").collect::<Vec<char>>();\n"
- "        assert!("
- "v == ['a', 'b'] || v == ['b', 'a"
- "|| v == ['b', 'a']);\n    }\n\n"
- "    }\n\n    #[test]\n"
- "\n    #[test]\n    fn test_eq() {\n"
- "        // These constants once "
- " constants once happened to "
- " happened to expose a bug in "
- "expose a bug in insert().\n"
- "        // I'm keeping them "
- " keeping them around to prevent "
- " to prevent a regression.\n"
- "        let mut s1 = HashSet::"
- " s1 = HashSet::new();\n\n"
- "\n        s1.insert(1);\n"
- "        s1.insert(2);\n"
- "        s1.insert(3);\n\n"
- "        let mut s2 = HashSet::"
- " s2 = HashSet::new();\n\n"
- "\n        s2.insert(1);\n"
- "        s2.insert(2);\n\n"
- "\n        assert!(s1 != s2);\n\n"
- "= s2);\n\n        s2.insert(3);\n\n"
- "\n        assert_eq!(s1, s2);\n"
- "s1, s2);\n    }\n\n    #[test]\n"
- "    fn test_show() {\n"
- "        let mut set = HashSet::"
- " set = HashSet::new();\n"
- "        let empty = HashSet::<"
- " = HashSet::<i32>::new();\n\n"
- "\n        set.insert(1);\n"
- "        set.insert(2);\n\n"
- "        let set_str = format!(\"{"
- "set:?}\");\n\n        assert!("
- "set_str == \"{1, 2}\" || set_str ="
- "2}\" || set_str == \"{2, 1}\");\n"
- "        assert_eq!(format!(\"{"
- "format!(\"{empty:?}\"), \"{}\");\n"
- "    }\n\n    #[test]\n"
- "    fn test_trivial_drain() {\n"
- "        let mut s = HashSet::<"
- " s = HashSet::<i32>::new();\n"
- "        for _ in s.drain() {}\n"
- "        assert!(s.is_empty());\n"
- "s.is_empty());\n        drop(s);\n"
- "\n"
- "        let mut s = HashSet::<"
- " s = HashSet::<i32>::new();\n"
- "        drop(s.drain());\n"
- "        assert!(s.is_empty());\n"
- "s.is_empty());\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_drain() {\n"
- "        let mut s: HashSet<_> = "
- "s: HashSet<_> = (1..100).collect"
- "(1..100).collect();\n\n"
- "        // try this a bunch of "
- "this a bunch of times to make "
- " times to make sure we don't "
- " sure we don't screw up internal"
- " up internal state.\n"
- "        for _ in 0..20 {\n"
- "            assert_eq!("
- "s.len(), 99);\n\n            {\n"
- "                let mut last_i ="
- "let mut last_i = 0;\n"
- "                let mut d = "
- "let mut d = s.drain();\n"
- "                for (i, x) in "
- "for (i, x) in d.by_ref().take(50"
- "().take(50).enumerate() {\n"
- "                    last_i = i;\n"
- "                    assert!(x !"
- "x != 0);\n                }\n"
- "                assert_eq!("
- "last_i, 49);\n            }\n\n"
- "            }\n\n            if !"
- "            if !s.is_empty() {\n"
- "                panic!(\""
- "s should be empty!\");\n"
- ";\n            }\n\n"
- "            // reset to try "
- "// reset to try again.\n"
- "            s.extend(1..100);\n"
- "        }\n    }\n\n    #[test]\n"
- "    fn test_replace() {\n"
- "        use core::hash;\n\n"
- "\n        #[derive(Debug)]\n"
- "        #[allow(dead_code)]\n"
- "        struct Foo(&'static str,"
- "(&'static str, i32);\n\n"
- "        impl PartialEq for Foo {"
- " for Foo {\n"
- "            fn eq(&self, other: "
- "(&self, other: &Self) -> bool {\n"
- "                self.0 == other."
- "self.0 == other.0\n            }\n"
- "            }\n        }\n\n"
- "\n        impl Eq for Foo {}\n\n"
- "        impl hash::Hash for Foo "
- "::Hash for Foo {\n"
- "            fn hash<H: hash::"
- " hash<H: hash::Hasher>(&self, h:"
- ">(&self, h: &mut H) {\n"
- "                self.0.hash(h);\n"
- "            }\n        }\n\n"
- "        let mut s = HashSet::new"
- "s = HashSet::new();\n"
- "        assert_eq!("
- "s.replace(Foo(\"a\", 1)), None);\n"
- "        assert_eq!(s.len(), 1);\n"
- "s.len(), 1);\n        assert_eq!("
- "s.replace(Foo(\"a\", 2)), Some(Foo"
- "\", 2)), Some(Foo(\"a\", 1)));\n"
- "        assert_eq!(s.len(), 1);\n"
- "s.len(), 1);\n\n"
- "\n        let mut it = s.iter();\n"
- "        assert_eq!("
- "it.next(), Some(&Foo(\"a\", 2)));\n"
- "        assert_eq!("
- "it.next(), None);\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    #[allow(clippy::"
- "#[allow(clippy::needless_borrow)"
- "needless_borrow)]\n"
- "    fn test_extend_ref() {\n"
- "        let mut a = HashSet::new"
- "a = HashSet::new();\n"
- "        a.insert(1);\n\n"
- "\n        a.extend([2, 3, 4]);\n\n"
- "\n        assert_eq!("
- "a.len(), 4);\n        assert!("
- "a.contains(&1));\n"
- "        assert!("
- "a.contains(&2));\n"
- "        assert!("
- "a.contains(&3));\n"
- "        assert!("
- "a.contains(&4));\n\n"
- "        let mut b = HashSet::new"
- "b = HashSet::new();\n"
- "        b.insert(5);\n"
- "        b.insert(6);\n\n"
- "\n        a.extend(&b);\n\n"
- "\n        assert_eq!("
- "a.len(), 6);\n        assert!("
- "a.contains(&1));\n"
- "        assert!("
- "a.contains(&2));\n"
- "        assert!("
- "a.contains(&3));\n"
- "        assert!("
- "a.contains(&4));\n"
- "        assert!("
- "a.contains(&5));\n"
- "        assert!("
- "a.contains(&6));\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_retain() {\n"
- "        let xs = [1, 2, 3, 4, 5,"
- " [1, 2, 3, 4, 5, 6];\n"
- "        let mut set: HashSet<i32"
- "set: HashSet<i32> = xs.iter()."
- "> = xs.iter().copied().collect()"
- "().collect();\n"
- "        set.retain(|&k| k % 2 =="
- "(|&k| k % 2 == 0);\n"
- "        assert_eq!("
- "set.len(), 3);\n        assert!("
- "set.contains(&2));\n"
- "        assert!("
- "set.contains(&4));\n"
- "        assert!("
- "set.contains(&6));\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn test_extract_if() {\n"
- "        {\n"
- "            let mut set: HashSet"
- "mut set: HashSet<i32> = (0..8)."
- "<i32> = (0..8).collect();\n"
- "            let drained = "
- let drained = set.extract_if(|&k
- "(|&k| k % 2 == 0);\n"
- "            let mut out = "
- "let mut out = drained.collect::<"
- "::<Vec<_>>();\n"
- "            out.sort_unstable();"
- "();\n            assert_eq!(vec!["
- "vec![0, 2, 4, 6], out);\n"
- "            assert_eq!("
- "set.len(), 4);\n        }\n"
- "        }\n        {\n"
- "            let mut set: HashSet"
- "mut set: HashSet<i32> = (0..8)."
- "<i32> = (0..8).collect();\n"
- "            set.extract_if(|&k| "
- (|&k| k % 2 == 0).for_each(drop)
- ").for_each(drop);\n"
- "            assert_eq!("
- "set.len(), 4, \"Removes non-"
- "4, \"Removes non-matching items "
- "-matching items on drop\");\n"
- "        }\n    }\n\n    #[test]\n"
- "    fn test_const_with_hasher() "
- "() {\n"
- "        use core::hash::"
- "use core::hash::BuildHasher;\n"
- "        use std::collections::"
- "::collections::hash_map::"
- "::hash_map::DefaultHasher;\n\n"
- "\n        #[derive(Clone)]\n"
- "        struct MyHasher;\n"
- "        impl BuildHasher for "
- "BuildHasher for MyHasher {\n"
- "            type Hasher = "
- "type Hasher = DefaultHasher;\n\n"
- "            fn build_hasher(&"
- " build_hasher(&self) -> "
- "(&self) -> DefaultHasher {\n"
- "                DefaultHasher::"
- "DefaultHasher::new()\n"
- "            }\n        }\n\n"
- "        const EMPTY_SET: HashSet"
- ": HashSet<u32, MyHasher> = "
- ", MyHasher> = HashSet::"
- "> = HashSet::with_hasher("
- "::with_hasher(MyHasher);\n\n"
- "        let mut set = EMPTY_SET;"
- "set = EMPTY_SET;\n"
- "        set.insert(19);\n"
- "        assert!("
- "set.contains(&19));\n    }\n\n"
- "    }\n\n    #[test]\n"
- "    fn rehash_in_place() {\n"
- "        let mut set = HashSet::"
- " set = HashSet::new();\n\n"
- "\n        for i in 0..224 {\n"
- "            set.insert(i);\n"
- "        }\n\n        assert_eq!(\n"
- "            set.capacity(),\n"
- "            224,\n"
- "            \"The set must be at "
- " set must be at or close to "
- " at or close to capacity to "
- " to capacity to trigger a re "
- "to trigger a re hashing\"\n"
- "        );\n\n"
- "\n        for i in 100..1400 {\n"
- "            set.remove(&(i - 100"
- "(&(i - 100));\n"
- "            set.insert(i);\n"
- "        }\n    }\n\n    #[test]\n"
- "\n    #[test]\n    fn collect() {\n"
- "        // At the time of "
- " At the time of writing, this "
- " writing, this hits the ZST case"
- " the ZST case in from_base_index"
- " from_base_index\n"
- "        // (and without the `map"
- "without the `map`, it does not)."
- "`, it does not).\n"
- "        let mut _set: HashSet<_>"
- "_set: HashSet<_> = (0..3).map(|_"
- " = (0..3).map(|_| ()).collect();"
- "| ()).collect();\n    }\n}\n"
