---
source: tests/snapshots.rs
expression: chunks
---
- //
- "https://github.com/rust-lang/"
- /rust-lang/hashbrown/blob/
- 1167d19935f79320d666bf8549f05322
- d666bf8549f053229567d778/src/
- /src/rustc_entry.rs
- "#[cfg(feature = \"raw\")]"
- "use crate::raw::RawTable;"
- "use crate::{Equivalent,"
- "::{Equivalent, TryReserveError};"
- "use alloc::borrow::ToOwned;"
- "use core::fmt;"
- "use core::hash::{BuildHasher,"
- "::{BuildHasher, Hash};"
- "use core::iter::{Chain,"
- "::iter::{Chain, FusedIterator};"
- "use core::ops::{BitAnd, BitOr,"
- ":{BitAnd, BitOr, BitXor, Sub};"
- "use super::map::{self,"
- "::map::{self, DefaultHashBuilder"
- ", HashMap, Keys};"
- "use crate::raw::{Allocator,"
- "raw::{Allocator, Global,"
- ", Global, RawExtractIf};"
- // Future Optimization (FIXME!)
- // =============================
- //
- // Iteration over zero sized
- over zero sized values is a noop
- values is a noop.
- There is no need
- "// for `bucket.val` in the case"
- "` in the case of HashSet."
- I suppose we would need HKT
- // to get rid of it properly.
- /// A hash set implemented as a
- "implemented as a `HashMap` where"
- "`HashMap` where the value is `()"
- "the value is `()`.\n///"
- "/// As with the [`HashMap`] type"
- "[`HashMap`] type, a `HashSet`"
- ", a `HashSet` requires that the"
- that the elements
- "/// implement the [`Eq`] and [`"
- "[`Eq`] and [`Hash`] traits."
- This can frequently be achieved
- be achieved by
- "/// using `#[derive(PartialEq,"
- "(PartialEq, Eq, Hash)]`."
- "If you implement these yourself,"
- /// it is important that the
- that the following property
- " property holds:\n///\n/// ```text"
- /// k1 == k2 -> hash(k1) == hash
- "hash(k1) == hash(k2)\n/// ```\n///"
- "/// In other words, if two keys"
- ", if two keys are equal, their"
- "are equal, their hashes must be"
- " hashes must be equal.\n///\n///"
- /// It is a logic error for an
- error for an item to be modified
- to be modified in such a way
- in such a way that the
- "/// item's hash, as determined"
- ", as determined by the [`Hash`]"
- "by the [`Hash`] trait, or its"
- "`] trait, or its equality, as"
- "/// determined by the [`Eq`]"
- "by the [`Eq`] trait, changes"
- "] trait, changes while it is in"
- while it is in the set. This is
- /// normally only possible
- "only possible through [`Cell`],"
- "[`Cell`], [`RefCell`], global"
- "`], global state, I/O, or"
- "/// unsafe code.\n///"
- /// It is also a logic error for
- "logic error for the [`Hash`]"
- "for the [`Hash`] implementation"
- "] implementation of a key to"
- of a key to panic.
- /// This is generally only
- generally only possible if the
- possible if the trait is
- if the trait is implemented
- is implemented manually. If a
- /// panic does occur then the
- "occur then the contents of the `"
- "of the `HashSet` may become"
- "` may become corrupted and"
- /// some items may be dropped
- may be dropped from the table.
- "///\n/// # Examples\n///\n/// ```"
- "/// use hashbrown::HashSet;"
- /// // Type inference lets us
- lets us omit an explicit type
- an explicit type signature (
- type signature (which
- "/// // would be `HashSet<String>"
- "`HashSet<String>` in this"
- "String>` in this example)."
- "/// let mut books = HashSet::new"
- " = HashSet::new();\n///"
- "///\n/// // Add some books."
- "/// books.insert(\"A Dance With"
- "(\"A Dance With Dragons\"."
- "With Dragons\".to_string());"
- "/// books.insert(\"To Kill a"
- "(\"To Kill a Mockingbird\"."
- "a Mockingbird\".to_string());"
- "/// books.insert(\"The Odyssey\"."
- "(\"The Odyssey\".to_string());"
- "/// books.insert(\"The Great"
- "(\"The Great Gatsby\".to_string())"
- "\".to_string());\n///"
- /// // Check for a specific one.
- /// if !
- "books.contains(\"The Winds of"
- "(\"The Winds of Winter\") {"
- "///     println!(\""
- "We have {} books, but The Winds"
- ", but The Winds of Winter ain't"
- "of Winter ain't one.\","
- ///              books.len());
- "/// }\n///\n/// // Remove a book."
- "/// books.remove(\"The Odyssey\");"
- ///
- /// // Iterate over everything.
- "/// for book in &books {"
- "///     println!(\"{}\", book);"
- "/// }\n/// ```\n///"
- "/// The easiest way to use `"
- "way to use `HashSet` with a"
- "`HashSet` with a custom type is"
- a custom type is to derive
- "/// [`Eq`] and [`Hash`]."
- "We must also derive [`PartialEq`"
- "[`PartialEq`]. This will in the"
- "/// future be implied by [`Eq`]."
- "///\n/// ```"
- "/// use hashbrown::HashSet;"
- "/// #[derive(Hash, Eq, PartialEq"
- ", Eq, PartialEq, Debug)]"
- "/// struct Viking {"
- "///     name: String,"
- "///     power: usize,\n/// }\n///"
- "/// let mut vikings = HashSet::"
- " = HashSet::new();\n///"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Einar\"."
- "{ name: \"Einar\".to_string(),"
- "\".to_string(), power: 9 });"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Einar\"."
- "{ name: \"Einar\".to_string(),"
- "\".to_string(), power: 9 });"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Olaf\".to_string"
- "\"Olaf\".to_string(), power: 4 });"
- "/// vikings.insert(Viking { name"
- "(Viking { name: \"Harald\"."
- "name: \"Harald\".to_string(),"
- "\".to_string(), power: 8 });\n///"
- /// // Use derived
- / // Use derived implementation
- implementation to print the
- to print the vikings.
- "/// for x in &vikings {"
- "///     println!(\"{:?}\", x);"
- "/// }\n/// ```\n///"
- "/// A `HashSet` with fixed list"
- with fixed list of elements can
- of elements can be initialized
- "be initialized from an array:"
- "///\n/// ```"
- "/// use hashbrown::HashSet;\n///"
- "/// let viking_names: HashSet<&'"
- ": HashSet<&'static str> ="
- "///     [ \"Einar\", \"Olaf\", \""
- "\", \"Olaf\", \"Harald\" ].into_iter("
- "\" ].into_iter().collect();"
- /// // use the values stored in
- values stored in the set
- "/// ```\n///"
- "/// [`Cell`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cell/"
- /std/cell/struct.Cell.html
- "/// [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- /std/cmp/trait.Eq.html
- "/// [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- /std/hash/trait.Hash.html
- "/// [`HashMap`]:"
- "[`HashMap`]: struct.HashMap.html"
- "/// [`PartialEq`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/cmp/"
- /std/cmp/trait.PartialEq.html
- "/// [`RefCell`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/cell/"
- /std/cell/struct.RefCell.html
- "pub struct HashSet<T, S ="
- "<T, S = DefaultHashBuilder, A:"
- ", A: Allocator = Global> {"
- "pub(crate) map: HashMap<T, (), S"
- "HashMap<T, (), S, A>,\n}"
- "impl<T: Clone, S: Clone, A:"
- ", S: Clone, A: Allocator + Clone"
- "+ Clone> Clone for HashSet<T, S,"
- "HashSet<T, S, A> {"
- "fn clone(&self) -> Self {"
- "HashSet {"
- "map: self.map.clone(),"
- "        }\n    }"
- "fn clone_from(&mut self, source:"
- "self, source: &Self) {"
- self.map.clone_from(&source.map)
- "(&source.map);\n    }\n}"
- "}\n\n#[cfg(feature = \"ahash\")]"
- "impl<T> HashSet<T,"
- "T> HashSet<T, DefaultHashBuilder"
- "> {"
- "/// Creates an empty `HashSet`."
- ///
- /// The hash set is initially
- set is initially created with a
- "created with a capacity of 0, so"
- "of 0, so it will not allocate"
- not allocate until it
- /// is first inserted into.
- ///
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`], for"
- "[`HashSet`], for example with"
- "/// [`with_hasher`](HashSet::"
- "`](HashSet::with_hasher) method."
- ///
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::new();"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn new() -> Self {"
- "Self {"
- "map: HashMap::new(),"
- "        }\n    }"
- "/// Creates an empty `HashSet`"
- "empty `HashSet` with the"
- "` with the specified capacity."
- ///
- /// The hash set will be able to
- "will be able to hold at least `"
- "hold at least `capacity`"
- "least `capacity` elements"
- "` elements without"
- /// reallocating.
- "If `capacity` is 0, the hash set"
- "0, the hash set will not"
- " set will not allocate.\n    ///"
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`], for"
- "[`HashSet`], for example with"
- "/// [`with_capacity_and_hasher`]"
- "`](HashSet::"
- "::with_capacity_and_hasher)"
- ") method.\n    ///"
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::"
- "i32> = HashSet::with_capacity(10"
- with_capacity(10);
- /// assert!(
- set.capacity() >= 10);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn with_capacity(capacity:"
- "(capacity: usize) -> Self {"
- "Self {"
- "map: HashMap::with_capacity("
- "::with_capacity(capacity),"
- "        }\n    }\n}"
- "}\n\n#[cfg(feature = \"ahash\")]"
- "impl<T: Hash + Eq, A: Allocator>"
- ", A: Allocator> HashSet<T,"
- "> HashSet<T, DefaultHashBuilder,"
- ", A> {"
- "/// Creates an empty `HashSet`."
- ///
- /// The hash set is initially
- set is initially created with a
- "created with a capacity of 0, so"
- "of 0, so it will not allocate"
- not allocate until it
- /// is first inserted into.
- ///
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`], for"
- "[`HashSet`], for example with"
- "/// [`with_hasher_in`](HashSet::"
- "`](HashSet::with_hasher_in)"
- ":with_hasher_in) method.\n    ///"
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::new();"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn new_in(alloc: A) -> Self"
- ": A) -> Self {\n        Self {"
- "map: HashMap::new_in(alloc),"
- "        }\n    }"
- "/// Creates an empty `HashSet`"
- "empty `HashSet` with the"
- "` with the specified capacity."
- ///
- /// The hash set will be able to
- "will be able to hold at least `"
- "hold at least `capacity`"
- "least `capacity` elements"
- "` elements without"
- /// reallocating.
- "If `capacity` is 0, the hash set"
- "0, the hash set will not"
- " set will not allocate.\n    ///"
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`], for"
- "[`HashSet`], for example with"
- "/// [`"
- "// [`with_capacity_and_hasher_in"
- "`](HashSet::"
- "::with_capacity_and_hasher_in)"
- ") method.\n    ///"
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::"
- "i32> = HashSet::with_capacity(10"
- with_capacity(10);
- /// assert!(
- set.capacity() >= 10);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn with_capacity_in(capacity
- "(capacity: usize, alloc: A) ->"
- ", alloc: A) -> Self {"
- "Self {"
- "map: HashMap::with_capacity_in("
- "(capacity, alloc),\n        }"
- "        }\n    }\n}"
- "impl<T, S, A: Allocator> HashSet"
- "> HashSet<T, S, A> {"
- /// Returns the number of
- the number of elements the set
- elements the set can hold
- the set can hold without
- can hold without reallocating.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::"
- "i32> = HashSet::with_capacity("
- "::with_capacity(100);"
- /// assert!(
- set.capacity() >= 100);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn capacity(&self) -> usize
- "(&self) -> usize {"
- self.map.capacity()
- "}"
- /// An iterator visiting all
- visiting all elements in
- all elements in arbitrary order.
- /// The iterator element type is
- "element type is `&'a T`."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let mut set = HashSet::new()"
- "= HashSet::new();"
- "/// set.insert(\"a\");"
- "    /// set.insert(\"b\");\n    ///"
- /// // Will print in an
- Will print in an arbitrary order
- arbitrary order.
- "/// for x in set.iter() {"
- "///     println!(\"{}\", x);"
- "    /// }\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn iter(&self) -> Iter<'_, T"
- ") -> Iter<'_, T> {"
- "Iter {"
- "iter: self.map.keys(),"
- "        }\n    }"
- /// Returns the number of
- the number of elements in the
- " elements in the set.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut v = HashSet::new();"
- "/// assert_eq!(v.len(), 0);"
- /// v.insert(1);
- "/// assert_eq!(v.len(), 1);"
- "v.len(), 1);\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn len(&self) -> usize {"
- "        self.map.len()\n    }"
- "/// Returns `true` if the set"
- "true` if the set contains no"
- set contains no elements.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut v = HashSet::new();"
- /// assert!(v.is_empty());
- /// v.insert(1);
- /// assert!(!v.is_empty());
- "v.is_empty());\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn is_empty(&self) -> bool {"
- self.map.is_empty()
- "}"
- "/// Clears the set, returning"
- "set, returning all elements in"
- all elements in an iterator.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<_> = [1"
- "HashSet<_> = [1, 2, 3].into_iter"
- "2, 3].into_iter().collect();"
- /// assert!(!set.is_empty());
- "set.is_empty());\n    ///"
- "/// // print 1, 2, 3 in an"
- "1, 2, 3 in an arbitrary order"
- "/// for i in set.drain() {"
- "///     println!(\"{}\", i);"
- "    /// }\n    ///"
- "    ///\n    /// assert!("
- /// assert!(set.is_empty());
- "set.is_empty());\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn drain(&mut self) -> Drain
- "self) -> Drain<'_, T, A> {"
- "Drain {"
- "iter: self.map.drain(),"
- "        }\n    }"
- /// Retains only the elements
- the elements specified by the
- specified by the predicate.
- ///
- "/// In other words, remove all"
- ", remove all elements `e` such"
- "`e` such that `f(&e)` returns `"
- "f(&e)` returns `false`.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let xs = [1,2,3,4,5,6];"
- "/// let mut set: HashSet<i32> ="
- ": HashSet<i32> = xs.into_iter()."
- xs.into_iter().collect();
- /// set.retain(|&k| k % 2 == 0);
- "/// assert_eq!(set.len(), 3);"
- "set.len(), 3);\n    /// ```"
- "pub fn retain<F>(&mut self, mut"
- ">(&mut self, mut f: F)\n    where"
- "F: FnMut(&T) -> bool,"
- "{"
- "self.map.retain(|k, _| f(k));"
- "}"
- /// Drains elements which are
- which are true under the given
- "under the given predicate,"
- /// and returns an iterator over
- an iterator over the removed
- "over the removed items.\n    ///"
- "/// In other words, move all"
- "words, move all elements `e`"
- "all elements `e` such that `f(&e"
- "such that `f(&e)` returns `true`"
- "` returns `true` out"
- /// into another iterator.
- ///
- "/// If the returned `ExtractIf`"
- "`ExtractIf` is not exhausted,"
- "not exhausted, e.g. because it"
- e.g. because it is dropped
- it is dropped without iterating
- /// or the iteration short-
- "iteration short-circuits, then"
- "-circuits, then the remaining"
- the remaining elements will be
- elements will be retained.
- "/// Use [`retain()`] with a"
- "()`] with a negated predicate if"
- predicate if you do not need the
- do not need the returned
- " the returned iterator.\n    ///"
- "/// [`retain()`]: HashSet::"
- "()`]: HashSet::retain\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<i32> ="
- ": HashSet<i32> = (0..8).collect("
- (0..8).collect();
- "/// let drained: HashSet<i32> ="
- ": HashSet<i32> = set.extract_if("
- set.extract_if(|v| v % 2 == 0).
- "|v| v % 2 == 0).collect();"
- ///
- /// let mut evens =
- mut evens = drained.into_iter().
- "().collect::<Vec<_>>();"
- /// let mut odds = set.into_iter
- "= set.into_iter().collect::<Vec<"
- ").collect::<Vec<_>>();"
- /// evens.sort();
- "    /// odds.sort();\n    ///"
- "    ///\n    /// assert_eq!("
- "/// assert_eq!(evens, vec!["
- "evens, vec![0, 2, 4, 6]);"
- "/// assert_eq!(odds, vec!["
- "odds, vec![1, 3, 5, 7]);"
- "1, 3, 5, 7]);\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn extract_if<F>(&mut self,"
- "<F>(&mut self, f: F) ->"
- "self, f: F) -> ExtractIf<'_, T,"
- "ExtractIf<'_, T, F, A>\n    where"
- "F: FnMut(&T) -> bool,"
- "    {\n        ExtractIf {"
- "f,"
- "inner: RawExtractIf {"
- "iter: unsafe {"
- ": unsafe { self.map.table.iter()"
- "() },"
- "table: &mut self.map.table,"
- "            },\n        }\n    }"
- "/// Clears the set, removing all"
- ", removing all values.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut v = HashSet::new();"
- /// v.insert(1);
- /// v.clear();
- /// assert!(v.is_empty());
- "v.is_empty());\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn clear(&mut self) {"
- "        self.map.clear();\n    }"
- "    }\n}"
- "impl<T, S> HashSet<T, S, Global>"
- "<T, S, Global> {"
- /// Creates a new empty hash set
- empty hash set which will use
- which will use the given hasher
- the given hasher to hash
- "    /// keys.\n    ///"
- /// The hash set is initially
- set is initially created with a
- "created with a capacity of 0, so"
- "of 0, so it will not"
- /// allocate until it is first
- it is first inserted into.
- ///
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`]."
- ///
- "/// The `hash_builder` passed"
- "` passed should implement the [`"
- "implement the [`BuildHasher`]"
- "[`BuildHasher`] trait for"
- "/// the HashSet to be useful,"
- "to be useful, see its"
- "useful, see its documentation"
- documentation for details.
- ///
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "/// [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;"
- ///
- "/// let s = DefaultHashBuilder::"
- "::default();"
- "/// let mut set = HashSet::"
- "set = HashSet::with_hasher(s);"
- /// set.insert(2);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub const fn with_hasher(hasher:"
- "(hasher: S) -> Self {"
- "Self {"
- "map: HashMap::with_hasher(hasher"
- "(hasher),\n        }\n    }"
- "/// Creates an empty `HashSet`"
- "empty `HashSet` with the"
- "` with the specified capacity,"
- "capacity, using"
- "/// `hasher` to hash the keys."
- ///
- /// The hash set will be able to
- "will be able to hold at least `"
- "hold at least `capacity`"
- "least `capacity` elements"
- "` elements without"
- /// reallocating.
- "If `capacity` is 0, the hash set"
- "0, the hash set will not"
- " set will not allocate.\n    ///"
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`]."
- ///
- "/// The `hash_builder` passed"
- "` passed should implement the [`"
- "implement the [`BuildHasher`]"
- "[`BuildHasher`] trait for"
- "/// the HashSet to be useful,"
- "to be useful, see its"
- "useful, see its documentation"
- documentation for details.
- ///
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "/// [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;"
- ///
- "/// let s = DefaultHashBuilder::"
- "::default();"
- "/// let mut set = HashSet::"
- "::with_capacity_and_hasher(10, s"
- "(10, s);\n    /// set.insert(1);"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn with_capacity_and_hasher(
- "(capacity: usize, hasher: S) ->"
- ", hasher: S) -> Self {"
- "Self {"
- "map: HashMap::"
- "::with_capacity_and_hasher("
- "(capacity, hasher),\n        }"
- "        }\n    }\n}"
- "impl<T, S, A> HashSet<T, S, A>"
- "where\n    A: Allocator,\n{"
- /// Returns a reference to the
- reference to the underlying
- the underlying allocator.
- "#[inline]"
- "pub fn allocator(&self) -> &A {"
- self.map.allocator()
- "}"
- /// Creates a new empty hash set
- empty hash set which will use
- which will use the given hasher
- the given hasher to hash
- "    /// keys.\n    ///"
- /// The hash set is initially
- set is initially created with a
- "created with a capacity of 0, so"
- "of 0, so it will not"
- /// allocate until it is first
- it is first inserted into.
- ///
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`]."
- ///
- "/// The `hash_builder` passed"
- "` passed should implement the [`"
- "implement the [`BuildHasher`]"
- "[`BuildHasher`] trait for"
- "/// the HashSet to be useful,"
- "to be useful, see its"
- "useful, see its documentation"
- documentation for details.
- ///
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "/// [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;"
- ///
- "/// let s = DefaultHashBuilder::"
- "::default();"
- "/// let mut set = HashSet::"
- "set = HashSet::with_hasher(s);"
- /// set.insert(2);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub const fn with_hasher_in(
- "with_hasher_in(hasher: S, alloc:"
- ": S, alloc: A) -> Self {"
- "Self {"
- "map: HashMap::with_hasher_in("
- ":with_hasher_in(hasher, alloc),"
- "        }\n    }"
- "/// Creates an empty `HashSet`"
- "empty `HashSet` with the"
- "` with the specified capacity,"
- "capacity, using"
- "/// `hasher` to hash the keys."
- ///
- /// The hash set will be able to
- "will be able to hold at least `"
- "hold at least `capacity`"
- "least `capacity` elements"
- "` elements without"
- /// reallocating.
- "If `capacity` is 0, the hash set"
- "0, the hash set will not"
- " set will not allocate.\n    ///"
- "/// # HashDoS resistance"
- ///
- "/// The `hash_builder` normally"
- "` normally use a fixed key by"
- a fixed key by default and that
- default and that does
- "/// not allow the `HashSet` to"
- "the `HashSet` to be protected"
- to be protected against attacks
- "against attacks such as [`"
- "such as [`HashDoS`]."
- /// Users who require HashDoS
- require HashDoS resistance
- resistance should explicitly use
- "/// [`ahash::RandomState`] or [`"
- "`] or [`std::collections::"
- "::collections::hash_map::"
- "::hash_map::RandomState`]"
- /// as the hasher when creating
- "when creating a [`HashSet`]."
- ///
- "/// The `hash_builder` passed"
- "` passed should implement the [`"
- "implement the [`BuildHasher`]"
- "[`BuildHasher`] trait for"
- "/// the HashSet to be useful,"
- "to be useful, see its"
- "useful, see its documentation"
- documentation for details.
- ///
- "/// [`HashDoS`]: https://"
- "`]: https://en.wikipedia.org/"
- /wiki/Collision_attack
- "/// [`std::collections::hash_map"
- "::hash_map::RandomState`]: https"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/collections/"
- std/collections/hash_map/
- hash_map/struct.RandomState.html
- "/// [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;"
- ///
- "/// let s = DefaultHashBuilder::"
- "::default();"
- "/// let mut set = HashSet::"
- "::with_capacity_and_hasher(10, s"
- "(10, s);\n    /// set.insert(1);"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn
- fn with_capacity_and_hasher_in(
- "(capacity: usize, hasher: S,"
- ", hasher: S, alloc: A) -> Self {"
- "Self {"
- "map: HashMap::"
- "::with_capacity_and_hasher_in("
- "(capacity, hasher, alloc),"
- "        }\n    }"
- /// Returns a reference to the
- "reference to the set's [`"
- "to the set's [`BuildHasher`]."
- ///
- "/// [`BuildHasher`]: https://"
- "`]: https://doc.rust-lang.org/"
- "-lang.org/std/hash/"
- /std/hash/trait.BuildHasher.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_map::"
- "::hash_map::DefaultHashBuilder;"
- ///
- /// let hasher =
- "let hasher = DefaultHashBuilder:"
- "::default();"
- "/// let set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::"
- "i32> = HashSet::with_hasher("
- "::with_hasher(hasher);"
- "/// let hasher: &"
- "let hasher: &DefaultHashBuilder"
- " = set.hasher();\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn hasher(&self) -> &S {"
- "        self.map.hasher()\n    }"
- "    }\n}"
- "impl<T, S, A> HashSet<T, S, A>"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- /// Reserves capacity for at
- "capacity for at least `"
- "for at least `additional` more"
- "additional` more elements to be"
- elements to be inserted
- "/// in the `HashSet`."
- The collection may reserve more
- may reserve more space to avoid
- /// frequent reallocations.
- "    ///\n    /// # Panics\n    ///"
- /// Panics if the new capacity
- "the new capacity exceeds [`isize"
- "exceeds [`isize::MAX`] bytes and"
- ":MAX`] bytes and [`abort`] the"
- "[`abort`] the program"
- /// in case of allocation error.
- "Use [`try_reserve`](HashSet::"
- "`](HashSet::try_reserve) instead"
- /// if you want to handle memory
- to handle memory allocation
- " allocation failure.\n    ///"
- "/// [`isize::MAX`]: https://"
- ":MAX`]: https://doc.rust-"
- "://doc.rust-lang.org/std/"
- /std/primitive.isize.html
- "/// [`abort`]: https://doc.rust-"
- "://doc.rust-lang.org/alloc/alloc"
- /alloc/alloc/
- alloc/fn.handle_alloc_error.html
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let mut set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::new();"
- /// set.reserve(10);
- /// assert!(
- set.capacity() >= 10);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn reserve(&mut self,"
- "(&mut self, additional: usize) {"
- self.map.reserve(additional);
- "}"
- /// Tries to reserve capacity
- "reserve capacity for at least `"
- "for at least `additional` more"
- "additional` more elements to be"
- elements to be inserted
- "/// in the given `HashSet<K,V>`."
- The collection may reserve more
- may reserve more space to avoid
- /// frequent reallocations.
- "    ///\n    /// # Errors\n    ///"
- "/// If the capacity overflows,"
- "overflows, or the allocator"
- or the allocator reports a
- "reports a failure, then an error"
- "    /// is returned.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let mut set: HashSet<i32> ="
- ": HashSet<i32> = HashSet::new();"
- "/// set.try_reserve(10).expect(\""
- "(10).expect(\"why is the test"
- "\"why is the test harness OOMing"
- "harness OOMing on 10 bytes?\");"
- ";\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn try_reserve(&mut self,"
- "(&mut self, additional: usize) -"
- ": usize) -> Result<(),"
- ") -> Result<(), TryReserveError>"
- "TryReserveError> {"
- self.map.try_reserve(additional)
- "}"
- /// Shrinks the capacity of the
- capacity of the set as much as
- set as much as possible.
- It will drop
- /// down as much as possible
- much as possible while
- possible while maintaining the
- maintaining the internal rules
- /// and possibly leaving some
- leaving some space in accordance
- in accordance with the resize
- " with the resize policy.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set = HashSet::"
- "set = HashSet::with_capacity(100"
- "(100);\n    /// set.insert(1);"
- /// set.insert(2);
- /// assert!(
- set.capacity() >= 100);
- /// set.shrink_to_fit();
- /// assert!(
- set.capacity() >= 2);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn shrink_to_fit(&mut self)
- "(&mut self) {"
- self.map.shrink_to_fit();
- "}"
- /// Shrinks the capacity of the
- capacity of the set with a lower
- set with a lower limit.
- It will drop
- /// down no lower than the
- lower than the supplied limit
- supplied limit while maintaining
- maintaining the internal rules
- /// and possibly leaving some
- leaving some space in accordance
- in accordance with the resize
- " with the resize policy.\n    ///"
- /// Panics if the current
- if the current capacity is
- capacity is smaller than the
- smaller than the supplied
- /// minimum capacity.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set = HashSet::"
- "set = HashSet::with_capacity(100"
- "(100);\n    /// set.insert(1);"
- /// set.insert(2);
- /// assert!(
- set.capacity() >= 100);
- /// set.shrink_to(10);
- /// assert!(
- set.capacity() >= 10);
- /// set.shrink_to(0);
- /// assert!(
- set.capacity() >= 2);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn shrink_to(&mut self,"
- "(&mut self, min_capacity: usize)"
- ": usize) {"
- self.map.shrink_to(min_capacity)
- "(min_capacity);\n    }"
- /// Visits the values
- the values representing the
- "representing the difference,"
- "/// i.e., the values that are in"
- "that are in `self` but not in `"
- "` but not in `other`.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let a: HashSet<_> = [1, 2, 3"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- "/// let b: HashSet<_> = [4, 2, 3"
- "<_> = [4, 2, 3, 4].into_iter()."
- "4].into_iter().collect();"
- ///
- "/// // Can be seen as `a - b`."
- "/// for x in a.difference(&b) {"
- "///     println!(\"{}\", x); //"
- "!(\"{}\", x); // Print 1\n    /// }"
- "    /// }\n    ///"
- "/// let diff: HashSet<_> ="
- ": HashSet<_> = a.difference(&b)."
- (&b).collect();
- /// assert_eq!(
- "diff, [1].iter().collect());"
- ///
- /// // Note that difference is
- "difference is not symmetric,"
- "/// // and `b - a` means"
- "`b - a` means something else:"
- "/// let diff: HashSet<_> ="
- ": HashSet<_> = b.difference(&a)."
- (&a).collect();
- /// assert_eq!(
- "diff, [4].iter().collect());"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn difference<'a>(&'a self,"
- "<'a>(&'a self, other: &'a Self)"
- "other: &'a Self) -> Difference<'"
- "-> Difference<'a, T, S, A> {"
- "Difference {"
- "iter: self.iter(),"
- "            other,\n        }"
- "        }\n    }"
- /// Visits the values
- the values representing the
- representing the symmetric
- "the symmetric difference,"
- "/// i.e., the values that are in"
- "that are in `self` or in `other`"
- "` or in `other` but not in both."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let a: HashSet<_> = [1, 2, 3"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- "/// let b: HashSet<_> = [4, 2, 3"
- "<_> = [4, 2, 3, 4].into_iter()."
- "4].into_iter().collect();"
- ///
- "/// // Print 1, 4 in arbitrary"
- ", 4 in arbitrary order."
- /// for x in
- for x in a.symmetric_difference(
- "(&b) {"
- "///     println!(\"{}\", x);"
- "    /// }\n    ///"
- "/// let diff1: HashSet<_> ="
- "<_> = a.symmetric_difference(&b)"
- (&b).collect();
- "/// let diff2: HashSet<_> ="
- "<_> = b.symmetric_difference(&a)"
- "(&a).collect();\n    ///"
- "    ///\n    /// assert_eq!("
- "/// assert_eq!(diff1, diff2);"
- /// assert_eq!(
- "diff1, [1, 4].iter().collect());"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn symmetric_difference<'a>("
- "<'a>(&'a self, other: &'a Self)"
- "other: &'a Self) ->"
- "&'a Self) -> SymmetricDifference"
- "<'a, T, S, A> {"
- "SymmetricDifference {"
- "iter: self.difference(other)."
- (other).chain(other.difference(
- "(self)),\n        }\n    }"
- /// Visits the values
- the values representing the
- "representing the intersection,"
- "/// i.e., the values that are"
- "values that are both in `self`"
- "both in `self` and `other`."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let a: HashSet<_> = [1, 2, 3"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- "/// let b: HashSet<_> = [4, 2, 3"
- "<_> = [4, 2, 3, 4].into_iter()."
- "4].into_iter().collect();"
- ///
- "/// // Print 2, 3 in arbitrary"
- ", 3 in arbitrary order."
- /// for x in a.intersection(&b)
- "(&b) {"
- "///     println!(\"{}\", x);"
- "    /// }\n    ///"
- "/// let intersection: HashSet<_>"
- ": HashSet<_> = a.intersection(&b"
- (&b).collect();
- /// assert_eq!(
- "intersection, [2, 3].iter()."
- ", [2, 3].iter().collect());"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn intersection<'a>(&'a self"
- "<'a>(&'a self, other: &'a Self)"
- "other: &'a Self) -> Intersection"
- "-> Intersection<'a, T, S, A> {"
- "let (smaller, larger) = if"
- ", larger) = if self.len() <="
- "if self.len() <= other.len() {"
- "(self, other)"
- "} else {"
- "(other, self)"
- "};"
- "Intersection {"
- "iter: smaller.iter(),"
- "other: larger,"
- "        }\n    }"
- /// Visits the values
- the values representing the
- "representing the union,"
- "/// i.e., all the values in `"
- "the values in `self` or `other`,"
- "` or `other`, without duplicates"
- " duplicates.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let a: HashSet<_> = [1, 2, 3"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- "/// let b: HashSet<_> = [4, 2, 3"
- "<_> = [4, 2, 3, 4].into_iter()."
- "4].into_iter().collect();"
- ///
- "/// // Print 1, 2, 3, 4 in"
- "1, 2, 3, 4 in arbitrary order."
- "/// for x in a.union(&b) {"
- "///     println!(\"{}\", x);"
- "    /// }\n    ///"
- "/// let union: HashSet<_> ="
- ": HashSet<_> = a.union(&b)."
- "> = a.union(&b).collect();"
- /// assert_eq!(
- "union, [1, 2, 3, 4].iter()."
- "2, 3, 4].iter().collect());"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn union<'a>(&'a self, other"
- "(&'a self, other: &'a Self) ->"
- ": &'a Self) -> Union<'a, T, S, A"
- "<'a, T, S, A> {"
- "// We'll iterate one set in full"
- "one set in full, and only the"
- ", and only the remaining"
- the remaining difference from
- difference from the other.
- // Use the smaller set for the
- set for the difference in order
- in order to reduce hash lookups.
- "let (smaller, larger) = if"
- ", larger) = if self.len() <="
- "if self.len() <= other.len() {"
- "(self, other)"
- "} else {"
- "(other, self)"
- "        };\n        Union {"
- "iter: larger.iter().chain("
- ().chain(smaller.difference(
- "(larger)),\n        }\n    }"
- "/// Returns `true` if the set"
- "true` if the set contains a"
- " set contains a value.\n    ///"
- /// The value may be any
- value may be any borrowed form
- "borrowed form of the set's value"
- "the set's value type, but"
- "/// [`Hash`] and [`Eq`] on the"
- "[`Eq`] on the borrowed form *"
- borrowed form *must* match those
- "* match those for"
- "    /// the value type.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let set: HashSet<_> = [1, 2,"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- /// assert_eq!(
- "set.contains(&1), true);"
- /// assert_eq!(
- "set.contains(&4), false);"
- "    /// ```\n    ///"
- "/// [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- /std/cmp/trait.Eq.html
- "/// [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- /std/hash/trait.Hash.html
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn contains<Q: ?"
- "Sized>(&self, value: &Q) -> bool"
- where
- "Q: Hash + Equivalent<T>,"
- "{"
- self.map.contains_key(value)
- "}"
- /// Returns a reference to the
- reference to the value in the
- "the value in the set, if any,"
- "the set, if any, that is equal"
- ", that is equal to the given"
- " to the given value.\n    ///"
- /// The value may be any
- value may be any borrowed form
- "borrowed form of the set's value"
- "the set's value type, but"
- "/// [`Hash`] and [`Eq`] on the"
- "[`Eq`] on the borrowed form *"
- borrowed form *must* match those
- "* match those for"
- "    /// the value type.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let set: HashSet<_> = [1, 2,"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- /// assert_eq!(
- "set.get(&2), Some(&2));"
- /// assert_eq!(
- "set.get(&4), None);\n    /// ```"
- "    /// ```\n    ///"
- "/// [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- /std/cmp/trait.Eq.html
- "/// [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- /std/hash/trait.Hash.html
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn get<Q: ?"
- "Sized>(&self, value: &Q) ->"
- ", value: &Q) -> Option<&T>"
- where
- "Q: Hash + Equivalent<T>,"
- "{"
- "// Avoid `Option::map` because"
- "::map` because it bloats LLVM IR"
- bloats LLVM IR.
- match self.map.get_key_value(
- "(value) {"
- "Some((k, _)) => Some(k),"
- "None => None,"
- "        }\n    }"
- "/// Inserts the given `value`"
- "given `value` into the set if it"
- "the set if it is not present,"
- "is not present, then"
- /// returns a reference to the
- reference to the value in the
- " the value in the set.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<_> = [1"
- "HashSet<_> = [1, 2, 3].into_iter"
- "2, 3].into_iter().collect();"
- "/// assert_eq!(set.len(), 3);"
- /// assert_eq!(
- "set.get_or_insert(2), &2);"
- /// assert_eq!(
- "set.get_or_insert(100), &100);"
- /// assert_eq!(
- "set.len(), 4); // 100 was"
- ", 4); // 100 was inserted"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn get_or_insert(&mut self,"
- "(&mut self, value: T) -> &T {"
- // Although the raw entry gives
- "raw entry gives us `&mut T`, we"
- "us `&mut T`, we only return `&T`"
- "only return `&T` to be"
- "`&T` to be consistent with"
- "// `get`."
- "Key mutation is \"raw\" because"
- "is \"raw\" because you're not"
- "you're not supposed to affect `"
- "to affect `Eq` or `Hash`."
- self.map
- ".raw_entry_mut()"
- ".from_key(&value)"
- ".or_insert(value, ())"
- "            .0\n    }"
- /// Inserts an owned copy of the
- "copy of the given `value` into"
- "`value` into the set if it is"
- the set if it is not
- "/// present, then returns a"
- ", then returns a reference to"
- a reference to the value in the
- "the value in the set.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<String>"
- "HashSet<String> = [\"cat\", \"dog\","
- "= [\"cat\", \"dog\", \"horse\"]"
- ///     .iter().map(|&pet|
- ().map(|&pet| pet.to_owned()).
- pet.to_owned()).collect();
- "    ///\n    /// assert_eq!("
- "/// assert_eq!(set.len(), 3);"
- "/// for &pet in &[\"cat\", \"dog\","
- "&[\"cat\", \"dog\", \"fish\"] {"
- ///     let value =
- value = set.get_or_insert_owned(
- "(pet);\n    ///     assert_eq!("
- "value, pet);\n    /// }"
- "    /// }\n    /// assert_eq!("
- "set.len(), 4); // a new \"fish\""
- "// a new \"fish\" was inserted"
- "    /// ```\n    #[inline]"
- "pub fn get_or_insert_owned<Q: ?"
- "Sized>(&mut self, value: &Q) ->"
- ", value: &Q) -> &T\n    where"
- "Q: Hash + Equivalent<T> +"
- Equivalent<T> + ToOwned<Owned =
- " ToOwned<Owned = T>,\n    {"
- // Although the raw entry gives
- "raw entry gives us `&mut T`, we"
- "us `&mut T`, we only return `&T`"
- "only return `&T` to be"
- "`&T` to be consistent with"
- "// `get`."
- "Key mutation is \"raw\" because"
- "is \"raw\" because you're not"
- "you're not supposed to affect `"
- "to affect `Eq` or `Hash`."
- self.map
- ".raw_entry_mut()"
- ".from_key(value)"
- ".or_insert_with(|| ("
- "(|| (value.to_owned(), ()))"
- "            .0\n    }"
- /// Inserts a value computed
- "a value computed from `f` into"
- "from `f` into the set if the"
- "the set if the given `value` is"
- "/// not present, then returns a"
- ", then returns a reference to"
- a reference to the value in the
- "the value in the set.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<String>"
- "HashSet<String> = [\"cat\", \"dog\","
- "= [\"cat\", \"dog\", \"horse\"]"
- ///     .iter().map(|&pet|
- ().map(|&pet| pet.to_owned()).
- pet.to_owned()).collect();
- "    ///\n    /// assert_eq!("
- "/// assert_eq!(set.len(), 3);"
- "/// for &pet in &[\"cat\", \"dog\","
- "&[\"cat\", \"dog\", \"fish\"] {"
- ///     let value =
- value = set.get_or_insert_with(
- "(pet, str::to_owned);"
- "///     assert_eq!(value, pet);"
- "value, pet);\n    /// }"
- "    /// }\n    /// assert_eq!("
- "set.len(), 4); // a new \"fish\""
- "// a new \"fish\" was inserted"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn get_or_insert_with<Q: ?"
- "Sized, F>(&mut self, value: &Q,"
- "self, value: &Q, f: F) -> &T"
- where
- "Q: Hash + Equivalent<T>,"
- "F: FnOnce(&Q) -> T,"
- "{"
- // Although the raw entry gives
- "raw entry gives us `&mut T`, we"
- "us `&mut T`, we only return `&T`"
- "only return `&T` to be"
- "`&T` to be consistent with"
- "// `get`."
- "Key mutation is \"raw\" because"
- "is \"raw\" because you're not"
- "you're not supposed to affect `"
- "to affect `Eq` or `Hash`."
- self.map
- ".raw_entry_mut()"
- ".from_key(value)"
- ".or_insert_with(|| (f(value), ()"
- "|| (f(value), ()))"
- "            .0\n    }"
- "/// Gets the given value's"
- "given value's corresponding"
- corresponding entry in the set
- entry in the set for in-place
- set for in-place manipulation.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_set::"
- "::hash_set::Entry::*;\n    ///"
- "/// let mut singles = HashSet::"
- "= HashSet::new();"
- "/// let mut dupes = HashSet::new"
- " = HashSet::new();\n    ///"
- "/// for ch in \"a short treatise"
- "a short treatise on fungi\".chars"
- "on fungi\".chars() {"
- ///     if let Vacant(dupe_entry
- "(dupe_entry) = dupes.entry(ch) {"
- "///         // We haven't"
- "// We haven't already seen a"
- "already seen a duplicate, so"
- "///         // check if we've at"
- "if we've at least seen it once."
- ///         match singles.entry(
- "singles.entry(ch) {"
- ///             Vacant(
- "Vacant(single_entry) => {"
- ///                 // We found
- // We found a new character for
- character for the first time.
- ///
- single_entry.insert();
- "///             }"
- ///             Occupied(
- "Occupied(single_entry) => {"
- "///                 // We've"
- "// We've already seen this once,"
- "seen this once, \"move\" it to"
- ", \"move\" it to dupes."
- ///
- single_entry.remove();
- ///
- dupe_entry.insert();
- "///             }"
- "    ///         }\n    ///     }"
- "    ///     }\n    /// }\n    ///"
- "    ///\n    /// assert!(!"
- "singles.contains(&'t') &&"
- "(&'t') && dupes.contains(&'t'));"
- /// assert!(
- "singles.contains(&'u') && !"
- "dupes.contains(&'u'));"
- /// assert!(!
- "singles.contains(&'v') && !"
- "dupes.contains(&'v'));"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn entry(&mut self, value: T"
- "self, value: T) -> Entry<'_, T,"
- "-> Entry<'_, T, S, A> {"
- "match self.map.entry(value) {"
- "map::Entry::Occupied(entry) =>"
- "(entry) => Entry::Occupied("
- "Entry::Occupied(OccupiedEntry {"
- "(OccupiedEntry { inner: entry })"
- "inner: entry }),"
- "map::Entry::Vacant(entry) =>"
- "Vacant(entry) => Entry::Vacant("
- "> Entry::Vacant(VacantEntry {"
- "(VacantEntry { inner: entry }),"
- "        }\n    }"
- "/// Returns `true` if `self` has"
- "` if `self` has no elements in"
- "no elements in common with `"
- "in common with `other`."
- /// This is equivalent to
- is equivalent to checking for an
- checking for an empty
- for an empty intersection.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let a: HashSet<_> = [1, 2, 3"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- "/// let mut b = HashSet::new();"
- "    ///\n    /// assert_eq!("
- "a.is_disjoint(&b), true);"
- /// b.insert(4);
- /// assert_eq!(
- "a.is_disjoint(&b), true);"
- /// b.insert(1);
- /// assert_eq!(
- "a.is_disjoint(&b), false);"
- "/// ```"
- "pub fn is_disjoint(&self, other:"
- "(&self, other: &Self) -> bool {"
- self.iter().all(|v| !
- "other.contains(v))\n    }"
- "/// Returns `true` if the set is"
- "` if the set is a subset of"
- "is a subset of another,"
- "/// i.e., `other` contains at"
- "` contains at least all the"
- "at least all the values in `self"
- " values in `self`.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let sup: HashSet<_> = [1, 2,"
- "<_> = [1, 2, 3].into_iter()."
- "3].into_iter().collect();"
- "/// let mut set = HashSet::new()"
- "= HashSet::new();\n    ///"
- "    ///\n    /// assert_eq!("
- "set.is_subset(&sup), true);"
- /// set.insert(2);
- /// assert_eq!(
- "set.is_subset(&sup), true);"
- /// set.insert(4);
- /// assert_eq!(
- "set.is_subset(&sup), false);"
- "/// ```"
- "pub fn is_subset(&self, other: &"
- "(&self, other: &Self) -> bool {"
- self.len() <= other.len() &&
- "= other.len() && self.iter().all"
- self.iter().all(|v|
- ().all(|v| other.contains(v))
- "}"
- "/// Returns `true` if the set is"
- "` if the set is a superset of"
- "is a superset of another,"
- "/// i.e., `self` contains at"
- "` contains at least all the"
- "at least all the values in `"
- " the values in `other`.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let sub: HashSet<_> = [1, 2]"
- "<_> = [1, 2].into_iter().collect"
- ().collect();
- "/// let mut set = HashSet::new()"
- "= HashSet::new();\n    ///"
- "    ///\n    /// assert_eq!("
- "set.is_superset(&sub), false);"
- "    ///\n    /// set.insert(0);"
- /// set.insert(1);
- /// assert_eq!(
- "set.is_superset(&sub), false);"
- "    ///\n    /// set.insert(2);"
- /// assert_eq!(
- "set.is_superset(&sub), true);"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn is_superset(&self, other:"
- "(&self, other: &Self) -> bool {"
- other.is_subset(self)
- "}"
- /// Adds a value to the set.
- ///
- /// If the set did not have this
- "not have this value present, `"
- "value present, `true` is"
- ", `true` is returned.\n    ///"
- /// If the set did have this
- "did have this value present, `"
- "value present, `false` is"
- ", `false` is returned.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set = HashSet::new()"
- "= HashSet::new();\n    ///"
- "    ///\n    /// assert_eq!("
- "set.insert(2), true);"
- /// assert_eq!(
- "set.insert(2), false);"
- "/// assert_eq!(set.len(), 1);"
- "set.len(), 1);\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn insert(&mut self, value:"
- "mut self, value: T) -> bool {"
- "self.map.insert(value, ())."
- "(value, ()).is_none()\n    }"
- /// Insert a value the set
- a value the set without checking
- without checking if the value
- if the value already exists in
- " exists in the set.\n    ///"
- /// Returns a reference to the
- reference to the value just
- the value just inserted.
- ///
- /// This operation is safe if a
- is safe if a value does not
- a value does not exist in the
- "not exist in the set.\n    ///"
- "/// However, if a value exists"
- a value exists in the set
- "in the set already, the behavior"
- ", the behavior is unspecified:"
- "/// this operation may panic,"
- "may panic, loop forever, or any"
- "forever, or any following"
- or any following operation with
- operation with the set
- "/// may panic, loop forever or"
- loop forever or return arbitrary
- return arbitrary result.
- ///
- "/// That said, this operation ("
- this operation (and following
- (and following operations) are
- operations) are guaranteed to
- /// not violate memory safety.
- ///
- /// This operation is faster
- "is faster than regular insert,"
- "regular insert, because it does"
- because it does not perform
- /// lookup before insertion.
- ///
- /// This operation is useful
- is useful during initial
- during initial population of the
- of the set.
- "/// For example, when"
- "example, when constructing a set"
- "a set from another set, we know"
- /// that values are unique.
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn insert_unique_unchecked(&
- "(&mut self, value: T) -> &T {"
- self.map.insert_unique_unchecked
- "(value, ()).0\n    }"
- "/// Adds a value to the set,"
- "to the set, replacing the"
- ", replacing the existing value,"
- "existing value, if any, that is"
- "if any, that is equal to the"
- is equal to the given
- /// one.
- Returns the replaced value.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set = HashSet::new()"
- "= HashSet::new();"
- "/// set.insert(Vec::<i32>::new()"
- "::<i32>::new());\n    ///"
- "    ///\n    /// assert_eq!("
- "set.get(&[][..]).unwrap()."
- "][..]).unwrap().capacity(), 0);"
- "/// set.replace(Vec::"
- "(Vec::with_capacity(10));"
- /// assert_eq!(
- "set.get(&[][..]).unwrap()."
- "][..]).unwrap().capacity(), 10);"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn replace(&mut self, value:"
- "mut self, value: T) -> Option<T>"
- "T) -> Option<T> {"
- "match self.map.entry(value) {"
- "map::Entry::Occupied(occupied) ="
- (occupied) => Some(
- ) => Some(occupied.replace_key()
- "()),"
- "map::Entry::Vacant(vacant) => {"
- vacant.insert(());
- None
- "            }\n        }\n    }"
- /// Removes a value from the set
- from the set.
- Returns whether the value was
- /// present in the set.
- ///
- /// The value may be any
- value may be any borrowed form
- "borrowed form of the set's value"
- "the set's value type, but"
- "/// [`Hash`] and [`Eq`] on the"
- "[`Eq`] on the borrowed form *"
- borrowed form *must* match those
- "* match those for"
- "    /// the value type.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set = HashSet::new()"
- "= HashSet::new();\n    ///"
- "    ///\n    /// set.insert(2);"
- /// assert_eq!(
- "set.remove(&2), true);"
- /// assert_eq!(
- "set.remove(&2), false);"
- "    /// ```\n    ///"
- "/// [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- /std/cmp/trait.Eq.html
- "/// [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- /std/hash/trait.Hash.html
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn remove<Q: ?"
- "Sized>(&mut self, value: &Q) ->"
- ", value: &Q) -> bool\n    where"
- "Q: Hash + Equivalent<T>,"
- "{"
- self.map.remove(value).is_some()
- "}"
- /// Removes and returns the
- and returns the value in the set
- "value in the set, if any, that"
- ", if any, that is equal to the"
- is equal to the given one.
- ///
- /// The value may be any
- value may be any borrowed form
- "borrowed form of the set's value"
- "the set's value type, but"
- "/// [`Hash`] and [`Eq`] on the"
- "[`Eq`] on the borrowed form *"
- borrowed form *must* match those
- "* match those for"
- "    /// the value type.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<_> = [1"
- "HashSet<_> = [1, 2, 3].into_iter"
- "2, 3].into_iter().collect();"
- /// assert_eq!(
- "set.take(&2), Some(2));"
- /// assert_eq!(
- "set.take(&2), None);\n    /// ```"
- "    /// ```\n    ///"
- "/// [`Eq`]: https://doc.rust-"
- "://doc.rust-lang.org/std/cmp/"
- /std/cmp/trait.Eq.html
- "/// [`Hash`]: https://doc.rust-"
- "://doc.rust-lang.org/std/hash/"
- /std/hash/trait.Hash.html
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn take<Q: ?"
- "Sized>(&mut self, value: &Q) ->"
- ", value: &Q) -> Option<T>"
- where
- "Q: Hash + Equivalent<T>,"
- "{"
- "// Avoid `Option::map` because"
- "::map` because it bloats LLVM IR"
- bloats LLVM IR.
- match self.map.remove_entry(
- "(value) {"
- "Some((k, _)) => Some(k),"
- "None => None,"
- "        }\n    }\n}"
- "impl<T, S, A: Allocator> HashSet"
- "> HashSet<T, S, A> {"
- "/// Returns a reference to the ["
- "to the [`RawTable`] used"
- "`RawTable`] used underneath [`"
- "underneath [`HashSet`]."
- /// This function is only
- function is only available if
- "available if the `raw` feature"
- "`raw` feature of the crate is"
- of the crate is enabled.
- "    ///\n    /// # Note\n    ///"
- /// Calling this function is
- "this function is safe, but using"
- "safe, but using the raw hash"
- the raw hash table API may
- table API may require
- /// unsafe functions or blocks.
- ///
- "/// `RawTable` API gives the"
- "` API gives the lowest level of"
- lowest level of control under
- of control under the set that
- the set that can be useful
- "/// for extending the HashSet's"
- "the HashSet's API, but may lead"
- ", but may lead to *[undefined"
- "to *[undefined behavior]*."
- ///
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`RawTable`]: crate::raw::"
- "`]: crate::raw::RawTable"
- "/// [undefined behavior]: https:"
- "]: https://doc.rust-lang.org/"
- "-lang.org/reference/behavior-"
- /behavior-considered-
- "-considered-undefined.html"
- "#[cfg(feature = \"raw\")]"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn raw_table(&self) -> &
- "(&self) -> &RawTable<(T, ()), A>"
- "<(T, ()), A> {"
- self.map.raw_table()
- "}"
- /// Returns a mutable reference
- "reference to the [`RawTable`]"
- "the [`RawTable`] used underneath"
- "used underneath [`HashSet`]."
- /// This function is only
- function is only available if
- "available if the `raw` feature"
- "`raw` feature of the crate is"
- of the crate is enabled.
- "    ///\n    /// # Note\n    ///"
- /// Calling this function is
- "this function is safe, but using"
- "safe, but using the raw hash"
- the raw hash table API may
- table API may require
- /// unsafe functions or blocks.
- ///
- "/// `RawTable` API gives the"
- "` API gives the lowest level of"
- lowest level of control under
- of control under the set that
- the set that can be useful
- "/// for extending the HashSet's"
- "the HashSet's API, but may lead"
- ", but may lead to *[undefined"
- "to *[undefined behavior]*."
- ///
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`RawTable`]: crate::raw::"
- "`]: crate::raw::RawTable"
- "/// [undefined behavior]: https:"
- "]: https://doc.rust-lang.org/"
- "-lang.org/reference/behavior-"
- /behavior-considered-
- "-considered-undefined.html"
- "#[cfg(feature = \"raw\")]"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn raw_table_mut(&mut self)
- "(&mut self) -> &mut RawTable<(T,"
- "mut RawTable<(T, ()), A> {"
- self.map.raw_table_mut()
- "    }\n}"
- "impl<T, S, A> PartialEq for"
- "A> PartialEq for HashSet<T, S, A"
- " HashSet<T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "fn eq(&self, other: &Self) ->"
- "other: &Self) -> bool {"
- "if self.len() != other.len() {"
- return false;
- "}"
- self.iter().all(|key|
- ().all(|key| other.contains(key)
- "(key))\n    }\n}"
- "impl<T, S, A> Eq for HashSet<T,"
- " for HashSet<T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{\n}"
- "impl<T, S, A> fmt::Debug for"
- "> fmt::Debug for HashSet<T, S, A"
- " HashSet<T, S, A>\nwhere"
- "where\n    T: fmt::Debug,"
- "    A: Allocator,\n{"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- f.debug_set().entries(self.iter(
- "(self.iter()).finish()\n    }\n}"
- "impl<T, S, A> From<HashMap<T, ()"
- "<HashMap<T, (), S, A>> for"
- ", (), S, A>> for HashSet<T, S, A"
- " HashSet<T, S, A>\nwhere"
- "where\n    A: Allocator,\n{"
- "fn from(map: HashMap<T, (), S, A"
- "<T, (), S, A>) -> Self {"
- "        Self { map }\n    }\n}"
- "impl<T, S, A> FromIterator<T>"
- "FromIterator<T> for HashSet<T, S"
- "for HashSet<T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher + Default,"
- "    A: Default + Allocator,\n{"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn from_iter<I: IntoIterator<"
- "I: IntoIterator<Item = T>>(iter:"
- "Item = T>>(iter: I) -> Self {"
- "let mut set = Self::"
- "mut set = Self::with_hasher_in("
- ":with_hasher_in(Default::default"
- "Default::default(), Default::"
- "(), Default::default());"
- set.extend(iter);
- "        set\n    }\n}"
- // The default hasher is used to
- is used to match the std
- to match the std implementation
- implementation signature
- "#[cfg(feature = \"ahash\")]"
- "impl<T, A, const N: usize> From<"
- "N: usize> From<[T; N]> for"
- "From<[T; N]> for HashSet<T,"
- "HashSet<T, DefaultHashBuilder, A"
- ", A>\nwhere\n    T: Eq + Hash,"
- "    A: Default + Allocator,\n{"
- "{\n    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let set1 = HashSet::from([1,"
- "::from([1, 2, 3, 4]);"
- "/// let set2: HashSet<_> = [1, 2"
- "<_> = [1, 2, 3, 4].into();"
- "/// assert_eq!(set1, set2);"
- "set1, set2);\n    /// ```"
- "fn from(arr: [T; N]) -> Self {"
- arr.into_iter().collect()
- "    }\n}"
- "impl<T, S, A> Extend<T> for"
- "A> Extend<T> for HashSet<T, S, A"
- " HashSet<T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn extend<I: IntoIterator<Item ="
- "<Item = T>>(&mut self, iter: I)"
- "self, iter: I) {"
- self.map.extend(iter.into_iter()
- "iter.into_iter().map(|k| (k, ())"
- ".map(|k| (k, ())));\n    }"
- "    }\n\n    #[inline]"
- "#[cfg(feature = \"nightly\")]"
- "fn extend_one(&mut self, k: T) {"
- "self.map.insert(k, ());"
- "    }\n\n    #[inline]"
- "#[cfg(feature = \"nightly\")]"
- "fn extend_reserve(&mut self,"
- "(&mut self, additional: usize) {"
- "Extend::<(T, ())>::"
- "::<(T, ())>::extend_reserve(&mut"
- "(&mut self.map, additional);"
- "    }\n}"
- "impl<'a, T, S, A> Extend<&'a T>"
- "A> Extend<&'a T> for HashSet<T,"
- "> for HashSet<T, S, A>\nwhere"
- "T: 'a + Eq + Hash + Copy,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn extend<I: IntoIterator<Item ="
- "<Item = &'a T>>(&mut self, iter:"
- "&mut self, iter: I) {"
- self.extend(iter.into_iter().
- "().copied());\n    }"
- "    }\n\n    #[inline]"
- "#[cfg(feature = \"nightly\")]"
- "fn extend_one(&mut self, k: &'a"
- "mut self, k: &'a T) {"
- "self.map.insert(*k, ());"
- "    }\n\n    #[inline]"
- "#[cfg(feature = \"nightly\")]"
- "fn extend_reserve(&mut self,"
- "(&mut self, additional: usize) {"
- "Extend::<(T, ())>::"
- "::<(T, ())>::extend_reserve(&mut"
- "(&mut self.map, additional);"
- "    }\n}"
- "impl<T, S, A> Default for"
- ", A> Default for HashSet<T, S, A"
- " HashSet<T, S, A>\nwhere"
- "where\n    S: Default,"
- "    A: Default + Allocator,\n{"
- "/// Creates an empty `HashSet<T,"
- "`HashSet<T, S>` with the `"
- ", S>` with the `Default` value"
- "`Default` value for the hasher."
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn default() -> Self {"
- "Self {"
- "map: HashMap::default(),"
- "        }\n    }\n}"
- "impl<T, S, A> BitOr<&HashSet<T,"
- "<&HashSet<T, S, A>> for &HashSet"
- "A>> for &HashSet<T, S, A>\nwhere"
- "where\n    T: Eq + Hash + Clone,"
- "S: BuildHasher + Default,"
- "    A: Allocator,\n{"
- "type Output = HashSet<T, S>;"
- "/// Returns the union of `self`"
- "union of `self` and `rhs` as a"
- "` and `rhs` as a new `HashSet<T,"
- " new `HashSet<T, S>`.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();"
- "/// let b: HashSet<_> = vec!["
- "3, 4, 5].into_iter().collect();"
- ///
- /// let set = &a | &b;
- "    ///\n    /// let mut i = 0;"
- "/// let expected = [1, 2, 3, 4,"
- "= [1, 2, 3, 4, 5];"
- "/// for x in &set {"
- ///     assert!(
- expected.contains(x));
- "    ///     i += 1;\n    /// }"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```"
- "fn bitor(self, rhs: &HashSet<T,"
- "rhs: &HashSet<T, S, A>) ->"
- "<T, S, A>) -> HashSet<T, S> {"
- self.union(rhs).cloned().collect
- "cloned().collect()\n    }\n}"
- "impl<T, S, A> BitAnd<&HashSet<T,"
- "<&HashSet<T, S, A>> for &HashSet"
- "A>> for &HashSet<T, S, A>\nwhere"
- "where\n    T: Eq + Hash + Clone,"
- "S: BuildHasher + Default,"
- "    A: Allocator,\n{"
- "type Output = HashSet<T, S>;"
- /// Returns the intersection of
- "intersection of `self` and `rhs`"
- "`self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();"
- "/// let b: HashSet<_> = vec!["
- "2, 3, 4].into_iter().collect();"
- ///
- /// let set = &a & &b;
- "    ///\n    /// let mut i = 0;"
- "/// let expected = [2, 3];"
- "/// for x in &set {"
- ///     assert!(
- expected.contains(x));
- "    ///     i += 1;\n    /// }"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```"
- "fn bitand(self, rhs: &HashSet<T,"
- "rhs: &HashSet<T, S, A>) ->"
- "<T, S, A>) -> HashSet<T, S> {"
- self.intersection(rhs).cloned().
- "(rhs).cloned().collect()\n    }\n}"
- "impl<T, S> BitXor<&HashSet<T, S>"
- "<&HashSet<T, S>> for &HashSet<T,"
- " for &HashSet<T, S>\nwhere"
- "where\n    T: Eq + Hash + Clone,"
- "    S: BuildHasher + Default,\n{"
- "type Output = HashSet<T, S>;"
- /// Returns the symmetric
- "the symmetric difference of `"
- "difference of `self` and `rhs`"
- "`self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();"
- "/// let b: HashSet<_> = vec!["
- "3, 4, 5].into_iter().collect();"
- ///
- /// let set = &a ^ &b;
- "    ///\n    /// let mut i = 0;"
- "/// let expected = [1, 2, 4, 5];"
- "/// for x in &set {"
- ///     assert!(
- expected.contains(x));
- "    ///     i += 1;\n    /// }"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```"
- "fn bitxor(self, rhs: &HashSet<T,"
- "rhs: &HashSet<T, S>) -> HashSet<"
- "S>) -> HashSet<T, S> {"
- self.symmetric_difference(rhs).
- "(rhs).cloned().collect()\n    }\n}"
- "impl<T, S> Sub<&HashSet<T, S>>"
- "<&HashSet<T, S>> for &HashSet<T,"
- " for &HashSet<T, S>\nwhere"
- "where\n    T: Eq + Hash + Clone,"
- "    S: BuildHasher + Default,\n{"
- "type Output = HashSet<T, S>;"
- "/// Returns the difference of `"
- "difference of `self` and `rhs`"
- "`self` and `rhs` as a new `"
- "`rhs` as a new `HashSet<T, S>`."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let a: HashSet<_> = vec!["
- "1, 2, 3].into_iter().collect();"
- "/// let b: HashSet<_> = vec!["
- "3, 4, 5].into_iter().collect();"
- ///
- /// let set = &a - &b;
- "    ///\n    /// let mut i = 0;"
- "/// let expected = [1, 2];"
- "/// for x in &set {"
- ///     assert!(
- expected.contains(x));
- "    ///     i += 1;\n    /// }"
- "    /// }\n    /// assert_eq!("
- "i, expected.len());\n    /// ```"
- "fn sub(self, rhs: &HashSet<T, S>"
- ": &HashSet<T, S>) -> HashSet<T,"
- ">) -> HashSet<T, S> {"
- self.difference(rhs).cloned().
- "(rhs).cloned().collect()\n    }\n}"
- /// An iterator over the items
- "over the items of a `HashSet`."
- ///
- "/// This `struct` is created by"
- "` is created by the [`iter`]"
- "by the [`iter`] method on [`"
- "`] method on [`HashSet`]."
- /// See its documentation for
- " for more.\n///"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`iter`]:"
- "// [`iter`]: struct.HashSet.html"
- "#method.iter"
- "pub struct Iter<'a, K> {"
- "    iter: Keys<'a, K, ()>,\n}"
- /// An owning iterator over the
- "over the items of a `HashSet`."
- ///
- "/// This `struct` is created by"
- "` is created by the [`into_iter`"
- "the [`into_iter`] method on [`"
- "`] method on [`HashSet`]"
- "/// (provided by the `"
- "by the `IntoIterator` trait)."
- See its documentation for more.
- ///
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`into_iter`]:"
- "into_iter`]: struct.HashSet.html"
- "#method.into_iter"
- "pub struct IntoIter<K, A:"
- "IntoIter<K, A: Allocator ="
- ", A: Allocator = Global> {"
- "iter: map::IntoIter<K, (), A>,"
- "}"
- /// A draining iterator over the
- "over the items of a `HashSet`."
- ///
- "/// This `struct` is created by"
- "` is created by the [`drain`]"
- "by the [`drain`] method on [`"
- "`] method on [`HashSet`]."
- /// See its documentation for
- " for more.\n///"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`drain`]:"
- "/ [`drain`]: struct.HashSet.html"
- "#method.drain"
- "pub struct Drain<'a, K, A:"
- "Drain<'a, K, A: Allocator ="
- ", A: Allocator = Global> {"
- "iter: map::Drain<'a, K, (), A>,"
- "}"
- /// A draining iterator over
- "iterator over entries of a `"
- "entries of a `HashSet` which"
- "`HashSet` which don't satisfy"
- "don't satisfy the predicate `f`."
- ///
- "/// This `struct` is created by"
- "` is created by the [`extract_if"
- "the [`extract_if`] method on [`"
- "`] method on [`HashSet`]."
- See its
- "/// documentation for more.\n///"
- "/// [`extract_if`]:"
- "`]: struct.HashSet.html#"
- "#method.extract_if"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "#[must_use = \"Iterators are lazy"
- "are lazy unless consumed\"]"
- "pub struct ExtractIf<'a, K, F, A"
- "<'a, K, F, A: Allocator = Global"
- " = Global>\nwhere"
- "where\n    F: FnMut(&K) -> bool,"
- "{\n    f: F,"
- "inner: RawExtractIf<'a, (K, ()),"
- "<'a, (K, ()), A>,\n}"
- /// A lazy iterator producing
- producing elements in the
- elements in the intersection of
- " intersection of `HashSet`s.\n///"
- "/// This `struct` is created by"
- "` is created by the [`"
- "by the [`intersection`] method"
- "`] method on [`HashSet`]."
- /// See its documentation for
- " for more.\n///"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`intersection`]:"
- "`]: struct.HashSet.html#"
- "#method.intersection"
- "pub struct Intersection<'a, T, S"
- "<'a, T, S, A: Allocator = Global"
- "= Global> {"
- // iterator of the first set
- "iter: Iter<'a, T>,"
- // the second set
- "other: &'a HashSet<T, S, A>,"
- "}"
- /// A lazy iterator producing
- producing elements in the
- "elements in the difference of `"
- " difference of `HashSet`s.\n///"
- "/// This `struct` is created by"
- "` is created by the [`difference"
- "the [`difference`] method on [`"
- "`] method on [`HashSet`]."
- /// See its documentation for
- " for more.\n///"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`difference`]:"
- "`]: struct.HashSet.html#"
- "#method.difference"
- "pub struct Difference<'a, T, S,"
- "<'a, T, S, A: Allocator = Global"
- "= Global> {"
- // iterator of the first set
- "iter: Iter<'a, T>,"
- // the second set
- "other: &'a HashSet<T, S, A>,"
- "}"
- /// A lazy iterator producing
- producing elements in the
- elements in the symmetric
- "in the symmetric difference of `"
- " difference of `HashSet`s.\n///"
- "/// This `struct` is created by"
- "` is created by the [`"
- "by the [`symmetric_difference`]"
- "`] method on\n/// [`HashSet`]."
- See its documentation for more.
- ///
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`symmetric_difference`]:"
- "`]: struct.HashSet.html#"
- "#method.symmetric_difference"
- "pub struct SymmetricDifference<'"
- "<'a, T, S, A: Allocator = Global"
- "= Global> {"
- "iter: Chain<Difference<'a, T, S,"
- "<'a, T, S, A>, Difference<'a, T,"
- "<'a, T, S, A>>,\n}"
- /// A lazy iterator producing
- producing elements in the union
- " in the union of `HashSet`s.\n///"
- "/// This `struct` is created by"
- "` is created by the [`union`]"
- "by the [`union`] method on [`"
- "`] method on [`HashSet`]."
- /// See its documentation for
- " for more.\n///"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`union`]:"
- "/ [`union`]: struct.HashSet.html"
- "#method.union"
- "pub struct Union<'a, T, S, A:"
- "<'a, T, S, A: Allocator = Global"
- "= Global> {"
- "iter: Chain<Iter<'a, T>,"
- "<Iter<'a, T>, Difference<'a, T,"
- "<'a, T, S, A>>,\n}"
- "impl<'a, T, S, A: Allocator>"
- "S, A: Allocator> IntoIterator"
- "> IntoIterator for &'a HashSet<T"
- "&'a HashSet<T, S, A> {"
- "type Item = &'a T;"
- "type IntoIter = Iter<'a, T>;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn into_iter(self) -> Iter<'a, T"
- ") -> Iter<'a, T> {"
- "        self.iter()\n    }\n}"
- "impl<T, S, A: Allocator>"
- "S, A: Allocator> IntoIterator"
- "> IntoIterator for HashSet<T, S,"
- "HashSet<T, S, A> {"
- type Item = T;
- "type IntoIter = IntoIter<T, A>;"
- /// Creates a consuming iterator
- "iterator, that is, one that"
- "is, one that moves each value"
- moves each value out
- /// of the set in arbitrary
- set in arbitrary order.
- The set cannot be used after
- be used after calling
- "    /// this.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// let mut set = HashSet::new()"
- "= HashSet::new();"
- "/// set.insert(\"a\".to_string());"
- "/// set.insert(\"b\".to_string());"
- ///
- /// // Not possible to collect
- to collect to a Vec<String> with
- "Vec<String> with a regular `."
- "a regular `.iter()`."
- "/// let v: Vec<String> ="
- "v: Vec<String> = set.into_iter()"
- set.into_iter().collect();
- ///
- /// // Will print in an
- Will print in an arbitrary order
- arbitrary order.
- "/// for x in &v {"
- "///     println!(\"{}\", x);"
- "    /// }\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- fn into_iter(self) -> IntoIter<T
- ") -> IntoIter<T, A> {"
- "IntoIter {"
- "iter: self.map.into_iter(),"
- "        }\n    }\n}"
- "impl<K> Clone for Iter<'_, K> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn clone(&self) -> Self {"
- "Iter {"
- "iter: self.iter.clone(),"
- "        }\n    }\n}"
- "impl<'a, K> Iterator for Iter<'a"
- "for Iter<'a, K> {"
- "type Item = &'a K;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn next(&mut self) -> Option<&'a"
- ") -> Option<&'a K> {"
- "        self.iter.next()\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- self.iter.size_hint()
- "}"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, f:"
- ", init: B, f: F) -> B\n    where"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, f)"
- "    }\n}"
- "impl<'a, K> ExactSizeIterator"
- "for Iter<'a, K> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn len(&self) -> usize {"
- "        self.iter.len()\n    }\n}"
- "impl<K> FusedIterator for Iter<'"
- "for Iter<'_, K> {}"
- "impl<K: fmt::Debug> fmt::Debug"
- "> fmt::Debug for Iter<'_, K> {"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- f.debug_list().entries(
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}"
- "impl<K, A: Allocator> Iterator"
- "> Iterator for IntoIter<K, A> {"
- type Item = K;
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- fn next(&mut self) -> Option<K>
- ") -> Option<K> {"
- "// Avoid `Option::map` because"
- "::map` because it bloats LLVM IR"
- bloats LLVM IR.
- "match self.iter.next() {"
- "Some((k, _)) => Some(k),"
- "None => None,"
- "        }\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- self.iter.size_hint()
- "}"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, mut"
- ", init: B, mut f: F) -> B"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, |acc, (k, ("
- ", |acc, (k, ())| f(acc, k))"
- "    }\n}"
- "impl<K, A: Allocator>"
- "A: Allocator> ExactSizeIterator"
- "for IntoIter<K, A> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn len(&self) -> usize {"
- "        self.iter.len()\n    }\n}"
- "impl<K, A: Allocator>"
- "K, A: Allocator> FusedIterator"
- "> FusedIterator for IntoIter<K,"
- "for IntoIter<K, A> {}"
- "impl<K: fmt::Debug, A: Allocator"
- ", A: Allocator> fmt::Debug for"
- "> fmt::Debug for IntoIter<K, A>"
- "IntoIter<K, A> {"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- let entries_iter =
- entries_iter = self.iter.iter().
- "().map(|(k, _)| k);"
- f.debug_list().entries(
- ().entries(entries_iter).finish(
- ").finish()\n    }\n}"
- "impl<K, A: Allocator> Iterator"
- "> Iterator for Drain<'_, K, A> {"
- type Item = K;
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- fn next(&mut self) -> Option<K>
- ") -> Option<K> {"
- "// Avoid `Option::map` because"
- "::map` because it bloats LLVM IR"
- bloats LLVM IR.
- "match self.iter.next() {"
- "Some((k, _)) => Some(k),"
- "None => None,"
- "        }\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- self.iter.size_hint()
- "}"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, mut"
- ", init: B, mut f: F) -> B"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, |acc, (k, ("
- ", |acc, (k, ())| f(acc, k))"
- "    }\n}"
- "impl<K, A: Allocator>"
- "A: Allocator> ExactSizeIterator"
- "for Drain<'_, K, A> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn len(&self) -> usize {"
- "        self.iter.len()\n    }\n}"
- "impl<K, A: Allocator>"
- "K, A: Allocator> FusedIterator"
- "> FusedIterator for Drain<'_, K,"
- "for Drain<'_, K, A> {}"
- "impl<K: fmt::Debug, A: Allocator"
- ", A: Allocator> fmt::Debug for"
- "> fmt::Debug for Drain<'_, K, A>"
- "Drain<'_, K, A> {"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- let entries_iter =
- entries_iter = self.iter.iter().
- "().map(|(k, _)| k);"
- f.debug_list().entries(
- ().entries(entries_iter).finish(
- ").finish()\n    }\n}"
- "impl<K, F, A: Allocator>"
- "F, A: Allocator> Iterator for"
- "> Iterator for ExtractIf<'_, K,"
- " ExtractIf<'_, K, F, A>\nwhere"
- "where\n    F: FnMut(&K) -> bool,"
- "{\n    type Item = K;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- fn next(&mut self) -> Option<
- "self) -> Option<Self::Item> {"
- self.inner
- ".next(|&mut (ref k, ())| (self.f"
- "k, ())| (self.f)(k))"
- ".map(|(k, ())| k)"
- "    }\n\n    #[inline]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- "(0, self.inner.iter.size_hint()."
- "().1)\n    }\n}"
- "impl<K, F, A: Allocator>"
- "F, A: Allocator> FusedIterator"
- "> FusedIterator for ExtractIf<'_"
- "for ExtractIf<'_, K, F, A> where"
- ", K, F, A> where F: FnMut(&K) ->"
- "F: FnMut(&K) -> bool {}"
- "impl<T, S, A: Allocator> Clone"
- Allocator> Clone for
- "> Clone for Intersection<'_, T,"
- "<'_, T, S, A> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn clone(&self) -> Self {"
- "Intersection {"
- "iter: self.iter.clone(),"
- "            ..*self\n        }"
- "        }\n    }\n}"
- "impl<'a, T, S, A> Iterator for"
- "A> Iterator for Intersection<'a,"
- "Intersection<'a, T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "{\n    type Item = &'a T;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn next(&mut self) -> Option<&'a"
- ") -> Option<&'a T> {"
- "loop {"
- let elt = self.iter.next()?;
- "if self.other.contains(elt) {"
- return Some(elt);
- "            }\n        }\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- "let (_, upper) ="
- "(_, upper) = self.iter.size_hint"
- "();\n        (0, upper)\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, mut"
- ", init: B, mut f: F) -> B"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, |acc, elt|"
- "init, |acc, elt| {"
- "if self.other.contains(elt) {"
- "f(acc, elt)"
- "} else {"
- acc
- "            }\n        })\n    }\n}"
- "impl<T, S, A> fmt::Debug for"
- "> fmt::Debug for Intersection<'_"
- " Intersection<'_, T, S, A>\nwhere"
- "T: fmt::Debug + Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- f.debug_list().entries(
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}"
- "impl<T, S, A> FusedIterator for"
- "for Intersection<'_, T, S, A>"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{\n}"
- "impl<T, S, A: Allocator> Clone"
- Allocator> Clone for Difference<
- "for Difference<'_, T, S, A> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn clone(&self) -> Self {"
- "Difference {"
- "iter: self.iter.clone(),"
- "            ..*self\n        }"
- "        }\n    }\n}"
- "impl<'a, T, S, A> Iterator for"
- "A> Iterator for Difference<'a, T"
- " Difference<'a, T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "{\n    type Item = &'a T;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn next(&mut self) -> Option<&'a"
- ") -> Option<&'a T> {"
- "loop {"
- let elt = self.iter.next()?;
- ";\n            if !"
- "if !self.other.contains(elt) {"
- return Some(elt);
- "            }\n        }\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- "let (_, upper) ="
- "(_, upper) = self.iter.size_hint"
- "();\n        (0, upper)\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, mut"
- ", init: B, mut f: F) -> B"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, |acc, elt|"
- "init, |acc, elt| {"
- "if self.other.contains(elt) {"
- acc
- "} else {"
- "f(acc, elt)"
- "            }\n        })\n    }\n}"
- "impl<T, S, A> FusedIterator for"
- "for Difference<'_, T, S, A>"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{\n}"
- "impl<T, S, A> fmt::Debug for"
- "> fmt::Debug for Difference<'_,"
- " Difference<'_, T, S, A>\nwhere"
- "T: fmt::Debug + Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- f.debug_list().entries(
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}"
- "impl<T, S, A: Allocator> Clone"
- Allocator> Clone for
- "> Clone for SymmetricDifference<"
- "<'_, T, S, A> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn clone(&self) -> Self {"
- "SymmetricDifference {"
- "iter: self.iter.clone(),"
- "        }\n    }\n}"
- "impl<'a, T, S, A> Iterator for"
- Iterator for SymmetricDifference
- "<'a, T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "{\n    type Item = &'a T;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn next(&mut self) -> Option<&'a"
- ") -> Option<&'a T> {"
- "        self.iter.next()\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- self.iter.size_hint()
- "}"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, f:"
- ", init: B, f: F) -> B\n    where"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, f)"
- "    }\n}"
- "impl<T, S, A> FusedIterator for"
- "for SymmetricDifference<'_, T, S"
- "<'_, T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{\n}"
- "impl<T, S, A> fmt::Debug for"
- "::Debug for SymmetricDifference<"
- "<'_, T, S, A>\nwhere"
- "T: fmt::Debug + Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- f.debug_list().entries(
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}"
- "impl<T, S, A: Allocator> Clone"
- "Allocator> Clone for Union<'_, T"
- "for Union<'_, T, S, A> {"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn clone(&self) -> Self {"
- "Union {"
- "iter: self.iter.clone(),"
- "        }\n    }\n}"
- "impl<T, S, A> FusedIterator for"
- " for Union<'_, T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{\n}"
- "impl<T, S, A> fmt::Debug for"
- "> fmt::Debug for Union<'_, T, S,"
- " Union<'_, T, S, A>\nwhere"
- "T: fmt::Debug + Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- f.debug_list().entries(
- ().entries(self.clone()).finish(
- "()).finish()\n    }\n}"
- "impl<'a, T, S, A> Iterator for"
- "A> Iterator for Union<'a, T, S,"
- " Union<'a, T, S, A>\nwhere"
- "where\n    T: Eq + Hash,"
- "S: BuildHasher,"
- "    A: Allocator,\n{"
- "{\n    type Item = &'a T;"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn next(&mut self) -> Option<&'a"
- ") -> Option<&'a T> {"
- "        self.iter.next()\n    }"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn size_hint(&self) -> (usize,"
- "self) -> (usize, Option<usize>)"
- ", Option<usize>) {"
- self.iter.size_hint()
- "}"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "fn fold<B, F>(self, init: B, f:"
- ", init: B, f: F) -> B\n    where"
- "    where\n        Self: Sized,"
- "F: FnMut(B, Self::Item) -> B,"
- "{"
- "self.iter.fold(init, f)"
- "    }\n}"
- /// A view into a single entry
- "a single entry in a set, which"
- "in a set, which may either be"
- may either be vacant or occupied
- " or occupied.\n///"
- "/// This `enum` is constructed"
- "` is constructed from the [`"
- "from the [`entry`] method on [`"
- "`] method on [`HashSet`].\n///"
- "/// [`HashSet`]:"
- "[`HashSet`]: struct.HashSet.html"
- "/// [`entry`]:"
- "/ [`entry`]: struct.HashSet.html"
- "#method.entry\n///\n/// # Examples"
- "/// # Examples\n///\n/// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet,"
- "{Entry, HashSet, OccupiedEntry};"
- ///
- "/// let mut set = HashSet::new()"
- "= HashSet::new();"
- "/// set.extend([\"a\", \"b\", \"c\"]);"
- "/// assert_eq!(set.len(), 3);"
- "set.len(), 3);\n///"
- /// // Existing value (insert)
- "/// let entry: Entry<_, _> ="
- ": Entry<_, _> = set.entry(\"a\");"
- "/// let _raw_o: OccupiedEntry<_,"
- "OccupiedEntry<_, _> ="
- "<_, _> = entry.insert();"
- "/// assert_eq!(set.len(), 3);"
- /// // Nonexistent value (insert
- value (insert)
- "/// set.entry(\"d\").insert();\n///"
- /// // Existing value (or_insert
- value (or_insert)
- "/// set.entry(\"b\").or_insert();"
- /// // Nonexistent value (
- value (or_insert)
- "/// set.entry(\"e\").or_insert();"
- "///\n/// println!(\""
- "Our HashSet: {:?}\", set);\n///"
- "/// let mut vec: Vec<_> ="
- "vec: Vec<_> = set.iter().copied("
- ().copied().collect();
- "/// // The `Iter` iterator"
- "`Iter` iterator produces items"
- produces items in arbitrary
- "in arbitrary order, so the"
- /// // items must be sorted to
- be sorted to test them against a
- them against a sorted array.
- /// vec.sort_unstable();
- /// assert_eq!(
- "vec, [\"a\", \"b\", \"c\", \"d\", \"e\"]);"
- "/// ```"
- "pub enum Entry<'a, T, S, A ="
- "<'a, T, S, A = Global>\nwhere"
- "where\n    A: Allocator,\n{"
- "{\n    /// An occupied entry."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet};"
- "/// let mut set: HashSet<_> = [\""
- "HashSet<_> = [\"a\", \"b\"].into();"
- ///
- "/// match set.entry(\"a\") {"
- "///     Entry::Vacant(_) =>"
- "::Vacant(_) => unreachable!(),"
- "///     Entry::Occupied(_) => {"
- "Occupied(_) => { }\n    /// }"
- "    /// }\n    /// ```"
- "Occupied(OccupiedEntry<'a, T, S,"
- "<'a, T, S, A>),"
- "    /// A vacant entry.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet};"
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- ///
- "/// match set.entry(\"a\") {"
- "///     Entry::Occupied(_) =>"
- "::Occupied(_) => unreachable!(),"
- "///     Entry::Vacant(_) => { }"
- "    /// }\n    /// ```"
- "Vacant(VacantEntry<'a, T, S, A>)"
- "<'a, T, S, A>),\n}"
- "impl<T: fmt::Debug, S, A:"
- "::Debug, S, A: Allocator> fmt::"
- "Allocator> fmt::Debug for Entry<"
- "Debug for Entry<'_, T, S, A> {"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- "match *self {"
- "Entry::Vacant(ref v) =>"
- "Vacant(ref v) => f.debug_tuple(\""
- "f.debug_tuple(\"Entry\").field(v)."
- "\").field(v).finish(),"
- "Entry::Occupied(ref o) =>"
- "(ref o) => f.debug_tuple(\"Entry\""
- "(\"Entry\").field(o).finish(),"
- "        }\n    }\n}"
- /// A view into an occupied
- "into an occupied entry in a `"
- "entry in a `HashSet`."
- "/// It is part of the [`Entry`]"
- " of the [`Entry`] enum.\n///"
- "/// [`Entry`]: enum.Entry.html"
- "///\n/// # Examples\n///\n/// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet,"
- "{Entry, HashSet, OccupiedEntry};"
- ///
- "/// let mut set = HashSet::new()"
- "= HashSet::new();"
- "/// set.extend([\"a\", \"b\", \"c\"]);"
- ///
- "/// let _entry_o: OccupiedEntry<"
- ": OccupiedEntry<_, _> ="
- "<_, _> = set.entry(\"a\").insert()"
- "(\"a\").insert();\n/// assert_eq!("
- "/// assert_eq!(set.len(), 3);"
- "set.len(), 3);\n///"
- "///\n/// // Existing key"
- "/// match set.entry(\"a\") {"
- "///     Entry::Vacant(_) =>"
- "::Vacant(_) => unreachable!(),"
- "///     Entry::Occupied(view) =>"
- "(view) => {"
- ///         assert_eq!(
- "view.get(), &\"a\");\n///     }"
- "///     }\n/// }\n///"
- "/// }\n///\n/// assert_eq!("
- "/// assert_eq!(set.len(), 3);"
- "set.len(), 3);\n///"
- "///\n/// // Existing key (take)"
- "/// match set.entry(\"c\") {"
- "///     Entry::Vacant(_) =>"
- "::Vacant(_) => unreachable!(),"
- "///     Entry::Occupied(view) =>"
- "(view) => {"
- ///         assert_eq!(
- "view.remove(), \"c\");\n///     }"
- "///     }\n/// }\n/// assert_eq!("
- "set.get(&\"c\"), None);"
- "/// assert_eq!(set.len(), 2);"
- "set.len(), 2);\n/// ```"
- "pub struct OccupiedEntry<'a, T,"
- "<'a, T, S, A: Allocator = Global"
- "= Global> {"
- "inner: map::OccupiedEntry<'a, T,"
- "<'a, T, (), S, A>,\n}"
- "impl<T: fmt::Debug, S, A:"
- "::Debug, S, A: Allocator> fmt::"
- "Allocator> fmt::Debug for"
- "> fmt::Debug for OccupiedEntry<'"
- "OccupiedEntry<'_, T, S, A> {"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- "f.debug_struct(\"OccupiedEntry\")"
- ".field(\"value\", self.get())"
- "            .finish()\n    }\n}"
- /// A view into a vacant entry
- "a vacant entry in a `HashSet`."
- "/// It is part of the [`Entry`]"
- " of the [`Entry`] enum.\n///"
- "/// [`Entry`]: enum.Entry.html"
- "///\n/// # Examples\n///\n/// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet,"
- "{Entry, HashSet, VacantEntry};"
- ///
- "/// let mut set = HashSet::<&str"
- "= HashSet::<&str>::new();\n///"
- "/// let entry_v: VacantEntry<_,"
- ": VacantEntry<_, _> = match"
- "<_, _> = match set.entry(\"a\") {"
- "///     Entry::Vacant(view) =>"
- ":Vacant(view) => view,"
- "///     Entry::Occupied(_) =>"
- "::Occupied(_) => unreachable!(),"
- "/// };\n/// entry_v.insert();"
- /// assert!(
- "set.contains(\"a\") && set.len() ="
- ") && set.len() == 1);\n///"
- /// // Nonexistent key (insert)
- "/// match set.entry(\"b\") {"
- "///     Entry::Vacant(view) => {"
- "(view) => { view.insert(); },"
- "///     Entry::Occupied(_) =>"
- "::Occupied(_) => unreachable!(),"
- "/// }\n/// assert!("
- "set.contains(\"b\") && set.len() ="
- ") && set.len() == 2);\n/// ```"
- "pub struct VacantEntry<'a, T, S,"
- "<'a, T, S, A: Allocator = Global"
- "= Global> {"
- "inner: map::VacantEntry<'a, T, ("
- "<'a, T, (), S, A>,\n}"
- "impl<T: fmt::Debug, S, A:"
- "::Debug, S, A: Allocator> fmt::"
- "Allocator> fmt::Debug for"
- "> fmt::Debug for VacantEntry<'_,"
- "VacantEntry<'_, T, S, A> {"
- "fn fmt(&self, f: &mut fmt::"
- ", f: &mut fmt::Formatter<'_>) ->"
- "<'_>) -> fmt::Result {"
- "f.debug_tuple(\"VacantEntry\")."
- "(\"VacantEntry\").field(self.get()"
- "field(self.get()).finish()\n    }"
- "    }\n}"
- "impl<'a, T, S, A: Allocator>"
- "S, A: Allocator> Entry<'a, T, S,"
- "Entry<'a, T, S, A> {"
- "/// Sets the value of the entry,"
- "of the entry, and returns an"
- ", and returns an OccupiedEntry."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- "/// let entry = set.entry(\""
- "= set.entry(\"horseyland\").insert"
- "\").insert();\n    ///"
- "    ///\n    /// assert_eq!("
- "entry.get(), &\"horseyland\");"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn insert(self) ->
- "insert(self) -> OccupiedEntry<'a"
- "OccupiedEntry<'a, T, S, A>"
- "    where\n        T: Hash,"
- "        S: BuildHasher,\n    {"
- "    {\n        match self {"
- "Entry::Occupied(entry) => entry,"
- "Entry::Vacant(entry) =>"
- "Vacant(entry) => entry.insert(),"
- "        }\n    }"
- /// Ensures a value is in the
- value is in the entry by
- in the entry by inserting if it
- inserting if it was vacant.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- ///
- /// // nonexistent key
- "/// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();"
- /// assert!(
- "set.contains(\"poneyland\"));"
- "    ///\n    /// // existing key"
- "/// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();"
- /// assert!(
- "set.contains(\"poneyland\"));"
- "/// assert_eq!(set.len(), 1);"
- "set.len(), 1);\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn or_insert(self)
- "    where\n        T: Hash,"
- "        S: BuildHasher,\n    {"
- "if let Entry::Vacant(entry) ="
- ":Vacant(entry) = self {"
- entry.insert();
- "        }\n    }"
- /// Returns a reference to this
- " to this entry's value.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- "/// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();"
- /// // existing key
- /// assert_eq!(
- "set.entry(\"poneyland\").get(), &\""
- "\").get(), &\"poneyland\");"
- /// // nonexistent key
- /// assert_eq!(
- "set.entry(\"horseland\").get(), &\""
- "\").get(), &\"horseland\");"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn get(&self) -> &T {"
- "match *self {"
- "Entry::Occupied(ref entry) =>"
- "(ref entry) => entry.get(),"
- "Entry::Vacant(ref entry) =>"
- "(ref entry) => entry.get(),"
- "        }\n    }\n}"
- "impl<T, S, A: Allocator>"
- "S, A: Allocator> OccupiedEntry<'"
- "OccupiedEntry<'_, T, S, A> {"
- /// Gets a reference to the
- reference to the value in the
- " the value in the entry.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet};"
- ///
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- "/// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();"
- ///
- "/// match set.entry(\"poneyland\")"
- "(\"poneyland\") {"
- "///     Entry::Vacant(_) =>"
- "::Vacant(_) => panic!(),"
- "///     Entry::Occupied(entry) ="
- (entry) => assert_eq!(
- "entry.get(), &\"poneyland\"),"
- "    /// }\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn get(&self) -> &T {"
- "        self.inner.key()\n    }"
- /// Takes the value out of the
- "value out of the entry, and"
- "the entry, and returns it."
- /// Keeps the allocated memory
- allocated memory for reuse.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_set::"
- "::hash_set::Entry;\n    ///"
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- /// // The set is empty
- /// assert!(
- set.is_empty() && set.capacity()
- "& set.capacity() == 0);\n    ///"
- "/// set.entry(\"poneyland\")."
- "(\"poneyland\").or_insert();"
- /// let capacity_before_remove =
- " = set.capacity();\n    ///"
- "/// if let Entry::Occupied(o) ="
- "::Occupied(o) = set.entry(\""
- "o) = set.entry(\"poneyland\") {"
- ///     assert_eq!(
- "o.remove(), \"poneyland\");"
- "    /// }\n    ///"
- "    ///\n    /// assert_eq!("
- "set.contains(\"poneyland\"), false"
- "\"), false);"
- /// // Now set hold none
- set hold none elements but
- elements but capacity is equal
- is equal to the old one
- /// assert!(
- set.len() == 0 && set.capacity()
- "& set.capacity() =="
- () == capacity_before_remove);
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn remove(self) -> T {"
- self.inner.remove_entry().0
- "}"
- "/// Replaces the entry,"
- "the entry, returning the old"
- the old value.
- The new value in the hash map
- in the hash map will be
- /// the value used to create
- used to create this entry.
- "    ///\n    /// # Panics\n    ///"
- /// Will panic if this
- panic if this OccupiedEntry was
- "was created through [`Entry::"
- " [`Entry::insert`].\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "///  use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet};"
- "///  use std::rc::Rc;"
- ///
- "///  let mut set: HashSet<Rc<"
- "set: HashSet<Rc<String>> ="
- "<Rc<String>> = HashSet::new();"
- "///  let key_one = Rc::new(\""
- "= Rc::new(\"Stringthing\"."
- "(\"Stringthing\".to_string());"
- "///  let key_two = Rc::new(\""
- "= Rc::new(\"Stringthing\"."
- "(\"Stringthing\".to_string());"
- ///
- ///  set.insert(key_one.clone())
- key_one.clone());
- ///  assert!(
- "Rc::strong_count(&key_one) == 2"
- "(&key_one) == 2 && Rc::"
- ") == 2 && Rc::strong_count(&"
- "::strong_count(&key_two) == 1);"
- ///
- ///  match set.entry(
- match set.entry(key_two.clone())
- "key_two.clone()) {"
- "///      Entry::Occupied(entry)"
- ":Occupied(entry) => {"
- "///          let old_key: Rc<"
- "let old_key: Rc<String> ="
- ": Rc<String> = entry.replace();"
- ///          assert!(
- "Rc::ptr_eq(&key_one, &old_key));"
- "///      }"
- "///      Entry::Vacant(_) =>"
- "::Vacant(_) => panic!(),"
- "    ///  }\n    ///"
- "    ///\n    ///  assert!("
- "Rc::strong_count(&key_one) == 1"
- "(&key_one) == 1 && Rc::"
- ") == 1 && Rc::strong_count(&"
- "::strong_count(&key_two) == 2);"
- ///  assert!(
- "set.contains(&\"Stringthing\"."
- "(&\"Stringthing\".to_owned()));"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn replace(self) -> T {"
- self.inner.replace_key()
- "    }\n}"
- "impl<'a, T, S, A: Allocator>"
- "S, A: Allocator> VacantEntry<'a,"
- "VacantEntry<'a, T, S, A> {"
- /// Gets a reference to the
- reference to the value that
- the value that would be used
- would be used when inserting
- "/// through the `VacantEntry`."
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- ///
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- /// assert_eq!(
- "set.entry(\"poneyland\").get(), &\""
- "\").get(), &\"poneyland\");"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn get(&self) -> &T {"
- "        self.inner.key()\n    }"
- /// Take ownership of the value.
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::hash_set::{"
- "::hash_set::{Entry, HashSet};"
- ///
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- ///
- "/// match set.entry(\"poneyland\")"
- "(\"poneyland\") {"
- "///     Entry::Occupied(_) =>"
- "::Occupied(_) => panic!(),"
- "///     Entry::Vacant(v) =>"
- "::Vacant(v) => assert_eq!("
- "v.into_value(), \"poneyland\"),"
- "    /// }\n    /// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- "pub fn into_value(self) -> T {"
- self.inner.into_key()
- "}"
- /// Sets the value of the entry
- of the entry with the
- "entry with the VacantEntry's"
- " VacantEntry's value.\n    ///"
- "    ///\n    /// # Examples"
- "    /// # Examples\n    ///"
- "    ///\n    /// ```"
- "/// use hashbrown::HashSet;"
- "/// use hashbrown::hash_set::"
- "::hash_set::Entry;\n    ///"
- "/// let mut set: HashSet<&str> ="
- "HashSet<&str> = HashSet::new();"
- ///
- "/// if let Entry::Vacant(o) ="
- "::Vacant(o) = set.entry(\""
- "o) = set.entry(\"poneyland\") {"
- ///     o.insert();
- "    /// }\n    /// assert!("
- "set.contains(\"poneyland\"));"
- "/// ```"
- "#[cfg_attr(feature = \"inline-"
- "= \"inline-more\", inline)]"
- pub fn insert(self) ->
- "insert(self) -> OccupiedEntry<'a"
- "OccupiedEntry<'a, T, S, A>"
- "    where\n        T: Hash,"
- "        S: BuildHasher,\n    {"
- "    {\n        OccupiedEntry {"
- "inner: self.inner.insert_entry(("
- "(()),\n        }\n    }\n}"
- "    }\n}\n\n#[allow(dead_code)]"
- "fn assert_covariance() {"
- "fn set<'new>(v: HashSet<&'static"
- "HashSet<&'static str>) ->"
- "'static str>) -> HashSet<&'new"
- "-> HashSet<&'new str> {"
- "        v\n    }"
- "fn iter<'a, 'new>(v: Iter<'a, &'"
- ">(v: Iter<'a, &'static str>) ->"
- "'static str>) -> Iter<'a, &'new"
- "> Iter<'a, &'new str> {"
- "        v\n    }"
- "fn into_iter<'new, A: Allocator>"
- ", A: Allocator>(v: IntoIter<&'"
- ">(v: IntoIter<&'static str, A>)"
- "'static str, A>) -> IntoIter<&'"
- ") -> IntoIter<&'new str, A> {"
- "        v\n    }"
- "fn difference<'a, 'new, A:"
- "<'a, 'new, A: Allocator>("
- "v: Difference<'a, &'static str,"
- "&'static str, DefaultHashBuilder"
- ", A>,"
- ") -> Difference<'a, &'new str,"
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }"
- "fn symmetric_difference<'a, 'new"
- "<'a, 'new, A: Allocator>("
- "v: SymmetricDifference<'a, &'"
- "<'a, &'static str,"
- "&'static str, DefaultHashBuilder"
- ", A>,"
- ") -> SymmetricDifference<'a, &'"
- "<'a, &'new str,"
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }"
- "fn intersection<'a, 'new, A:"
- "<'a, 'new, A: Allocator>("
- "v: Intersection<'a, &'static str"
- "'a, &'static str,"
- "&'static str, DefaultHashBuilder"
- ", A>,"
- ") -> Intersection<'a, &'new str,"
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }"
- "fn union<'a, 'new, A: Allocator>"
- ", A: Allocator>("
- "v: Union<'a, &'static str,"
- "&'static str, DefaultHashBuilder"
- ", A>,"
- ") -> Union<'a, &'new str,"
- "a, &'new str, DefaultHashBuilder"
- ", A> {\n        v\n    }"
- "fn drain<'new, A: Allocator>(d:"
- "A: Allocator>(d: Drain<'static,"
- ": Drain<'static, &'static str, A"
- "&'static str, A>) -> Drain<'new,"
- ") -> Drain<'new, &'new str, A> {"
- "        d\n    }\n}\n\n#[cfg(test)]"
- "}\n\n#[cfg(test)]\nmod test_set {"
- "use super::super::map::"
- "::super::map::DefaultHashBuilder"
- ";\n    use super::HashSet;"
- "use std::vec::Vec;"
- "#[test]"
- "fn test_zero_capacities() {"
- type HS = HashSet<i32>;
- "let s = HS::new();"
- "assert_eq!(s.capacity(), 0);"
- "let s = HS::default();"
- "assert_eq!(s.capacity(), 0);"
- "let s = HS::with_hasher("
- "::with_hasher(DefaultHashBuilder"
- "::default());"
- "assert_eq!(s.capacity(), 0);"
- "let s = HS::with_capacity(0);"
- "assert_eq!(s.capacity(), 0);"
- "let s = HS::"
- "s = HS::with_capacity_and_hasher"
- "(0, DefaultHashBuilder::default("
- "::default());"
- "assert_eq!(s.capacity(), 0);"
- "let mut s = HS::new();"
- s.insert(1);
- s.insert(2);
- s.remove(&1);
- s.remove(&2);
- s.shrink_to_fit();
- "assert_eq!(s.capacity(), 0);"
- "let mut s = HS::new();"
- s.reserve(0);
- "assert_eq!(s.capacity(), 0);"
- "    }\n\n    #[test]"
- "fn test_disjoint() {"
- "let mut xs = HashSet::new();"
- "let mut ys = HashSet::new();"
- assert!(xs.is_disjoint(&ys));
- assert!(ys.is_disjoint(&xs));
- assert!(xs.insert(5));
- "xs.insert(5));\n        assert!("
- assert!(ys.insert(11));
- "ys.insert(11));\n        assert!("
- assert!(xs.is_disjoint(&ys));
- assert!(ys.is_disjoint(&xs));
- assert!(xs.insert(7));
- "xs.insert(7));\n        assert!("
- assert!(xs.insert(19));
- "xs.insert(19));\n        assert!("
- assert!(xs.insert(4));
- "xs.insert(4));\n        assert!("
- assert!(ys.insert(2));
- "ys.insert(2));\n        assert!("
- assert!(ys.insert(-11));
- assert!(xs.is_disjoint(&ys));
- assert!(ys.is_disjoint(&xs));
- assert!(ys.insert(7));
- "ys.insert(7));\n        assert!(!"
- assert!(!xs.is_disjoint(&ys));
- assert!(!ys.is_disjoint(&xs));
- "    }\n\n    #[test]"
- "fn test_subset_and_superset() {"
- "let mut a = HashSet::new();"
- assert!(a.insert(0));
- "a.insert(0));\n        assert!("
- assert!(a.insert(5));
- "a.insert(5));\n        assert!("
- assert!(a.insert(11));
- "a.insert(11));\n        assert!("
- assert!(a.insert(7));
- "let mut b = HashSet::new();"
- assert!(b.insert(0));
- "b.insert(0));\n        assert!("
- assert!(b.insert(7));
- "b.insert(7));\n        assert!("
- assert!(b.insert(19));
- "b.insert(19));\n        assert!("
- assert!(b.insert(250));
- "b.insert(250));\n        assert!("
- assert!(b.insert(11));
- "b.insert(11));\n        assert!("
- assert!(b.insert(200));
- assert!(!a.is_subset(&b));
- assert!(!a.is_superset(&b));
- assert!(!b.is_subset(&a));
- assert!(!b.is_superset(&a));
- assert!(b.insert(5));
- "b.insert(5));\n\n        assert!("
- assert!(a.is_subset(&b));
- assert!(!a.is_superset(&b));
- assert!(!b.is_subset(&a));
- assert!(b.is_superset(&a));
- "    }\n\n    #[test]"
- "fn test_iterate() {"
- "let mut a = HashSet::new();"
- "for i in 0..32 {"
- assert!(a.insert(i));
- "a.insert(i));\n        }"
- "let mut observed: u32 = 0;"
- "for k in &a {"
- observed |= 1 << *k;
- "        }\n        assert_eq!("
- "observed, 0xFFFF_FFFF);\n    }"
- "    }\n\n    #[test]"
- "fn test_intersection() {"
- "let mut a = HashSet::new();"
- "let mut b = HashSet::new();"
- assert!(a.insert(11));
- "a.insert(11));\n        assert!("
- assert!(a.insert(1));
- "a.insert(1));\n        assert!("
- assert!(a.insert(3));
- "a.insert(3));\n        assert!("
- assert!(a.insert(77));
- "a.insert(77));\n        assert!("
- assert!(a.insert(103));
- "a.insert(103));\n        assert!("
- assert!(a.insert(5));
- "a.insert(5));\n        assert!("
- assert!(a.insert(-5));
- "a.insert(-5));\n\n        assert!("
- assert!(b.insert(2));
- "b.insert(2));\n        assert!("
- assert!(b.insert(11));
- "b.insert(11));\n        assert!("
- assert!(b.insert(77));
- "b.insert(77));\n        assert!("
- assert!(b.insert(-9));
- "b.insert(-9));\n        assert!("
- assert!(b.insert(-42));
- "b.insert(-42));\n        assert!("
- assert!(b.insert(5));
- "b.insert(5));\n        assert!("
- assert!(b.insert(3));
- let mut i = 0;
- "let expected = [3, 5, 11, 77];"
- "for x in a.intersection(&b) {"
- assert!(expected.contains(x));
- "            i += 1;\n        }"
- "        }\n        assert_eq!("
- "assert_eq!(i, expected.len());"
- "    }\n\n    #[test]"
- "fn test_difference() {"
- "let mut a = HashSet::new();"
- "let mut b = HashSet::new();"
- assert!(a.insert(1));
- "a.insert(1));\n        assert!("
- assert!(a.insert(3));
- "a.insert(3));\n        assert!("
- assert!(a.insert(5));
- "a.insert(5));\n        assert!("
- assert!(a.insert(9));
- "a.insert(9));\n        assert!("
- assert!(a.insert(11));
- "a.insert(11));\n\n        assert!("
- assert!(b.insert(3));
- "b.insert(3));\n        assert!("
- assert!(b.insert(9));
- let mut i = 0;
- "let expected = [1, 5, 11];"
- "for x in a.difference(&b) {"
- assert!(expected.contains(x));
- "            i += 1;\n        }"
- "        }\n        assert_eq!("
- "assert_eq!(i, expected.len());"
- "    }\n\n    #[test]"
- "fn test_symmetric_difference() {"
- "let mut a = HashSet::new();"
- "let mut b = HashSet::new();"
- assert!(a.insert(1));
- "a.insert(1));\n        assert!("
- assert!(a.insert(3));
- "a.insert(3));\n        assert!("
- assert!(a.insert(5));
- "a.insert(5));\n        assert!("
- assert!(a.insert(9));
- "a.insert(9));\n        assert!("
- assert!(a.insert(11));
- "a.insert(11));\n\n        assert!("
- assert!(b.insert(-2));
- "b.insert(-2));\n        assert!("
- assert!(b.insert(3));
- "b.insert(3));\n        assert!("
- assert!(b.insert(9));
- "b.insert(9));\n        assert!("
- assert!(b.insert(14));
- "b.insert(14));\n        assert!("
- assert!(b.insert(22));
- let mut i = 0;
- "let expected = [-2, 1, 5, 11, 14"
- "-2, 1, 5, 11, 14, 22];"
- for x in a.symmetric_difference(
- "(&b) {\n            assert!("
- assert!(expected.contains(x));
- "            i += 1;\n        }"
- "        }\n        assert_eq!("
- "assert_eq!(i, expected.len());"
- "    }\n\n    #[test]"
- "fn test_union() {"
- "let mut a = HashSet::new();"
- "let mut b = HashSet::new();"
- assert!(a.insert(1));
- "a.insert(1));\n        assert!("
- assert!(a.insert(3));
- "a.insert(3));\n        assert!("
- assert!(a.insert(5));
- "a.insert(5));\n        assert!("
- assert!(a.insert(9));
- "a.insert(9));\n        assert!("
- assert!(a.insert(11));
- "a.insert(11));\n        assert!("
- assert!(a.insert(16));
- "a.insert(16));\n        assert!("
- assert!(a.insert(19));
- "a.insert(19));\n        assert!("
- assert!(a.insert(24));
- "a.insert(24));\n\n        assert!("
- assert!(b.insert(-2));
- "b.insert(-2));\n        assert!("
- assert!(b.insert(1));
- "b.insert(1));\n        assert!("
- assert!(b.insert(5));
- "b.insert(5));\n        assert!("
- assert!(b.insert(9));
- "b.insert(9));\n        assert!("
- assert!(b.insert(13));
- "b.insert(13));\n        assert!("
- assert!(b.insert(19));
- let mut i = 0;
- "let expected = [-2, 1, 3, 5, 9,"
- "[-2, 1, 3, 5, 9, 11, 13, 16, 19,"
- "11, 13, 16, 19, 24];"
- "for x in a.union(&b) {"
- assert!(expected.contains(x));
- "            i += 1;\n        }"
- "        }\n        assert_eq!("
- "assert_eq!(i, expected.len());"
- "    }\n\n    #[test]"
- "fn test_from_map() {"
- "let mut a = crate::HashMap::new("
- "::HashMap::new();"
- "a.insert(1, ());"
- "a.insert(2, ());"
- "a.insert(3, ());"
- "a.insert(4, ());"
- "let a: HashSet<_> = a.into();"
- "assert_eq!(a.len(), 4);"
- "a.len(), 4);\n        assert!("
- assert!(a.contains(&1));
- assert!(a.contains(&2));
- assert!(a.contains(&3));
- assert!(a.contains(&4));
- "a.contains(&4));\n    }"
- "    }\n\n    #[test]"
- "fn test_from_iter() {"
- "let xs = [1, 2, 2, 3, 4, 5, 6, 7"
- "2, 3, 4, 5, 6, 7, 8, 9];"
- "let set: HashSet<_> = xs.iter()."
- "<_> = xs.iter().copied().collect"
- copied().collect();
- "for x in &xs {"
- assert!(set.contains(x));
- "        }\n\n        assert_eq!("
- "set.iter().len(), xs.len() - 1);"
- "    }\n\n    #[test]"
- "fn test_move_iter() {"
- "let hs = {"
- "let mut hs = HashSet::new();"
- "hs.insert('a');"
- "hs.insert('b');"
- "            hs\n        };"
- "let v = hs.into_iter().collect::"
- "().collect::<Vec<char>>();"
- assert!(
- "v == ['a', 'b'] || v == ['b', 'a"
- " || v == ['b', 'a']);\n    }"
- "    }\n\n    #[test]"
- "    #[test]\n    fn test_eq() {"
- // These constants once happened
- once happened to expose a bug in
- expose a bug in insert().
- "// I'm keeping them around to"
- them around to prevent a
- to prevent a regression.
- "let mut s1 = HashSet::new();"
- s1.insert(1);
- s1.insert(2);
- s1.insert(3);
- "let mut s2 = HashSet::new();"
- s2.insert(1);
- s2.insert(2);
- assert!(s1 != s2);
- "= s2);\n\n        s2.insert(3);"
- "assert_eq!(s1, s2);"
- "s1, s2);\n    }\n\n    #[test]"
- "    #[test]\n    fn test_show() {"
- "let mut set = HashSet::new();"
- "let empty = HashSet::<i32>::new("
- "::<i32>::new();"
- set.insert(1);
- set.insert(2);
- "let set_str = format!(\"{set:?}\")"
- "set:?}\");\n\n        assert!("
- "set_str == \"{1, 2}\" || set_str ="
- "2}\" || set_str == \"{2, 1}\");"
- "assert_eq!(format!(\"{"
- "format!(\"{empty:?}\"), \"{}\");"
- "    }\n\n    #[test]"
- "fn test_trivial_drain() {"
- "let mut s = HashSet::<i32>::new("
- "::<i32>::new();"
- "for _ in s.drain() {}"
- assert!(s.is_empty());
- "s.is_empty());\n        drop(s);"
- "let mut s = HashSet::<i32>::new("
- "::<i32>::new();"
- drop(s.drain());
- assert!(s.is_empty());
- "s.is_empty());\n    }"
- "    }\n\n    #[test]"
- "fn test_drain() {"
- "let mut s: HashSet<_> = (1..100)"
- "<_> = (1..100).collect();"
- // try this a bunch of times to
- "of times to make sure we don't"
- "sure we don't screw up internal"
- up internal state.
- "for _ in 0..20 {"
- "assert_eq!(s.len(), 99);"
- "s.len(), 99);\n\n            {"
- let mut last_i = 0;
- let mut d = s.drain();
- "for (i, x) in d.by_ref().take(50"
- "().take(50).enumerate() {"
- last_i = i;
- assert!(x != 0);
- "x != 0);\n                }"
- "assert_eq!(last_i, 49);"
- "last_i, 49);\n            }"
- "            }\n\n            if !"
- "if !s.is_empty() {"
- "panic!(\"s should be empty!\");"
- ";\n            }"
- // reset to try again.
- s.extend(1..100);
- "        }\n    }\n\n    #[test]"
- "fn test_replace() {"
- "use core::hash;"
- "#[derive(Debug)]"
- "#[allow(dead_code)]"
- "struct Foo(&'static str, i32);"
- "impl PartialEq for Foo {"
- "fn eq(&self, other: &Self) ->"
- "other: &Self) -> bool {"
- self.0 == other.0
- "            }\n        }"
- "impl Eq for Foo {}"
- "impl hash::Hash for Foo {"
- "fn hash<H: hash::Hasher>(&self,"
- "::Hasher>(&self, h: &mut H) {"
- self.0.hash(h);
- "            }\n        }"
- "let mut s = HashSet::new();"
- assert_eq!(
- "s.replace(Foo(\"a\", 1)), None);"
- "assert_eq!(s.len(), 1);"
- "s.len(), 1);\n        assert_eq!("
- "s.replace(Foo(\"a\", 2)), Some(Foo"
- "\", 2)), Some(Foo(\"a\", 1)));"
- "assert_eq!(s.len(), 1);"
- let mut it = s.iter();
- assert_eq!(
- "it.next(), Some(&Foo(\"a\", 2)));"
- "assert_eq!(it.next(), None);"
- "    }\n\n    #[test]"
- "#[allow(clippy::needless_borrow)"
- "needless_borrow)]"
- "fn test_extend_ref() {"
- "let mut a = HashSet::new();"
- a.insert(1);
- "a.extend([2, 3, 4]);"
- "assert_eq!(a.len(), 4);"
- "a.len(), 4);\n        assert!("
- assert!(a.contains(&1));
- assert!(a.contains(&2));
- assert!(a.contains(&3));
- assert!(a.contains(&4));
- "let mut b = HashSet::new();"
- b.insert(5);
- b.insert(6);
- a.extend(&b);
- "assert_eq!(a.len(), 6);"
- "a.len(), 6);\n        assert!("
- assert!(a.contains(&1));
- assert!(a.contains(&2));
- assert!(a.contains(&3));
- assert!(a.contains(&4));
- assert!(a.contains(&5));
- assert!(a.contains(&6));
- "a.contains(&6));\n    }"
- "    }\n\n    #[test]"
- "fn test_retain() {"
- "let xs = [1, 2, 3, 4, 5, 6];"
- "let mut set: HashSet<i32> ="
- ": HashSet<i32> = xs.iter()."
- "> = xs.iter().copied().collect()"
- ().collect();
- set.retain(|&k| k % 2 == 0);
- "assert_eq!(set.len(), 3);"
- "set.len(), 3);\n        assert!("
- assert!(set.contains(&2));
- assert!(set.contains(&4));
- assert!(set.contains(&6));
- "    }\n\n    #[test]"
- "fn test_extract_if() {"
- "{"
- "let mut set: HashSet<i32> = (0.."
- "<i32> = (0..8).collect();"
- let drained = set.extract_if(|&k
- (|&k| k % 2 == 0);
- "let mut out = drained.collect::<"
- "::<Vec<_>>();"
- out.sort_unstable();
- "assert_eq!(vec!["
- "vec![0, 2, 4, 6], out);"
- "assert_eq!(set.len(), 4);"
- "set.len(), 4);\n        }"
- "        }\n        {"
- "let mut set: HashSet<i32> = (0.."
- "<i32> = (0..8).collect();"
- set.extract_if(|&k| k % 2 == 0).
- "&k| k % 2 == 0).for_each(drop);"
- assert_eq!(
- "set.len(), 4, \"Removes non-"
- "4, \"Removes non-matching items"
- "-matching items on drop\");"
- "        }\n    }\n\n    #[test]"
- "fn test_const_with_hasher() {"
- "use core::hash::BuildHasher;"
- "use std::collections::hash_map::"
- "::hash_map::DefaultHasher;"
- "#[derive(Clone)]"
- struct MyHasher;
- "impl BuildHasher for MyHasher {"
- type Hasher = DefaultHasher;
- fn build_hasher(&self) ->
- "(&self) -> DefaultHasher {"
- "DefaultHasher::new()"
- "            }\n        }"
- "const EMPTY_SET: HashSet<u32,"
- ": HashSet<u32, MyHasher> ="
- "u32, MyHasher> = HashSet::"
- "> = HashSet::with_hasher("
- "::with_hasher(MyHasher);"
- let mut set = EMPTY_SET;
- set.insert(19);
- assert!(set.contains(&19));
- "    }\n\n    #[test]"
- "fn rehash_in_place() {"
- "let mut set = HashSet::new();"
- "for i in 0..224 {"
- set.insert(i);
- "        }\n\n        assert_eq!("
- "set.capacity(),"
- "224,"
- "\"The set must be at or close to"
- at or close to capacity to
- to capacity to trigger a re
- "to trigger a re hashing\""
- );
- "for i in 100..1400 {"
- set.remove(&(i - 100));
- set.insert(i);
- "        }\n    }\n\n    #[test]"
- "    #[test]\n    fn collect() {"
- "// At the time of writing, this"
- "of writing, this hits the ZST"
- hits the ZST case in
- the ZST case in from_base_index
- "// (and without the `map`, it"
- "the `map`, it does not)."
- "let mut _set: HashSet<_> = (0..3"
- "<_> = (0..3).map(|_| ()).collect"
- "(|_| ()).collect();\n    }\n}"
